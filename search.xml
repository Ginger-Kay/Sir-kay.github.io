<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Codeforce 1119D Frets On Fire 题解]]></title>
    <url>%2F2019%2F09%2F14%2FCodeforce-1119D-Frets-On-Fire-%E9%A2%98%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[Codeforce 1119D Frets On Fire 题解题意给定$n$和$s_1,s_2,\dots,s_n$，由此得到一个$n\times(10^{18}+1)$的矩阵$f$，其中$f_{i,j}=s_i+j (1\le i\le n,0\le j\le 10^{18})$。 在样例$1$中，给定$n=6,s=[3,1,4,1,5,9]$，得到 \begin{matrix} \textbf{f} & \textbf{0} & \textbf{1} & \textbf{2} & \textbf{3} & \textbf{4} & \textbf{5} & \textbf{6} & \textbf{7} & \ldots \\ s_1: & 3 & 4 & 5 & 6 & 7 & 8 & 9 & 10 & \dots \\ s_2: & 1 & 2 & 3 & 4 & 5 & 6 & 7 & 8 & \dots \\ s_3: & 4 & 5 & 6 & 7 & 8 & 9 & 10 & 11 & \dots \\ s_4: & 1 & 2 & 3 & 4 & 5 & 6 & 7 & 8 & \dots \\ s_5: & 5 & 6 & 7 & 8 & 9 & 10 & 11 & 12 & \dots \\ s_6: & 9 & 10 & 11 & 12 & 13 & 14 & 15 & 16 & \dots \end{matrix}再给定$q$个查询，每个查询有$L,R$，问第$L$列到第$R$列(以下表达为$[L,R]$)有多少个不同的数。 题解因为问的是列，所以行的顺序不重要，可以对$s$进行从小到大排序。 对样例$1$排完序之后矩阵变为 \begin{matrix} \textbf{f} & \textbf{0} & \textbf{1} & \textbf{2} & \textbf{3} & \textbf{4} & \textbf{5} & \textbf{6} & \textbf{7} & \ldots \\ s_1: & 1 & 2 & 3 & 4 & 5 & 6 & 7 & 8 & \dots \\ s_2: & 1 & 2 & 3 & 4 & 5 & 6 & 7 & 8 & \dots \\ s_3: & 3 & 4 & 5 & 6 & 7 & 8 & 9 & 10 & \dots \\ s_4: & 4 & 5 & 6 & 7 & 8 & 9 & 10 & 11 & \dots \\ s_5: & 5 & 6 & 7 & 8 & 9 & 10 & 11 & 12 & \dots \\ s_6: & 9 & 10 & 11 & 12 & 13 & 14 & 15 & 16 & \dots \end{matrix}还有：查询$[L,R]$与查询$[0,R-L]$是等价的。 定义$r=R-L,w=r+1$。 考虑当每一行对于整个矩阵的贡献。 对于样例$1$： 第$1$行贡献了$0$个数$\{\varnothing\}$； 第$2$行贡献了$2$个数$\{1,2\}$； 第$3$行贡献了$1$个数$\{3\}$； 第$4$行贡献了$1$个数$\{4\}$； 第$5$行贡献了$4$个数$\{5,6,7,8\}$； 第$6$行没有贡献。 很容易发现，第$i$行的贡献为$s_{i+1}-s_i$。 对于任意区间$[0,r]$，第$i$行的贡献即为$\min\{s_{i+1}-s_i,w\}$。 那么答案即为$\sum_{i=1}^{n-1}{\min\{s_{i+1}-s_i,w\}}$。 问题：时间复杂度为$O(n\cdot q)$。 解答：设数组$t$，其中$t_i=s_{i+1}-s_i (1\le i&lt;n)$，将$t$从从小到大排序。设$p$为满足$t_p\le w$的最小值(用二分，时间复杂度为$O(\log n)$)，那么答案为$t_1+t_2+\dots+t_p+w\times(n-p)$($t_1+t_2+\dots+t_p$用前缀和求出)。时间复杂度为$O(\log n\cdot q)$。 程序123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202// #pragma GCC optimize(2)// #pragma G++ optimize(2)// #pragma comment(linker,"/STACK:102400000,102400000")// #include &lt;bits/stdc++.h&gt;#include &lt;map&gt;#include &lt;set&gt;#include &lt;list&gt;#include &lt;array&gt;#include &lt;cfenv&gt;#include &lt;cmath&gt;#include &lt;ctime&gt;#include &lt;deque&gt;#include &lt;mutex&gt;#include &lt;queue&gt;#include &lt;ratio&gt;#include &lt;regex&gt;#include &lt;stack&gt;#include &lt;tuple&gt;#include &lt;atomic&gt;#include &lt;bitset&gt;#include &lt;cctype&gt;#include &lt;cerrno&gt;#include &lt;cfloat&gt;#include &lt;chrono&gt;#include &lt;cstdio&gt;#include &lt;cwchar&gt;#include &lt;future&gt;#include &lt;limits&gt;#include &lt;locale&gt;#include &lt;memory&gt;#include &lt;random&gt;#include &lt;string&gt;#include &lt;thread&gt;#include &lt;vector&gt;#include &lt;cassert&gt;#include &lt;climits&gt;#include &lt;clocale&gt;#include &lt;complex&gt;#include &lt;csetjmp&gt;#include &lt;csignal&gt;#include &lt;cstdarg&gt;#include &lt;cstddef&gt;#include &lt;cstdint&gt;#include &lt;cstdlib&gt;#include &lt;cstring&gt;#include &lt;ctgmath&gt;#include &lt;cwctype&gt;#include &lt;fstream&gt;#include &lt;iomanip&gt;#include &lt;numeric&gt;#include &lt;sstream&gt;#include &lt;ccomplex&gt;#include &lt;cstdbool&gt;#include &lt;iostream&gt;#include &lt;typeinfo&gt;#include &lt;valarray&gt;#include &lt;algorithm&gt;#include &lt;cinttypes&gt;#include &lt;cstdalign&gt;#include &lt;stdexcept&gt;#include &lt;typeindex&gt;#include &lt;functional&gt;#include &lt;forward_list&gt;#include &lt;system_error&gt;#include &lt;unordered_map&gt;#include &lt;unordered_set&gt;#include &lt;scoped_allocator&gt;#include &lt;condition_variable&gt;// #include &lt;conio.h&gt;// #include &lt;windows.h&gt;using namespace std;typedef long long LL;typedef unsigned int ui;typedef unsigned long long ull;typedef float fl;typedef double ld;typedef long double LD;typedef pair&lt;int,int&gt; pii;#if (WIN32) || (WIN64) || (__WIN32) || (__WIN64) || (_WIN32) || (_WIN64) || (WINDOWS)#define lld "%I64d"#define llu "%I64u"#else#define lld "%lld"#define llu "%llu"#endif#define ui(n) ((unsigned int)(n))#define LL(n) ((long long)(n))#define ull(n) ((unsigned long long)(n))#define fl(n) ((float)(n))#define ld(n) ((double)(n))#define LD(n) ((long double)(n))#define char(n) ((char)(n))#define Bool(n) ((bool)(n))#define fixpoint(n) fixed&lt;&lt;setprecision(n)const int INF=1061109567;const int NINF=-1044266559;const LL LINF=4557430888798830399;const ld eps=1e-15;#define MOD (1000000007)#define PI (3.1415926535897932384626433832795028841971)/*#define MB_LEN_MAX 5#define SHRT_MIN (-32768)#define SHRT_MAX 32767#define USHRT_MAX 0xffffU#define INT_MIN (-2147483647 - 1)#define INT_MAX 2147483647#define UINT_MAX 0xffffffffU#define LONG_MIN (-2147483647L - 1)#define LONG_MAX 2147483647L#define ULONG_MAX 0xffffffffUL#define LLONG_MAX 9223372036854775807ll#define LLONG_MIN (-9223372036854775807ll - 1)#define ULLONG_MAX 0xffffffffffffffffull*/#define MP make_pair#define MT make_tuple#define All(a) (a).begin(),(a).end()#define pall(a) (a).rbegin(),(a).rend()#define Log(x,y) log(x)/log(y)#define SZ(a) ((int)(a).size())#define rep(i,n) for(int i=0;i&lt;((int)(n));i++)#define rep1(i,n) for(int i=1;i&lt;=((int)(n));i++)#define repa(i,a,n) for(int i=((int)(a));i&lt;((int)(n));i++)#define repa1(i,a,n) for(int i=((int)(a));i&lt;=((int)(n));i++)#define repd(i,n) for(int i=((int)(n))-1;i&gt;=0;i--)#define repd1(i,n) for(int i=((int)(n));i&gt;=1;i--)#define repda(i,n,a) for(int i=((int)(n));i&gt;((int)(a));i--)#define repda1(i,n,a) for(int i=((int)(n));i&gt;=((int)(a));i--)#define FOR(i,a,n,step) for(int i=((int)(a));i&lt;((int)(n));i+=((int)(step)))#define repv(itr,v) for(__typeof((v).begin()) itr=(v).begin();itr!=(v).end();itr++)#define repV(i,v) for(auto i:v)#define repE(i,v) for(auto &amp;i:v)#define MS(x,y) memset(x,y,sizeof(x))#define MC(x) MS(x,0)#define MINF(x) MS(x,63)#define MCP(x,y) memcpy(x,y,sizeof(y))#define sqr(x) ((x)*(x))#define UN(v) sort(All(v)),v.erase(unique(All(v)),v.end())#define filein(x) freopen(x,"r",stdin)#define fileout(x) freopen(x,"w",stdout)#define fileio(x)\ freopen(x".in","r",stdin);\ freopen(x".out","w",stdout)#define filein2(filename,name) ifstream name(filename,ios::in)#define fileout2(filename,name) ofstream name(filename,ios::out)#define file(filename,name) fstream name(filename,ios::in|ios::out)#define Pause system("pause")#define Cls system("cls")#define fs first#define sc second#define PC(x) putchar(x)#define GC(x) x=getchar()#define Endl PC('\n')#define SF scanf#define PF printfinline int Read()&#123; int X=0,w=0;char ch=0;while(!isdigit(ch))&#123;w|=ch=='-';ch=getchar();&#125;while(isdigit(ch))X=(X&lt;&lt;3)+(X&lt;&lt;1)+(ch^48),ch=getchar(); return w?-X:X;&#125;inline void Write(int x)&#123;if(x&lt;0)putchar('-'),x=-x;if(x&gt;9)Write(x/10);putchar(x%10+'0');&#125;inline LL powmod(LL a,LL b)&#123;LL RES=1;a%=MOD;assert(b&gt;=0);for(;b;b&gt;&gt;=1)&#123;if(b&amp;1)RES=RES*a%MOD;a=a*a%MOD;&#125;return RES%MOD;&#125;inline LL gcdll(LL a,LL b)&#123;return b?gcdll(b,a%b):a;&#125;const int dx[]=&#123;0,1,0,-1,1,-1,-1,1&#125;;const int dy[]=&#123;1,0,-1,0,-1,-1,1,1&#125;;/************************************************************Begin************************************************************/const int maxn=100010;int n,q;LL s[maxn],pre[maxn],L,R;int main()&#123; SF("%d",&amp;n); rep1(i,n) SF("%lld",&amp;s[i]); sort(s+1,s+n+1); rep1(i,n-1) s[i]=s[i+1]-s[i]; sort(s+1,s+n); rep1(i,n-1) pre[i]=pre[i-1]+s[i]; SF("%d",&amp;q); while(q--) &#123; SF("%lld%lld",&amp;L,&amp;R); LL w=R-L+1;int id=lower_bound(s+1,s+n,w)-(s+1); PF("%lld ",pre[id]+(n-id)*w); &#125; return 0;&#125;/*************************************************************End**************************************************************/]]></content>
      <categories>
        <category>算法</category>
        <category>Codeforces</category>
      </categories>
      <tags>
        <tag>排序</tag>
        <tag>二分</tag>
        <tag>前缀和</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Codeforces 309B Context Advertising 题解]]></title>
    <url>%2F2019%2F09%2F08%2FCodeforces-309B-Context-Advertising-%E9%A2%98%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[Codeforces 309B Context Advertising 题解题意给定$n,r,c$和一个由$n$个单词组成的句子(两两单词之间有一个空格)，在这个句子里选出若干个连续的单词，组成一个“矩阵”，行数不能超过$r$，每行字符数不能超过$c$(包括空格)，不能把一个单词拆开。求合法矩阵中，单词数最多的那个矩阵，并输出。 题解题目要求组成一个$r\times c$的矩阵。 先考虑每行字符数的这个条件。设这个句子为$s_0,s_1,\dots,s_{n-1}$，对于一个单词$i(0\le i&lt; n)$，找出一个最大的$j(i&lt;j\le n)$，满足$|s_i|+|s_{i+1}|+\dots+|s_{j-1}|+(j-i-1)\le c$，从$i$到$j$连一条无向边。这个过程可以用双指针或二分完成。这样，就构造了一棵树。 再考虑行数这个条件。对于树上每个结点$i$，用倍增求出它的$r$辈祖先$j$，那么这若干个连续单词的长度是$j-i$。找出最大长度，输出即可。 程序(双指针+倍增)123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246// #pragma GCC optimize(2)// #pragma G++ optimize(2)// #pragma comment(linker,"/STACK:102400000,102400000")// #include &lt;bits/stdc++.h&gt;#include &lt;map&gt;#include &lt;set&gt;#include &lt;list&gt;#include &lt;array&gt;#include &lt;cfenv&gt;#include &lt;cmath&gt;#include &lt;ctime&gt;#include &lt;deque&gt;#include &lt;mutex&gt;#include &lt;queue&gt;#include &lt;ratio&gt;#include &lt;regex&gt;#include &lt;stack&gt;#include &lt;tuple&gt;#include &lt;atomic&gt;#include &lt;bitset&gt;#include &lt;cctype&gt;#include &lt;cerrno&gt;#include &lt;cfloat&gt;#include &lt;chrono&gt;#include &lt;cstdio&gt;#include &lt;cwchar&gt;#include &lt;future&gt;#include &lt;limits&gt;#include &lt;locale&gt;#include &lt;memory&gt;#include &lt;random&gt;#include &lt;string&gt;#include &lt;thread&gt;#include &lt;vector&gt;#include &lt;cassert&gt;#include &lt;climits&gt;#include &lt;clocale&gt;#include &lt;complex&gt;#include &lt;csetjmp&gt;#include &lt;csignal&gt;#include &lt;cstdarg&gt;#include &lt;cstddef&gt;#include &lt;cstdint&gt;#include &lt;cstdlib&gt;#include &lt;cstring&gt;#include &lt;ctgmath&gt;#include &lt;cwctype&gt;#include &lt;fstream&gt;#include &lt;iomanip&gt;#include &lt;numeric&gt;#include &lt;sstream&gt;#include &lt;ccomplex&gt;#include &lt;cstdbool&gt;#include &lt;iostream&gt;#include &lt;typeinfo&gt;#include &lt;valarray&gt;#include &lt;algorithm&gt;#include &lt;cinttypes&gt;#include &lt;cstdalign&gt;#include &lt;stdexcept&gt;#include &lt;typeindex&gt;#include &lt;functional&gt;#include &lt;forward_list&gt;#include &lt;system_error&gt;#include &lt;unordered_map&gt;#include &lt;unordered_set&gt;#include &lt;scoped_allocator&gt;#include &lt;condition_variable&gt;// #include &lt;conio.h&gt;// #include &lt;windows.h&gt;using namespace std;typedef long long LL;typedef unsigned int ui;typedef unsigned long long ull;typedef float fl;typedef double ld;typedef long double LD;typedef pair&lt;int,int&gt; pii;#if (WIN32) || (WIN64) || (__WIN32) || (__WIN64) || (_WIN32) || (_WIN64) || (WINDOWS)#define lld "%I64d"#define llu "%I64u"#else#define lld "%lld"#define llu "%llu"#endif#define ui(n) ((unsigned int)(n))#define LL(n) ((long long)(n))#define ull(n) ((unsigned long long)(n))#define fl(n) ((float)(n))#define ld(n) ((double)(n))#define LD(n) ((long double)(n))#define char(n) ((char)(n))#define Bool(n) ((bool)(n))#define fixpoint(n) fixed&lt;&lt;setprecision(n)const int INF=1061109567;const int NINF=-1044266559;const LL LINF=4557430888798830399;const ld eps=1e-15;#define MOD (1000000007)#define PI (3.1415926535897932384626433832795028841971)/*#define MB_LEN_MAX 5#define SHRT_MIN (-32768)#define SHRT_MAX 32767#define USHRT_MAX 0xffffU#define INT_MIN (-2147483647 - 1)#define INT_MAX 2147483647#define UINT_MAX 0xffffffffU#define LONG_MIN (-2147483647L - 1)#define LONG_MAX 2147483647L#define ULONG_MAX 0xffffffffUL#define LLONG_MAX 9223372036854775807ll#define LLONG_MIN (-9223372036854775807ll - 1)#define ULLONG_MAX 0xffffffffffffffffull*/#define MP make_pair#define MT make_tuple#define All(a) (a).begin(),(a).end()#define pall(a) (a).rbegin(),(a).rend()#define Log(x,y) log(x)/log(y)#define SZ(a) ((int)(a).size())#define rep(i,n) for(int i=0;i&lt;((int)(n));i++)#define rep1(i,n) for(int i=1;i&lt;=((int)(n));i++)#define repa(i,a,n) for(int i=((int)(a));i&lt;((int)(n));i++)#define repa1(i,a,n) for(int i=((int)(a));i&lt;=((int)(n));i++)#define repd(i,n) for(int i=((int)(n))-1;i&gt;=0;i--)#define repd1(i,n) for(int i=((int)(n));i&gt;=1;i--)#define repda(i,n,a) for(int i=((int)(n));i&gt;((int)(a));i--)#define repda1(i,n,a) for(int i=((int)(n));i&gt;=((int)(a));i--)#define FOR(i,a,n,step) for(int i=((int)(a));i&lt;((int)(n));i+=((int)(step)))#define repv(itr,v) for(__typeof((v).begin()) itr=(v).begin();itr!=(v).end();itr++)#define repV(i,v) for(auto i:v)#define repE(i,v) for(auto &amp;i:v)#define MS(x,y) memset(x,y,sizeof(x))#define MC(x) MS(x,0)#define MINF(x) MS(x,63)#define MCP(x,y) memcpy(x,y,sizeof(y))#define sqr(x) ((x)*(x))#define UN(v) sort(All(v)),v.erase(unique(All(v)),v.end())#define filein(x) freopen(x,"r",stdin)#define fileout(x) freopen(x,"w",stdout)#define fileio(x)\ freopen(x".in","r",stdin);\ freopen(x".out","w",stdout)#define filein2(filename,name) ifstream name(filename,ios::in)#define fileout2(filename,name) ofstream name(filename,ios::out)#define file(filename,name) fstream name(filename,ios::in|ios::out)#define Pause system("pause")#define Cls system("cls")#define fs first#define sc second#define PC(x) putchar(x)#define GC(x) x=getchar()#define Endl PC('\n')#define SF scanf#define PF printfinline int Read()&#123; int X=0,w=0;char ch=0;while(!isdigit(ch))&#123;w|=ch=='-';ch=getchar();&#125;while(isdigit(ch))X=(X&lt;&lt;3)+(X&lt;&lt;1)+(ch^48),ch=getchar(); return w?-X:X;&#125;inline void Write(int x)&#123;if(x&lt;0)putchar('-'),x=-x;if(x&gt;9)Write(x/10);putchar(x%10+'0');&#125;inline LL powmod(LL a,LL b)&#123;LL RES=1;a%=MOD;assert(b&gt;=0);for(;b;b&gt;&gt;=1)&#123;if(b&amp;1)RES=RES*a%MOD;a=a*a%MOD;&#125;return RES%MOD;&#125;inline LL gcdll(LL a,LL b)&#123;return b?gcdll(b,a%b):a;&#125;const int dx[]=&#123;0,1,0,-1,1,-1,-1,1&#125;;const int dy[]=&#123;1,0,-1,0,-1,-1,1,1&#125;;/************************************************************Begin************************************************************/const int maxn=1000010;int n,r,c,len[maxn],sum[maxn],to[maxn],fa[maxn],cur[maxn];string str[maxn];inline void sol(int num)&#123; if(!num) &#123; rep(i,n+1) fa[i]=i; return; &#125; sol(num/2); rep(i,n+1) cur[i]=fa[fa[i]]; if(num%2) &#123; rep(i,n+1) fa[i]=to[cur[i]]; &#125; else &#123; rep(i,n+1) fa[i]=cur[i]; &#125;&#125;int main()&#123; cin&gt;&gt;n&gt;&gt;r&gt;&gt;c; rep(i,n) &#123; cin&gt;&gt;str[i]; len[i]=str[i].size()+1; &#125; rep(i,n) sum[i+1]=sum[i]+len[i]; for(int i=0,j=0;i&lt;=n;i++) &#123; for(;j&lt;=n&amp;&amp;sum[j]-sum[i]&lt;=c+1;j++); to[i]=--j; &#125; sol(r); int mx=-1,id=-1; rep(i,n+1) if(mx&lt;fa[i]-i) &#123; mx=fa[i]-i; id=i; &#125; rep(cntr,r) &#123; if(id==to[id]) break; repa(i,id,to[id]) &#123; if(i&gt;id) cout&lt;&lt;" "; cout&lt;&lt;str[i]; &#125; id=to[id]; cout&lt;&lt;endl; &#125; return 0;&#125;/*************************************************************End**************************************************************/]]></content>
      <categories>
        <category>算法</category>
        <category>Codeforces</category>
      </categories>
      <tags>
        <tag>二分</tag>
        <tag>双指针</tag>
        <tag>倍增</tag>
        <tag>DP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Ural 1220 Stacks 题解]]></title>
    <url>%2F2019%2F09%2F07%2FUral-1220-Stacks-%E9%A2%98%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[Ural 1220 Stacks 题解题意模拟若干个栈。 给定$n(1\le n\le 10^5)$个操作，每个操作有如下两个类型 PUSH a b，意为把b插入第a个栈中。 POP a，意为输出第a个栈的栈顶元素，并弹出栈顶。 $1\le a \le 10^3,0\le b\le 10^9$，保证操作无误，内存限制为0.75MB=768KB​。 题解纯模拟会MLE(不知道有没有神仙可以卡过去)，不管是vector，stack还是其它的。 很容易想到用静态链表$v$维护，把所有的元素存储在同一个数组： $v_i$有一个指针$p_i$指向这个栈中前一个元素。 每个栈有$l_i$表示栈顶元素的下标。 但是这样仍然会MLE。 把$p$数组的类型换成unsigned short($[0,65536]$)，观察到$0\le v_i$。 若$p_i&gt;65536$，让$v_i=-v_i$，$p_i=p_i-65536$。 执行POP操作时转换一下即可。 Tip: G++ 7.1还是MLE(796KB)，选用Visual C++ 2017可以通过(760KB)。 程序1234567891011121314151617181920212223242526272829303132333435363738394041424344#include &lt;stdio.h&gt;#include &lt;math.h&gt;using namespace std;const int maxn=100001,maxm=1001,maxnum=65536;int n,a,b,v[maxn],len,lst[maxm];unsigned short poi[maxn];char op[5];int main()&#123; scanf("%d",&amp;n); for(int i=0;i&lt;n;i++) &#123; scanf("%s%d",op,&amp;a); if(op[1]=='U') &#123; scanf("%d",&amp;b); v[len++]=b; int id=len-1; if(lst[a]&gt;maxnum) &#123; poi[id]=lst[a]-maxnum; v[id]=-v[id]; &#125; else poi[id]=lst[a]; lst[a]=id; &#125; else &#123; printf("%d\n",abs(v[lst[a]])); if(v[lst[a]]&lt;0) lst[a]=poi[lst[a]]+maxnum; else lst[a]=poi[lst[a]]; &#125; &#125; return 0;&#125;]]></content>
      <categories>
        <category>算法</category>
        <category>Ural</category>
      </categories>
      <tags>
        <tag>静态链表</tag>
        <tag>卡内存</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Ural 1218 Episode N-th: The Jedi Tournament 题解]]></title>
    <url>%2F2019%2F09%2F04%2FUral-1218-Episode-N-th-The-Jedi-Tournament-%E9%A2%98%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[Ural 1218 Episode N-th: The Jedi Tournament 题解题意给定$n(1\le n\le 20)$个玩家，每个玩家有一个字符串名字和三个整数值(所有玩家的数值都不同)。对于玩家$i$和$j$，如果玩家$i$的三个值中至少有两个值大于玩家$j$的对应值，则$i$玩家可以淘汰$j$玩家。一个玩家胜利了就是他淘汰了所有人。你可以随意安排赛程，输出那些至少胜利了一次的玩家的名字(按照输入的顺序输出)。 题解构图。若$i$玩家可以淘汰$j$玩家，则从$i$连一条有向边到$j$。问题转化成：如果从$i$开始，能找到一条长度为$n-1$的路径，那么他胜利了。 方法$1$无脑暴力DFS。边数$n^2$，点数$n$，时间复杂度为$O(n^3)$。妥妥的TLE。 方法$2$强连通分量缩点。因为在同一个强连通分量中，任意一个点都可以淘汰(这个强连通分量中)其它的点。缩点后，图变成一个DAG，而入度为$0$的那个强连通分量中，任意一个点都可以淘汰(整个图中)其它的点。输出那个强连通分量里所有的点即可。 方法$2$程序123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245// #pragma GCC optimize(2)// #pragma G++ optimize(2)// #pragma comment(linker,"/STACK:102400000,102400000")// #include &lt;bits/stdc++.h&gt;#include &lt;map&gt;#include &lt;set&gt;#include &lt;list&gt;#include &lt;array&gt;#include &lt;cfenv&gt;#include &lt;cmath&gt;#include &lt;ctime&gt;#include &lt;deque&gt;#include &lt;mutex&gt;#include &lt;queue&gt;#include &lt;ratio&gt;#include &lt;regex&gt;#include &lt;stack&gt;#include &lt;tuple&gt;#include &lt;atomic&gt;#include &lt;bitset&gt;#include &lt;cctype&gt;#include &lt;cerrno&gt;#include &lt;cfloat&gt;#include &lt;chrono&gt;#include &lt;cstdio&gt;#include &lt;cwchar&gt;#include &lt;future&gt;#include &lt;limits&gt;#include &lt;locale&gt;#include &lt;memory&gt;#include &lt;random&gt;#include &lt;string&gt;#include &lt;thread&gt;#include &lt;vector&gt;#include &lt;cassert&gt;#include &lt;climits&gt;#include &lt;clocale&gt;#include &lt;complex&gt;#include &lt;csetjmp&gt;#include &lt;csignal&gt;#include &lt;cstdarg&gt;#include &lt;cstddef&gt;#include &lt;cstdint&gt;#include &lt;cstdlib&gt;#include &lt;cstring&gt;#include &lt;ctgmath&gt;#include &lt;cwctype&gt;#include &lt;fstream&gt;#include &lt;iomanip&gt;#include &lt;numeric&gt;#include &lt;sstream&gt;#include &lt;ccomplex&gt;#include &lt;cstdbool&gt;#include &lt;iostream&gt;#include &lt;typeinfo&gt;#include &lt;valarray&gt;#include &lt;algorithm&gt;#include &lt;cinttypes&gt;#include &lt;cstdalign&gt;#include &lt;stdexcept&gt;#include &lt;typeindex&gt;#include &lt;functional&gt;#include &lt;forward_list&gt;#include &lt;system_error&gt;#include &lt;unordered_map&gt;#include &lt;unordered_set&gt;#include &lt;scoped_allocator&gt;#include &lt;condition_variable&gt;// #include &lt;conio.h&gt;// #include &lt;windows.h&gt;using namespace std;typedef long long LL;typedef unsigned int ui;typedef unsigned long long ull;typedef float fl;typedef double ld;typedef long double LD;typedef pair&lt;int,int&gt; pii;#if (WIN32) || (WIN64) || (__WIN32) || (__WIN64) || (_WIN32) || (_WIN64) || (WINDOWS)#define lld "%I64d"#define llu "%I64u"#else#define lld "%lld"#define llu "%llu"#endif#define ui(n) ((unsigned int)(n))#define LL(n) ((long long)(n))#define ull(n) ((unsigned long long)(n))#define fl(n) ((float)(n))#define ld(n) ((double)(n))#define LD(n) ((long double)(n))#define char(n) ((char)(n))#define Bool(n) ((bool)(n))#define fixpoint(n) fixed&lt;&lt;setprecision(n)const int INF=1061109567;const int NINF=-1044266559;const LL LINF=4557430888798830399;const ld eps=1e-15;#define MOD (1000000007)#define PI (3.1415926535897932384626433832795028841971)/*#define MB_LEN_MAX 5#define SHRT_MIN (-32768)#define SHRT_MAX 32767#define USHRT_MAX 0xffffU#define INT_MIN (-2147483647 - 1)#define INT_MAX 2147483647#define UINT_MAX 0xffffffffU#define LONG_MIN (-2147483647L - 1)#define LONG_MAX 2147483647L#define ULONG_MAX 0xffffffffUL#define LLONG_MAX 9223372036854775807ll#define LLONG_MIN (-9223372036854775807ll - 1)#define ULLONG_MAX 0xffffffffffffffffull*/#define MP make_pair#define MT make_tuple#define All(a) (a).begin(),(a).end()#define pall(a) (a).rbegin(),(a).rend()#define Log(x,y) log(x)/log(y)#define SZ(a) ((int)(a).size())#define rep(i,n) for(int i=0;i&lt;((int)(n));i++)#define rep1(i,n) for(int i=1;i&lt;=((int)(n));i++)#define repa(i,a,n) for(int i=((int)(a));i&lt;((int)(n));i++)#define repa1(i,a,n) for(int i=((int)(a));i&lt;=((int)(n));i++)#define repd(i,n) for(int i=((int)(n))-1;i&gt;=0;i--)#define repd1(i,n) for(int i=((int)(n));i&gt;=1;i--)#define repda(i,n,a) for(int i=((int)(n));i&gt;((int)(a));i--)#define repda1(i,n,a) for(int i=((int)(n));i&gt;=((int)(a));i--)#define FOR(i,a,n,step) for(int i=((int)(a));i&lt;((int)(n));i+=((int)(step)))#define repv(itr,v) for(__typeof((v).begin()) itr=(v).begin();itr!=(v).end();itr++)#define repV(i,v) for(auto i:v)#define repE(i,v) for(auto &amp;i:v)#define MS(x,y) memset(x,y,sizeof(x))#define MC(x) MS(x,0)#define MINF(x) MS(x,63)#define MCP(x,y) memcpy(x,y,sizeof(y))#define sqr(x) ((x)*(x))#define UN(v) sort(All(v)),v.erase(unique(All(v)),v.end())#define filein(x) freopen(x,"r",stdin)#define fileout(x) freopen(x,"w",stdout)#define fileio(x)\ freopen(x".in","r",stdin);\ freopen(x".out","w",stdout)#define filein2(filename,name) ifstream name(filename,ios::in)#define fileout2(filename,name) ofstream name(filename,ios::out)#define file(filename,name) fstream name(filename,ios::in|ios::out)#define Pause system("pause")#define Cls system("cls")#define fs first#define sc second#define PC(x) putchar(x)#define GC(x) x=getchar()#define Endl PC('\n')#define SF scanf#define PF printfinline int Read()&#123; int X=0,w=0;char ch=0;while(!isdigit(ch))&#123;w|=ch=='-';ch=getchar();&#125;while(isdigit(ch))X=(X&lt;&lt;3)+(X&lt;&lt;1)+(ch^48),ch=getchar(); return w?-X:X;&#125;inline void Write(int x)&#123;if(x&lt;0)putchar('-'),x=-x;if(x&gt;9)Write(x/10);putchar(x%10+'0');&#125;inline LL powmod(LL a,LL b)&#123;LL RES=1;a%=MOD;assert(b&gt;=0);for(;b;b&gt;&gt;=1)&#123;if(b&amp;1)RES=RES*a%MOD;a=a*a%MOD;&#125;return RES%MOD;&#125;inline LL gcdll(LL a,LL b)&#123;return b?gcdll(b,a%b):a;&#125;const int dx[]=&#123;0,1,0,-1,1,-1,-1,1&#125;;const int dy[]=&#123;1,0,-1,0,-1,-1,1,1&#125;;/************************************************************Begin************************************************************/const int maxn=210;int n,a[maxn],b[maxn],c[maxn],tim,dfn[maxn],low[maxn],sta[maxn],ind,cscc,scc[maxn],deg[maxn];string jedi[maxn];vector&lt;int&gt; e[maxn];bool vis[maxn];inline void Tarjan(int x)&#123; dfn[x]=low[x]=++tim; vis[x]=1; sta[++ind]=x; for(int i=0;i&lt;e[x].size();i++) &#123; int y=e[x][i]; if(!dfn[y]) &#123; Tarjan(y); low[x]=min(low[x],low[y]); &#125; else if(vis[y]) low[x]=min(low[x],dfn[y]); &#125; if(low[x]==dfn[x]) &#123; do &#123; // printf("%d ",sta[ind]); scc[sta[ind]]=cscc; vis[sta[ind--]]=0; &#125; while(x!=sta[ind+1]); cscc++; // printf("\n"); &#125;&#125;int main()&#123; cin&gt;&gt;n; rep(i,n) &#123; cin&gt;&gt;jedi[i]&gt;&gt;a[i]&gt;&gt;b[i]&gt;&gt;c[i]; &#125; rep(i,n) rep(j,n) &#123; int cnt=0; if(a[i]&gt;a[j]) cnt++; if(b[i]&gt;b[j]) cnt++; if(c[i]&gt;c[j]) cnt++; if(cnt&gt;=2) e[i].push_back(j); &#125; rep(i,n) if(!dfn[i]) Tarjan(i); rep(i,n) repV(j,e[i]) if(scc[i]!=scc[j]) deg[scc[j]]++; int deg0; rep(i,cscc) if(deg[i]==0) deg0=i; rep(i,n) if(scc[i]==deg0) cout&lt;&lt;jedi[i]&lt;&lt;endl; return 0;&#125;/*************************************************************End**************************************************************/]]></content>
      <categories>
        <category>算法</category>
        <category>Ural</category>
      </categories>
      <tags>
        <tag>图论</tag>
        <tag>强连通分量</tag>
        <tag>缩点</tag>
        <tag>Tarjan</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Ural 1217 Unlucky Tickets 题解]]></title>
    <url>%2F2019%2F09%2F03%2FUral-1217-Unlucky-Tickets-%E9%A2%98%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[Ural 1217 Unlucky Tickets 题解题意给定$n(2\le n\le 20)$($n$是偶数)，求出在所有$n$位数中(可以有前导零)，前一半数码的和 与 后一半数码的和相等或在奇数位上的数码的和 与 在偶数位上的数码和相等 的个数。 题解考虑DP。 $f(i,j,k)$表示在前$i$位，前一半数码的和 减去 后一半数码的和的为$j$，在奇数位上的数码的和 减去 在偶数位上的数码和为$k$ 的个数。 Tip: $j$不可能为负数，而$k$有可能为负数，所以写的时候要把$k$变成非负数，即$f(i,j,k+base)$。 初始值：$f(0,0,0)=1$。 状态转移方程： 设当前状态为$f(i,j,k)$，需转移到的状态为$f(i’,j’,k’)$，$i’$位上放的数是$x$。 $i’=i+1$。 若$i’&gt;n/2$且$x&gt;j$($j’$位负数)，跳出关于$x$的循环。 若$i’\le n/2$，$j’=j+x$；否则$j’=j-x$。 若$i’\%2=1$，$k’=k+x$；否则$k’=k-x$。 $f(i’,j’,k’)+=f(i,j,k)$即可。 答案：$f(n,0,0)$。 程序123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204// #pragma GCC optimize(2)// #pragma G++ optimize(2)// #pragma comment(linker,"/STACK:102400000,102400000")// #include &lt;bits/stdc++.h&gt;#include &lt;map&gt;#include &lt;set&gt;#include &lt;list&gt;#include &lt;array&gt;#include &lt;cfenv&gt;#include &lt;cmath&gt;#include &lt;ctime&gt;#include &lt;deque&gt;#include &lt;mutex&gt;#include &lt;queue&gt;#include &lt;ratio&gt;#include &lt;regex&gt;#include &lt;stack&gt;#include &lt;tuple&gt;#include &lt;atomic&gt;#include &lt;bitset&gt;#include &lt;cctype&gt;#include &lt;cerrno&gt;#include &lt;cfloat&gt;#include &lt;chrono&gt;#include &lt;cstdio&gt;#include &lt;cwchar&gt;#include &lt;future&gt;#include &lt;limits&gt;#include &lt;locale&gt;#include &lt;memory&gt;#include &lt;random&gt;#include &lt;string&gt;#include &lt;thread&gt;#include &lt;vector&gt;#include &lt;cassert&gt;#include &lt;climits&gt;#include &lt;clocale&gt;#include &lt;complex&gt;#include &lt;csetjmp&gt;#include &lt;csignal&gt;#include &lt;cstdarg&gt;#include &lt;cstddef&gt;#include &lt;cstdint&gt;#include &lt;cstdlib&gt;#include &lt;cstring&gt;#include &lt;ctgmath&gt;#include &lt;cwctype&gt;#include &lt;fstream&gt;#include &lt;iomanip&gt;#include &lt;numeric&gt;#include &lt;sstream&gt;#include &lt;ccomplex&gt;#include &lt;cstdbool&gt;#include &lt;iostream&gt;#include &lt;typeinfo&gt;#include &lt;valarray&gt;#include &lt;algorithm&gt;#include &lt;cinttypes&gt;#include &lt;cstdalign&gt;#include &lt;stdexcept&gt;#include &lt;typeindex&gt;#include &lt;functional&gt;#include &lt;forward_list&gt;#include &lt;system_error&gt;#include &lt;unordered_map&gt;#include &lt;unordered_set&gt;#include &lt;scoped_allocator&gt;#include &lt;condition_variable&gt;// #include &lt;conio.h&gt;// #include &lt;windows.h&gt;using namespace std;typedef long long LL;typedef unsigned int ui;typedef unsigned long long ull;typedef float fl;typedef double ld;typedef long double LD;typedef pair&lt;int,int&gt; pii;#if (WIN32) || (WIN64) || (__WIN32) || (__WIN64) || (_WIN32) || (_WIN64) || (WINDOWS)#define lld "%I64d"#define llu "%I64u"#else#define lld "%lld"#define llu "%llu"#endif#define ui(n) ((unsigned int)(n))#define LL(n) ((long long)(n))#define ull(n) ((unsigned long long)(n))#define fl(n) ((float)(n))#define ld(n) ((double)(n))#define LD(n) ((long double)(n))#define char(n) ((char)(n))#define Bool(n) ((bool)(n))#define fixpoint(n) fixed&lt;&lt;setprecision(n)const int INF=1061109567;const int NINF=-1044266559;const LL LINF=4557430888798830399;const ld eps=1e-15;#define MOD (1000000007)#define PI (3.1415926535897932384626433832795028841971)/*#define MB_LEN_MAX 5#define SHRT_MIN (-32768)#define SHRT_MAX 32767#define USHRT_MAX 0xffffU#define INT_MIN (-2147483647 - 1)#define INT_MAX 2147483647#define UINT_MAX 0xffffffffU#define LONG_MIN (-2147483647L - 1)#define LONG_MAX 2147483647L#define ULONG_MAX 0xffffffffUL#define LLONG_MAX 9223372036854775807ll#define LLONG_MIN (-9223372036854775807ll - 1)#define ULLONG_MAX 0xffffffffffffffffull*/#define MP make_pair#define MT make_tuple#define All(a) (a).begin(),(a).end()#define pall(a) (a).rbegin(),(a).rend()#define Log(x,y) log(x)/log(y)#define SZ(a) ((int)(a).size())#define rep(i,n) for(int i=0;i&lt;((int)(n));i++)#define rep1(i,n) for(int i=1;i&lt;=((int)(n));i++)#define repa(i,a,n) for(int i=((int)(a));i&lt;((int)(n));i++)#define repa1(i,a,n) for(int i=((int)(a));i&lt;=((int)(n));i++)#define repd(i,n) for(int i=((int)(n))-1;i&gt;=0;i--)#define repd1(i,n) for(int i=((int)(n));i&gt;=1;i--)#define repda(i,n,a) for(int i=((int)(n));i&gt;((int)(a));i--)#define repda1(i,n,a) for(int i=((int)(n));i&gt;=((int)(a));i--)#define FOR(i,a,n,step) for(int i=((int)(a));i&lt;((int)(n));i+=((int)(step)))#define repv(itr,v) for(__typeof((v).begin()) itr=(v).begin();itr!=(v).end();itr++)#define repV(i,v) for(auto i:v)#define repE(i,v) for(auto &amp;i:v)#define MS(x,y) memset(x,y,sizeof(x))#define MC(x) MS(x,0)#define MINF(x) MS(x,63)#define MCP(x,y) memcpy(x,y,sizeof(y))#define sqr(x) ((x)*(x))#define UN(v) sort(All(v)),v.erase(unique(All(v)),v.end())#define filein(x) freopen(x,"r",stdin)#define fileout(x) freopen(x,"w",stdout)#define fileio(x)\ freopen(x".in","r",stdin);\ freopen(x".out","w",stdout)#define filein2(filename,name) ifstream name(filename,ios::in)#define fileout2(filename,name) ofstream name(filename,ios::out)#define file(filename,name) fstream name(filename,ios::in|ios::out)#define Pause system("pause")#define Cls system("cls")#define fs first#define sc second#define PC(x) putchar(x)#define GC(x) x=getchar()#define Endl PC('\n')#define SF scanf#define PF printfinline int Read()&#123; int X=0,w=0;char ch=0;while(!isdigit(ch))&#123;w|=ch=='-';ch=getchar();&#125;while(isdigit(ch))X=(X&lt;&lt;3)+(X&lt;&lt;1)+(ch^48),ch=getchar(); return w?-X:X;&#125;inline void Write(int x)&#123;if(x&lt;0)putchar('-'),x=-x;if(x&gt;9)Write(x/10);putchar(x%10+'0');&#125;inline LL powmod(LL a,LL b)&#123;LL RES=1;a%=MOD;assert(b&gt;=0);for(;b;b&gt;&gt;=1)&#123;if(b&amp;1)RES=RES*a%MOD;a=a*a%MOD;&#125;return RES%MOD;&#125;inline LL gcdll(LL a,LL b)&#123;return b?gcdll(b,a%b):a;&#125;const int dx[]=&#123;0,1,0,-1,1,-1,-1,1&#125;;const int dy[]=&#123;1,0,-1,0,-1,-1,1,1&#125;;/************************************************************Begin************************************************************/const int maxn=25,base=200;int n;LL dp[maxn][base+10][base*2+10];// dp[numbers of digits][the first half - the last half][digits on the odd positions - the digits on the even positions]int main()&#123; SF("%d",&amp;n); dp[0][0][base]=1; rep(i,n) rep(j,base+1) repa1(k,-200,200) if(dp[i][j][k+base]) &#123; rep(x,10) &#123; int ci=i+1,cj=j,ck=k; if(ci&gt;n/2&amp;&amp;x&gt;j) break; if(ci&lt;=n/2) cj+=x; else cj-=x; if(ci%2) ck+=x; else ck-=x; dp[ci][cj][ck+base]+=dp[i][j][k+base]; &#125; &#125; PF("%lld",dp[n][0][base]); return 0;&#125;/*************************************************************End**************************************************************/]]></content>
      <categories>
        <category>算法</category>
        <category>Ural</category>
      </categories>
      <tags>
        <tag>DP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[头文件和宏定义]]></title>
    <url>%2F2019%2F09%2F02%2F%E5%A4%B4%E6%96%87%E4%BB%B6%E5%92%8C%E5%AE%8F%E5%AE%9A%E4%B9%89%2F</url>
    <content type="text"><![CDATA[头文件和宏定义有点长，会使文章看上去很长，请谅解。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183// #pragma GCC optimize(2)// #pragma G++ optimize(2)// #pragma comment(linker,"/STACK:102400000,102400000")// #include &lt;bits/stdc++.h&gt;#include &lt;map&gt;#include &lt;set&gt;#include &lt;list&gt;#include &lt;array&gt;#include &lt;cfenv&gt;#include &lt;cmath&gt;#include &lt;ctime&gt;#include &lt;deque&gt;#include &lt;mutex&gt;#include &lt;queue&gt;#include &lt;ratio&gt;#include &lt;regex&gt;#include &lt;stack&gt;#include &lt;tuple&gt;#include &lt;atomic&gt;#include &lt;bitset&gt;#include &lt;cctype&gt;#include &lt;cerrno&gt;#include &lt;cfloat&gt;#include &lt;chrono&gt;#include &lt;cstdio&gt;#include &lt;cwchar&gt;#include &lt;future&gt;#include &lt;limits&gt;#include &lt;locale&gt;#include &lt;memory&gt;#include &lt;random&gt;#include &lt;string&gt;#include &lt;thread&gt;#include &lt;vector&gt;#include &lt;cassert&gt;#include &lt;climits&gt;#include &lt;clocale&gt;#include &lt;complex&gt;#include &lt;csetjmp&gt;#include &lt;csignal&gt;#include &lt;cstdarg&gt;#include &lt;cstddef&gt;#include &lt;cstdint&gt;#include &lt;cstdlib&gt;#include &lt;cstring&gt;#include &lt;ctgmath&gt;#include &lt;cwctype&gt;#include &lt;fstream&gt;#include &lt;iomanip&gt;#include &lt;numeric&gt;#include &lt;sstream&gt;#include &lt;ccomplex&gt;#include &lt;cstdbool&gt;#include &lt;iostream&gt;#include &lt;typeinfo&gt;#include &lt;valarray&gt;#include &lt;algorithm&gt;#include &lt;cinttypes&gt;#include &lt;cstdalign&gt;#include &lt;stdexcept&gt;#include &lt;typeindex&gt;#include &lt;functional&gt;#include &lt;forward_list&gt;#include &lt;system_error&gt;#include &lt;unordered_map&gt;#include &lt;unordered_set&gt;#include &lt;scoped_allocator&gt;#include &lt;condition_variable&gt;// #include &lt;conio.h&gt;// #include &lt;windows.h&gt;using namespace std;typedef long long LL;typedef unsigned int ui;typedef unsigned long long ull;typedef float fl;typedef double ld;typedef long double LD;typedef pair&lt;int,int&gt; pii;#if (WIN32) || (WIN64) || (__WIN32) || (__WIN64) || (_WIN32) || (_WIN64) || (WINDOWS)#define lld "%I64d"#define llu "%I64u"#else#define lld "%lld"#define llu "%llu"#endif#define ui(n) ((unsigned int)(n))#define LL(n) ((long long)(n))#define ull(n) ((unsigned long long)(n))#define fl(n) ((float)(n))#define ld(n) ((double)(n))#define LD(n) ((long double)(n))#define char(n) ((char)(n))#define Bool(n) ((bool)(n))#define fixpoint(n) fixed&lt;&lt;setprecision(n)const int INF=1061109567;const int NINF=-1044266559;const LL LINF=4557430888798830399;const ld eps=1e-15;#define MOD (1000000007)#define PI (3.1415926535897932384626433832795028841971)/*#define MB_LEN_MAX 5#define SHRT_MIN (-32768)#define SHRT_MAX 32767#define USHRT_MAX 0xffffU#define INT_MIN (-2147483647 - 1)#define INT_MAX 2147483647#define UINT_MAX 0xffffffffU#define LONG_MIN (-2147483647L - 1)#define LONG_MAX 2147483647L#define ULONG_MAX 0xffffffffUL#define LLONG_MAX 9223372036854775807ll#define LLONG_MIN (-9223372036854775807ll - 1)#define ULLONG_MAX 0xffffffffffffffffull*/#define MP make_pair#define MT make_tuple#define All(a) (a).begin(),(a).end()#define pall(a) (a).rbegin(),(a).rend()#define Log(x,y) log(x)/log(y)#define SZ(a) ((int)(a).size())#define rep(i,n) for(int i=0;i&lt;((int)(n));i++)#define rep1(i,n) for(int i=1;i&lt;=((int)(n));i++)#define repa(i,a,n) for(int i=((int)(a));i&lt;((int)(n));i++)#define repa1(i,a,n) for(int i=((int)(a));i&lt;=((int)(n));i++)#define repd(i,n) for(int i=((int)(n))-1;i&gt;=0;i--)#define repd1(i,n) for(int i=((int)(n));i&gt;=1;i--)#define repda(i,n,a) for(int i=((int)(n));i&gt;((int)(a));i--)#define repda1(i,n,a) for(int i=((int)(n));i&gt;=((int)(a));i--)#define FOR(i,a,n,step) for(int i=((int)(a));i&lt;((int)(n));i+=((int)(step)))#define repv(itr,v) for(__typeof((v).begin()) itr=(v).begin();itr!=(v).end();itr++)#define repV(i,v) for(auto i:v)#define repE(i,v) for(auto &amp;i:v)#define MS(x,y) memset(x,y,sizeof(x))#define MC(x) MS(x,0)#define MINF(x) MS(x,63)#define MCP(x,y) memcpy(x,y,sizeof(y))#define sqr(x) ((x)*(x))#define UN(v) sort(All(v)),v.erase(unique(All(v)),v.end())#define filein(x) freopen(x,"r",stdin)#define fileout(x) freopen(x,"w",stdout)#define fileio(x)\ freopen(x".in","r",stdin);\ freopen(x".out","w",stdout)#define filein2(filename,name) ifstream name(filename,ios::in)#define fileout2(filename,name) ofstream name(filename,ios::out)#define file(filename,name) fstream name(filename,ios::in|ios::out)#define Pause system("pause")#define Cls system("cls")#define fs first#define sc second#define PC(x) putchar(x)#define GC(x) x=getchar()#define Endl PC('\n')#define SF scanf#define PF printfinline int Read()&#123; int X=0,w=0;char ch=0;while(!isdigit(ch))&#123;w|=ch=='-';ch=getchar();&#125;while(isdigit(ch))X=(X&lt;&lt;3)+(X&lt;&lt;1)+(ch^48),ch=getchar(); return w?-X:X;&#125;inline void Write(int x)&#123;if(x&lt;0)putchar('-'),x=-x;if(x&gt;9)Write(x/10);putchar(x%10+'0');&#125;inline LL powmod(LL a,LL b)&#123;LL RES=1;a%=MOD;assert(b&gt;=0);for(;b;b&gt;&gt;=1)&#123;if(b&amp;1)RES=RES*a%MOD;a=a*a%MOD;&#125;return RES%MOD;&#125;inline LL gcdll(LL a,LL b)&#123;return b?gcdll(b,a%b):a;&#125;const int dx[]=&#123;0,1,0,-1,1,-1,-1,1&#125;;const int dy[]=&#123;1,0,-1,0,-1,-1,1,1&#125;;/************************************************************Begin************************************************************/const int maxn=INF;int main()&#123; return 0;&#125;/*************************************************************End**************************************************************/]]></content>
  </entry>
  <entry>
    <title><![CDATA[agc029C Lexicographic constraints 题解]]></title>
    <url>%2F2019%2F08%2F31%2Fagc029C-Lexicographic-constraints-%E9%A2%98%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[agc029C Lexicographic constraints 题解题意 有$n$个字符串，分别为$S_1,S_2,\dots,S_n$，$S_i$的长度为$A_i(1\le i\le n)$。给定$n$和$A$，求用最少个数的字符组成$S_1,S_2,\dots,S_n$，使得$S_1&lt;S_2&lt;\dots&lt;S_n$(字典序)。输出这个数。 题解贪心。对于每一个字符串，必须选择可选字符串中字典序最小的一个。 反证法：如果不选字典序最小的一个，答案肯定不会更优。 设每个字符为$0\sim\inf$中的一个数字。 所以 S_1=\begin{matrix} \underbrace{0\dots0} \\ A_1\end{matrix}已知$S_{i-1}$如何求$S_i(2\le i\le n)$呢。 $A_i&gt;A_{i-1}$时， S_i=S_{i-1}+\begin{matrix} \underbrace{0\dots0} \\ A_i-A_{i-1}\end{matrix} $A_i\le A_{i-1}$时，$S_i=S_{i-1}$的前$A_i$位，且$S_i$的最后一位加$1$，然后“进位”(如果当前位的值超出字符集的大小，就把当前位设置位$0$，前一位加$1$)。 这里需要知道字符集大小。考虑二分，因为字符集大小是满足单调性的。check函数：“进位”时如果进到$-1$位了，就不可行。 证明：如果字符集大小位$m$，则字符集大小为$m+1$一定可行，而字符集大小为$m-1$不一定可行。 问题：字符串长度最大为$10^9$，不能维护整个字符串。 解法$1$：用一个map&lt;int,int&gt;表示第几位放的是什么字符。观察发现：字符串中大部分的字符为$0$，所以只维护字符不为$0$位就可以了。 Tip: 需要特判$A_1&lt;A_2&lt;\dots&lt;A_n$的情况，否则前$3$个点会TLE。 解法$2$：同样，字符串中大部分的字符为$0$，可以用一个vector&lt;pair&lt;int,int&gt; &gt;维护，&lt;a,b&gt;表示字符为a，出现了b次的字符串，存在vector里即可表达整个字符串。这个方法写起来会更麻烦一点。 程序解法$1$123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231// #pragma GCC optimize(2)// #pragma G++ optimize(2)// #pragma comment(linker,"/STACK:102400000,102400000")// #include &lt;bits/stdc++.h&gt;#include &lt;map&gt;#include &lt;set&gt;#include &lt;list&gt;#include &lt;array&gt;#include &lt;cfenv&gt;#include &lt;cmath&gt;#include &lt;ctime&gt;#include &lt;deque&gt;#include &lt;mutex&gt;#include &lt;queue&gt;#include &lt;ratio&gt;#include &lt;regex&gt;#include &lt;stack&gt;#include &lt;tuple&gt;#include &lt;atomic&gt;#include &lt;bitset&gt;#include &lt;cctype&gt;#include &lt;cerrno&gt;#include &lt;cfloat&gt;#include &lt;chrono&gt;#include &lt;cstdio&gt;#include &lt;cwchar&gt;#include &lt;future&gt;#include &lt;limits&gt;#include &lt;locale&gt;#include &lt;memory&gt;#include &lt;random&gt;#include &lt;string&gt;#include &lt;thread&gt;#include &lt;vector&gt;#include &lt;cassert&gt;#include &lt;climits&gt;#include &lt;clocale&gt;#include &lt;complex&gt;#include &lt;csetjmp&gt;#include &lt;csignal&gt;#include &lt;cstdarg&gt;#include &lt;cstddef&gt;#include &lt;cstdint&gt;#include &lt;cstdlib&gt;#include &lt;cstring&gt;#include &lt;ctgmath&gt;#include &lt;cwctype&gt;#include &lt;fstream&gt;#include &lt;iomanip&gt;#include &lt;numeric&gt;#include &lt;sstream&gt;#include &lt;ccomplex&gt;#include &lt;cstdbool&gt;#include &lt;iostream&gt;#include &lt;typeinfo&gt;#include &lt;valarray&gt;#include &lt;algorithm&gt;#include &lt;cinttypes&gt;#include &lt;cstdalign&gt;#include &lt;stdexcept&gt;#include &lt;typeindex&gt;#include &lt;functional&gt;#include &lt;forward_list&gt;#include &lt;system_error&gt;#include &lt;unordered_map&gt;#include &lt;unordered_set&gt;#include &lt;scoped_allocator&gt;#include &lt;condition_variable&gt;// #include &lt;conio.h&gt;// #include &lt;windows.h&gt;using namespace std;typedef long long LL;typedef unsigned int ui;typedef unsigned long long ull;typedef float fl;typedef double ld;typedef long double LD;typedef pair&lt;int,int&gt; pii;#if (WIN32) || (WIN64) || (__WIN32) || (__WIN64) || (_WIN32) || (_WIN64) || (WINDOWS)#define lld "%I64d"#define llu "%I64u"#else#define lld "%lld"#define llu "%llu"#endif#define ui(n) ((unsigned int)(n))#define LL(n) ((long long)(n))#define ull(n) ((unsigned long long)(n))#define fl(n) ((float)(n))#define ld(n) ((double)(n))#define LD(n) ((long double)(n))#define char(n) ((char)(n))#define Bool(n) ((bool)(n))#define fixpoint(n) fixed&lt;&lt;setprecision(n)const int INF=1061109567;const int NINF=-1044266559;const LL LINF=4557430888798830399;const ld eps=1e-15;#define MOD (1000000007)#define PI (3.1415926535897932384626433832795028841971)/*#define MB_LEN_MAX 5#define SHRT_MIN (-32768)#define SHRT_MAX 32767#define USHRT_MAX 0xffffU#define INT_MIN (-2147483647 - 1)#define INT_MAX 2147483647#define UINT_MAX 0xffffffffU#define LONG_MIN (-2147483647L - 1)#define LONG_MAX 2147483647L#define ULONG_MAX 0xffffffffUL#define LLONG_MAX 9223372036854775807ll#define LLONG_MIN (-9223372036854775807ll - 1)#define ULLONG_MAX 0xffffffffffffffffull*/#define MP make_pair#define MT make_tuple#define All(a) (a).begin(),(a).end()#define pall(a) (a).rbegin(),(a).rend()#define Log(x,y) log(x)/log(y)#define SZ(a) ((int)(a).size())#define rep(i,n) for(int i=0;i&lt;((int)(n));i++)#define rep1(i,n) for(int i=1;i&lt;=((int)(n));i++)#define repa(i,a,n) for(int i=((int)(a));i&lt;((int)(n));i++)#define repa1(i,a,n) for(int i=((int)(a));i&lt;=((int)(n));i++)#define repd(i,n) for(int i=((int)(n))-1;i&gt;=0;i--)#define repd1(i,n) for(int i=((int)(n));i&gt;=1;i--)#define repda(i,n,a) for(int i=((int)(n));i&gt;((int)(a));i--)#define repda1(i,n,a) for(int i=((int)(n));i&gt;=((int)(a));i--)#define FOR(i,a,n,step) for(int i=((int)(a));i&lt;((int)(n));i+=((int)(step)))#define repv(itr,v) for(__typeof((v).begin()) itr=(v).begin();itr!=(v).end();itr++)#define repV(i,v) for(auto i:v)#define repE(i,v) for(auto &amp;i:v)#define MS(x,y) memset(x,y,sizeof(x))#define MC(x) MS(x,0)#define MINF(x) MS(x,63)#define MCP(x,y) memcpy(x,y,sizeof(y))#define sqr(x) ((x)*(x))#define UN(v) sort(All(v)),v.erase(unique(All(v)),v.end())#define filein(x) freopen(x,"r",stdin)#define fileout(x) freopen(x,"w",stdout)#define fileio(x)\ freopen(x".in","r",stdin);\ freopen(x".out","w",stdout)#define filein2(filename,name) ifstream name(filename,ios::in)#define fileout2(filename,name) ofstream name(filename,ios::out)#define file(filename,name) fstream name(filename,ios::in|ios::out)#define Pause system("pause")#define Cls system("cls")#define fs first#define sc second#define PC(x) putchar(x)#define GC(x) x=getchar()#define Endl PC('\n')#define SF scanf#define PF printfinline int Read()&#123; int X=0,w=0;char ch=0;while(!isdigit(ch))&#123;w|=ch=='-';ch=getchar();&#125;while(isdigit(ch))X=(X&lt;&lt;3)+(X&lt;&lt;1)+(ch^48),ch=getchar(); return w?-X:X;&#125;inline void Write(int x)&#123;if(x&lt;0)putchar('-'),x=-x;if(x&gt;9)Write(x/10);putchar(x%10+'0');&#125;inline LL powmod(LL a,LL b)&#123;LL RES=1;a%=MOD;assert(b&gt;=0);for(;b;b&gt;&gt;=1)&#123;if(b&amp;1)RES=RES*a%MOD;a=a*a%MOD;&#125;return RES%MOD;&#125;inline LL gcdll(LL a,LL b)&#123;return b?gcdll(b,a%b):a;&#125;const int dx[]=&#123;0,1,0,-1,1,-1,-1,1&#125;;const int dy[]=&#123;1,0,-1,0,-1,-1,1,1&#125;;/************************************************************Begin************************************************************/const int maxn=200010;int n,a[maxn];map&lt;int,int&gt; str;inline bool check(int x)&#123; int len=0; str.clear(); rep(i,n) if(a[i]&gt;len) &#123; len=a[i]; &#125; else &#123; while(!str.empty()&amp;&amp;str.rbegin()-&gt;fs&gt;=a[i]) str.erase(str.rbegin()-&gt;fs); int cur=a[i]-1; str[cur]++; while(str[cur]&gt;=x) &#123; str.erase(cur); str[--cur]++; if(cur&lt;0) return 0; &#125; len=a[i]; &#125; return 1;&#125;int main()&#123; SF("%d",&amp;n); rep(i,n) SF("%d",&amp;a[i]); bool f=1; rep1(i,n-1) if(a[i]&lt;=a[i-1]) f=0; if(f) return !PF("1"); int l=2,r=n+1; // [l,r) while(l&lt;r) &#123; int mid=(l+r)/2; if(check(mid)) r=mid; else l=mid+1; &#125; PF("%d",r); return 0;&#125;/*************************************************************End**************************************************************/ 解法$2$123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250// #pragma GCC optimize(2)// #pragma G++ optimize(2)// #pragma comment(linker,"/STACK:102400000,102400000")// #include &lt;bits/stdc++.h&gt;#include &lt;map&gt;#include &lt;set&gt;#include &lt;list&gt;#include &lt;array&gt;#include &lt;cfenv&gt;#include &lt;cmath&gt;#include &lt;ctime&gt;#include &lt;deque&gt;#include &lt;mutex&gt;#include &lt;queue&gt;#include &lt;ratio&gt;#include &lt;regex&gt;#include &lt;stack&gt;#include &lt;tuple&gt;#include &lt;atomic&gt;#include &lt;bitset&gt;#include &lt;cctype&gt;#include &lt;cerrno&gt;#include &lt;cfloat&gt;#include &lt;chrono&gt;#include &lt;cstdio&gt;#include &lt;cwchar&gt;#include &lt;future&gt;#include &lt;limits&gt;#include &lt;locale&gt;#include &lt;memory&gt;#include &lt;random&gt;#include &lt;string&gt;#include &lt;thread&gt;#include &lt;vector&gt;#include &lt;cassert&gt;#include &lt;climits&gt;#include &lt;clocale&gt;#include &lt;complex&gt;#include &lt;csetjmp&gt;#include &lt;csignal&gt;#include &lt;cstdarg&gt;#include &lt;cstddef&gt;#include &lt;cstdint&gt;#include &lt;cstdlib&gt;#include &lt;cstring&gt;#include &lt;ctgmath&gt;#include &lt;cwctype&gt;#include &lt;fstream&gt;#include &lt;iomanip&gt;#include &lt;numeric&gt;#include &lt;sstream&gt;#include &lt;ccomplex&gt;#include &lt;cstdbool&gt;#include &lt;iostream&gt;#include &lt;typeinfo&gt;#include &lt;valarray&gt;#include &lt;algorithm&gt;#include &lt;cinttypes&gt;#include &lt;cstdalign&gt;#include &lt;stdexcept&gt;#include &lt;typeindex&gt;#include &lt;functional&gt;#include &lt;forward_list&gt;#include &lt;system_error&gt;#include &lt;unordered_map&gt;#include &lt;unordered_set&gt;#include &lt;scoped_allocator&gt;#include &lt;condition_variable&gt;// #include &lt;conio.h&gt;// #include &lt;windows.h&gt;using namespace std;typedef long long LL;typedef unsigned int ui;typedef unsigned long long ull;typedef float fl;typedef double ld;typedef long double LD;typedef pair&lt;int,int&gt; pii;#if (WIN32) || (WIN64) || (__WIN32) || (__WIN64) || (_WIN32) || (_WIN64) || (WINDOWS)#define lld "%I64d"#define llu "%I64u"#else#define lld "%lld"#define llu "%llu"#endif#define ui(n) ((unsigned int)(n))#define LL(n) ((long long)(n))#define ull(n) ((unsigned long long)(n))#define fl(n) ((float)(n))#define ld(n) ((double)(n))#define LD(n) ((long double)(n))#define char(n) ((char)(n))#define Bool(n) ((bool)(n))#define fixpoint(n) fixed&lt;&lt;setprecision(n)const int INF=1061109567;const int NINF=-1044266559;const LL LINF=4557430888798830399;const ld eps=1e-15;#define MOD (1000000007)#define PI (3.1415926535897932384626433832795028841971)/*#define MB_LEN_MAX 5#define SHRT_MIN (-32768)#define SHRT_MAX 32767#define USHRT_MAX 0xffffU#define INT_MIN (-2147483647 - 1)#define INT_MAX 2147483647#define UINT_MAX 0xffffffffU#define LONG_MIN (-2147483647L - 1)#define LONG_MAX 2147483647L#define ULONG_MAX 0xffffffffUL#define LLONG_MAX 9223372036854775807ll#define LLONG_MIN (-9223372036854775807ll - 1)#define ULLONG_MAX 0xffffffffffffffffull*/#define MP make_pair#define MT make_tuple#define All(a) (a).begin(),(a).end()#define pall(a) (a).rbegin(),(a).rend()#define Log(x,y) log(x)/log(y)#define SZ(a) ((int)(a).size())#define rep(i,n) for(int i=0;i&lt;((int)(n));i++)#define rep1(i,n) for(int i=1;i&lt;=((int)(n));i++)#define repa(i,a,n) for(int i=((int)(a));i&lt;((int)(n));i++)#define repa1(i,a,n) for(int i=((int)(a));i&lt;=((int)(n));i++)#define repd(i,n) for(int i=((int)(n))-1;i&gt;=0;i--)#define repd1(i,n) for(int i=((int)(n));i&gt;=1;i--)#define repda(i,n,a) for(int i=((int)(n));i&gt;((int)(a));i--)#define repda1(i,n,a) for(int i=((int)(n));i&gt;=((int)(a));i--)#define FOR(i,a,n,step) for(int i=((int)(a));i&lt;((int)(n));i+=((int)(step)))#define repv(itr,v) for(__typeof((v).begin()) itr=(v).begin();itr!=(v).end();itr++)#define repV(i,v) for(auto i:v)#define repE(i,v) for(auto &amp;i:v)#define MS(x,y) memset(x,y,sizeof(x))#define MC(x) MS(x,0)#define MINF(x) MS(x,63)#define MCP(x,y) memcpy(x,y,sizeof(y))#define sqr(x) ((x)*(x))#define UN(v) sort(All(v)),v.erase(unique(All(v)),v.end())#define filein(x) freopen(x,"r",stdin)#define fileout(x) freopen(x,"w",stdout)#define fileio(x)\ freopen(x".in","r",stdin);\ freopen(x".out","w",stdout)#define filein2(filename,name) ifstream name(filename,ios::in)#define fileout2(filename,name) ofstream name(filename,ios::out)#define file(filename,name) fstream name(filename,ios::in|ios::out)#define Pause system("pause")#define Cls system("cls")#define fs first#define sc second#define PC(x) putchar(x)#define GC(x) x=getchar()#define Endl PC('\n')#define SF scanf#define PF printfinline int Read()&#123; int X=0,w=0;char ch=0;while(!isdigit(ch))&#123;w|=ch=='-';ch=getchar();&#125;while(isdigit(ch))X=(X&lt;&lt;3)+(X&lt;&lt;1)+(ch^48),ch=getchar(); return w?-X:X;&#125;inline void Write(int x)&#123;if(x&lt;0)putchar('-'),x=-x;if(x&gt;9)Write(x/10);putchar(x%10+'0');&#125;inline LL powmod(LL a,LL b)&#123;LL RES=1;a%=MOD;assert(b&gt;=0);for(;b;b&gt;&gt;=1)&#123;if(b&amp;1)RES=RES*a%MOD;a=a*a%MOD;&#125;return RES%MOD;&#125;inline LL gcdll(LL a,LL b)&#123;return b?gcdll(b,a%b):a;&#125;const int dx[]=&#123;0,1,0,-1,1,-1,-1,1&#125;;const int dy[]=&#123;1,0,-1,0,-1,-1,1,1&#125;;/************************************************************Begin************************************************************/const int maxn=200010;int n,a[maxn],alp;vector&lt;pair&lt;int,int&gt; &gt; v;inline int getlen()&#123; int len=0; repV(i,v) len+=i.sc; return len;&#125;inline int getlast()&#123; return v.back().fs;&#125;inline void pushstr(int x,int cnt)&#123; if(!v.empty()&amp;&amp;x==getlast()) v.back().sc+=cnt; else v.push_back(&#123;x,cnt&#125;);&#125;inline bool transform(int len)&#123; int cur=getlen(); if(cur&lt;len) &#123; pushstr(0,len-cur); &#125; else &#123; while(!v.empty()&amp;&amp;cur-v.back().sc&gt;=len) &#123; cur-=v.back().sc; v.pop_back(); &#125; v.back().sc-=cur-len; while(!v.empty()&amp;&amp;getlast()==alp-1) v.pop_back(); if(v.empty()) return 0; int x=getlast()+1;v.back().sc--; if(!v.back().sc) v.pop_back(); pushstr(x,1); pushstr(0,len-getlen()); &#125; return 1;&#125;inline bool check()&#123; v.clear(); rep(i,n) if(!transform(a[i])) return 0; return 1;&#125;int main()&#123; SF("%d",&amp;n); rep(i,n) SF("%d",&amp;a[i]); int l=1,r=n+1; // [l,r) while(l&lt;r) &#123; alp=(l+r)/2; if(check()) r=alp; else l=alp+1; &#125; PF("%d",r); return 0;&#125;/*************************************************************End**************************************************************/]]></content>
      <categories>
        <category>算法</category>
        <category>AtCoder</category>
      </categories>
      <tags>
        <tag>二分</tag>
        <tag>模拟</tag>
        <tag>贪心</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Ural 1204 Idempotents 题解]]></title>
    <url>%2F2019%2F08%2F29%2FUral-1204-Idempotents-%E9%A2%98%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[Ural 1204 Idempotents 题解题意给定$n$，且$n=p\times q$，$p,q$为不相等的质数。求所有的$x$，满足$0\le x\le n$且$x^2=x\pmod{n}$，并按序输出。 题解 \begin{align*} &\because x^2=x\pmod{n}\\ &\therefore x(x-1)=0\pmod{n}\\ &\therefore x(x-1)=0\pmod{pq}\\ &\therefore x(x-1)=kpq,k\ge 0\\ &\because x\le pq\\ &\therefore \begin{cases} x\%p=0,x\%q=1\\ x\%p=1,x\%q=0\\ \end{cases}\\ &\therefore \begin{cases} x=ap,x=bq+1\\ x=cp+1,x=dq \end{cases}\\ &\therefore \begin{cases} ap-bq=1\\ dq-cp=1 \end{cases} \end{align*}因为$gcd(p,q)=1$，所以可以用扩展欧几里得算法求出$x$。如果$x$是负数需要加上$n$。 程序123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228// #pragma GCC optimize(2)// #pragma G++ optimize(2)// #pragma comment(linker,"/STACK:102400000,102400000")// #include &lt;bits/stdc++.h&gt;#include &lt;map&gt;#include &lt;set&gt;#include &lt;list&gt;#include &lt;array&gt;#include &lt;cfenv&gt;#include &lt;cmath&gt;#include &lt;ctime&gt;#include &lt;deque&gt;#include &lt;mutex&gt;#include &lt;queue&gt;#include &lt;ratio&gt;#include &lt;regex&gt;#include &lt;stack&gt;#include &lt;tuple&gt;#include &lt;atomic&gt;#include &lt;bitset&gt;#include &lt;cctype&gt;#include &lt;cerrno&gt;#include &lt;cfloat&gt;#include &lt;chrono&gt;#include &lt;cstdio&gt;#include &lt;cwchar&gt;#include &lt;future&gt;#include &lt;limits&gt;#include &lt;locale&gt;#include &lt;memory&gt;#include &lt;random&gt;#include &lt;string&gt;#include &lt;thread&gt;#include &lt;vector&gt;#include &lt;cassert&gt;#include &lt;climits&gt;#include &lt;clocale&gt;#include &lt;complex&gt;#include &lt;csetjmp&gt;#include &lt;csignal&gt;#include &lt;cstdarg&gt;#include &lt;cstddef&gt;#include &lt;cstdint&gt;#include &lt;cstdlib&gt;#include &lt;cstring&gt;#include &lt;ctgmath&gt;#include &lt;cwctype&gt;#include &lt;fstream&gt;#include &lt;iomanip&gt;#include &lt;numeric&gt;#include &lt;sstream&gt;#include &lt;ccomplex&gt;#include &lt;cstdbool&gt;#include &lt;iostream&gt;#include &lt;typeinfo&gt;#include &lt;valarray&gt;#include &lt;algorithm&gt;#include &lt;cinttypes&gt;#include &lt;cstdalign&gt;#include &lt;stdexcept&gt;#include &lt;typeindex&gt;#include &lt;functional&gt;#include &lt;forward_list&gt;#include &lt;system_error&gt;#include &lt;unordered_map&gt;#include &lt;unordered_set&gt;#include &lt;scoped_allocator&gt;#include &lt;condition_variable&gt;// #include &lt;conio.h&gt;// #include &lt;windows.h&gt;using namespace std;typedef long long LL;typedef unsigned int ui;typedef unsigned long long ull;typedef float fl;typedef double ld;typedef long double LD;typedef pair&lt;int,int&gt; pii;#if (WIN32) || (WIN64) || (__WIN32) || (__WIN64) || (_WIN32) || (_WIN64) || (WINDOWS)#define lld "%I64d"#define llu "%I64u"#else#define lld "%lld"#define llu "%llu"#endif#define ui(n) ((unsigned int)(n))#define LL(n) ((long long)(n))#define ull(n) ((unsigned long long)(n))#define fl(n) ((float)(n))#define ld(n) ((double)(n))#define LD(n) ((long double)(n))#define char(n) ((char)(n))#define Bool(n) ((bool)(n))#define fixpoint(n) fixed&lt;&lt;setprecision(n)const int INF=1061109567;const int NINF=-1044266559;const LL LINF=4557430888798830399;const ld eps=1e-15;#define MOD (1000000007)#define PI (3.1415926535897932384626433832795028841971)/*#define MB_LEN_MAX 5#define SHRT_MIN (-32768)#define SHRT_MAX 32767#define USHRT_MAX 0xffffU#define INT_MIN (-2147483647 - 1)#define INT_MAX 2147483647#define UINT_MAX 0xffffffffU#define LONG_MIN (-2147483647L - 1)#define LONG_MAX 2147483647L#define ULONG_MAX 0xffffffffUL#define LLONG_MAX 9223372036854775807ll#define LLONG_MIN (-9223372036854775807ll - 1)#define ULLONG_MAX 0xffffffffffffffffull*/#define MP make_pair#define MT make_tuple#define All(a) (a).begin(),(a).end()#define pall(a) (a).rbegin(),(a).rend()#define Log(x,y) log(x)/log(y)#define SZ(a) ((int)(a).size())#define rep(i,n) for(int i=0;i&lt;((int)(n));i++)#define rep1(i,n) for(int i=1;i&lt;=((int)(n));i++)#define repa(i,a,n) for(int i=((int)(a));i&lt;((int)(n));i++)#define repa1(i,a,n) for(int i=((int)(a));i&lt;=((int)(n));i++)#define repd(i,n) for(int i=((int)(n))-1;i&gt;=0;i--)#define repd1(i,n) for(int i=((int)(n));i&gt;=1;i--)#define repda(i,n,a) for(int i=((int)(n));i&gt;((int)(a));i--)#define repda1(i,n,a) for(int i=((int)(n));i&gt;=((int)(a));i--)#define FOR(i,a,n,step) for(int i=((int)(a));i&lt;((int)(n));i+=((int)(step)))#define repv(itr,v) for(__typeof((v).begin()) itr=(v).begin();itr!=(v).end();itr++)#define repV(i,v) for(auto i:v)#define repE(i,v) for(auto &amp;i:v)#define MS(x,y) memset(x,y,sizeof(x))#define MC(x) MS(x,0)#define MINF(x) MS(x,63)#define MCP(x,y) memcpy(x,y,sizeof(y))#define sqr(x) ((x)*(x))#define UN(v) sort(All(v)),v.erase(unique(All(v)),v.end())#define filein(x) freopen(x,"r",stdin)#define fileout(x) freopen(x,"w",stdout)#define fileio(x)\ freopen(x".in","r",stdin);\ freopen(x".out","w",stdout)#define filein2(filename,name) ifstream name(filename,ios::in)#define fileout2(filename,name) ofstream name(filename,ios::out)#define file(filename,name) fstream name(filename,ios::in|ios::out)#define Pause system("pause")#define Cls system("cls")#define fs first#define sc second#define PC(x) putchar(x)#define GC(x) x=getchar()#define Endl PC('\n')#define SF scanf#define PF printfinline int Read()&#123; int X=0,w=0;char ch=0;while(!isdigit(ch))&#123;w|=ch=='-';ch=getchar();&#125;while(isdigit(ch))X=(X&lt;&lt;3)+(X&lt;&lt;1)+(ch^48),ch=getchar(); return w?-X:X;&#125;inline void Write(int x)&#123;if(x&lt;0)putchar('-'),x=-x;if(x&gt;9)Write(x/10);putchar(x%10+'0');&#125;inline LL powmod(LL a,LL b)&#123;LL RES=1;a%=MOD;assert(b&gt;=0);for(;b;b&gt;&gt;=1)&#123;if(b&amp;1)RES=RES*a%MOD;a=a*a%MOD;&#125;return RES%MOD;&#125;inline LL gcdll(LL a,LL b)&#123;return b?gcdll(b,a%b):a;&#125;const int dx[]=&#123;0,1,0,-1,1,-1,-1,1&#125;;const int dy[]=&#123;1,0,-1,0,-1,-1,1,1&#125;;/************************************************************Begin************************************************************/const int maxn=1000000000;int tim,n,p,q;vector&lt;int&gt; pri;bool isp[100010];inline void exgcd(int a,int b,int &amp;x,int &amp;y)&#123; if(b) &#123; exgcd(b,a%b,y,x); y-=a/b*x; &#125; else &#123; x=1; y=0; &#125;&#125;int main()&#123; for(int i=2;i&lt;=100000;i++) if(!isp[i]) &#123; pri.push_back(i); for(int j=i*2;j&lt;=100000;j+=i) isp[i]=1; &#125; SF("%d",&amp;tim); while(tim--) &#123; SF("%d",&amp;n); repV(i,pri) if(n%i==0) &#123; p=i; q=n/i; break; &#125; int x,y,ans1,ans2; exgcd(p,q,x,y); ans1=x&gt;0?x*p:x*p+n; exgcd(q,p,x,y); ans2=x&gt;0?x*q:x*q+n; PF("0 1 %d %d\n",min(ans1,ans2),max(ans1,ans2)); &#125; return 0;&#125;/*************************************************************End**************************************************************/]]></content>
      <categories>
        <category>算法</category>
        <category>Ural</category>
      </categories>
      <tags>
        <tag>数学</tag>
        <tag>拓展欧几里得</tag>
        <tag>同余</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Ural 1298 Knight 题解]]></title>
    <url>%2F2019%2F08%2F18%2FUral-1298-Knight-%E9%A2%98%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[Ural 1298 Knight 题解题意给定一个$n\times n(1\le n\le8)$的国际象棋棋盘和一个骑士(基本上相当于中国象棋的马)，问可否用经过每个格子$1$次。如果可以，输出路径，否则输出IMPOSSIBLE。 题解考虑回溯。暴力程序十分好写，但是会超时。 可以用启发式优化。 设当前点为$(x,y)$，可到达的点为$(x’,y’)$。优先选择$(x’,y’)$状态种数少的回溯，即可以转移的格子的数量少。 这样优化后就可以过了。 Tip: 优化后很快，为0.015s。 程序123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260// #pragma GCC optimize(2)// #pragma G++ optimize(2)// #pragma comment(linker,"/STACK:102400000,102400000")// #include &lt;bits/stdc++.h&gt;#include &lt;map&gt;#include &lt;set&gt;#include &lt;list&gt;#include &lt;array&gt;#include &lt;cfenv&gt;#include &lt;cmath&gt;#include &lt;ctime&gt;#include &lt;deque&gt;#include &lt;mutex&gt;#include &lt;queue&gt;#include &lt;ratio&gt;#include &lt;regex&gt;#include &lt;stack&gt;#include &lt;tuple&gt;#include &lt;atomic&gt;#include &lt;bitset&gt;#include &lt;cctype&gt;#include &lt;cerrno&gt;#include &lt;cfloat&gt;#include &lt;chrono&gt;#include &lt;cstdio&gt;#include &lt;cwchar&gt;#include &lt;future&gt;#include &lt;limits&gt;#include &lt;locale&gt;#include &lt;memory&gt;#include &lt;random&gt;#include &lt;string&gt;#include &lt;thread&gt;#include &lt;vector&gt;#include &lt;cassert&gt;#include &lt;climits&gt;#include &lt;clocale&gt;#include &lt;complex&gt;#include &lt;csetjmp&gt;#include &lt;csignal&gt;#include &lt;cstdarg&gt;#include &lt;cstddef&gt;#include &lt;cstdint&gt;#include &lt;cstdlib&gt;#include &lt;cstring&gt;#include &lt;ctgmath&gt;#include &lt;cwctype&gt;#include &lt;fstream&gt;#include &lt;iomanip&gt;#include &lt;numeric&gt;#include &lt;sstream&gt;#include &lt;ccomplex&gt;#include &lt;cstdbool&gt;#include &lt;iostream&gt;#include &lt;typeinfo&gt;#include &lt;valarray&gt;#include &lt;algorithm&gt;#include &lt;cinttypes&gt;#include &lt;cstdalign&gt;#include &lt;stdexcept&gt;#include &lt;typeindex&gt;#include &lt;functional&gt;#include &lt;forward_list&gt;#include &lt;system_error&gt;#include &lt;unordered_map&gt;#include &lt;unordered_set&gt;#include &lt;scoped_allocator&gt;#include &lt;condition_variable&gt;// #include &lt;conio.h&gt;// #include &lt;windows.h&gt;using namespace std;typedef long long LL;typedef unsigned int ui;typedef unsigned long long ull;typedef float fl;typedef double ld;typedef long double LD;typedef pair&lt;int,int&gt; pii;#if (WIN32) || (WIN64) || (__WIN32) || (__WIN64) || (_WIN32) || (_WIN64) || (WINDOWS)#define lld "%I64d"#define llu "%I64u"#else#define lld "%lld"#define llu "%llu"#endif#define ui(n) ((unsigned int)(n))#define LL(n) ((long long)(n))#define ull(n) ((unsigned long long)(n))#define fl(n) ((float)(n))#define ld(n) ((double)(n))#define LD(n) ((long double)(n))#define char(n) ((char)(n))#define Bool(n) ((bool)(n))#define fixpoint(n) fixed&lt;&lt;setprecision(n)const int INF=1061109567;const int NINF=-1044266559;const LL LINF=4557430888798830399;const ld eps=1e-15;#define MOD (1000000007)#define PI (3.1415926535897932384626433832795028841971)/*#define MB_LEN_MAX 5#define SHRT_MIN (-32768)#define SHRT_MAX 32767#define USHRT_MAX 0xffffU#define INT_MIN (-2147483647 - 1)#define INT_MAX 2147483647#define UINT_MAX 0xffffffffU#define LONG_MIN (-2147483647L - 1)#define LONG_MAX 2147483647L#define ULONG_MAX 0xffffffffUL#define LLONG_MAX 9223372036854775807ll#define LLONG_MIN (-9223372036854775807ll - 1)#define ULLONG_MAX 0xffffffffffffffffull*/#define MP make_pair#define MT make_tuple#define All(a) (a).begin(),(a).end()#define pall(a) (a).rbegin(),(a).rend()#define log2(x) log(x)/log(2)#define Log(x,y) log(x)/log(y)#define SZ(a) ((int)(a).size())#define rep(i,n) for(int i=0;i&lt;((int)(n));i++)#define rep1(i,n) for(int i=1;i&lt;=((int)(n));i++)#define repa(i,a,n) for(int i=((int)(a));i&lt;((int)(n));i++)#define repa1(i,a,n) for(int i=((int)(a));i&lt;=((int)(n));i++)#define repd(i,n) for(int i=((int)(n))-1;i&gt;=0;i--)#define repd1(i,n) for(int i=((int)(n));i&gt;=1;i--)#define repda(i,n,a) for(int i=((int)(n));i&gt;((int)(a));i--)#define repda1(i,n,a) for(int i=((int)(n));i&gt;=((int)(a));i--)#define FOR(i,a,n,step) for(int i=((int)(a));i&lt;((int)(n));i+=((int)(step)))#define repv(itr,v) for(__typeof((v).begin()) itr=(v).begin();itr!=(v).end();itr++)#define repV(i,v) for(auto i:v)#define repE(i,v) for(auto &amp;i:v)#define MS(x,y) memset(x,y,sizeof(x))#define MC(x) MS(x,0)#define MINF(x) MS(x,63)#define MCP(x,y) memcpy(x,y,sizeof(y))#define sqr(x) ((x)*(x))#define UN(v) sort(All(v)),v.erase(unique(All(v)),v.end())#define filein(x) freopen(x,"r",stdin)#define fileout(x) freopen(x,"w",stdout)#define fileio(x)\ freopen(x".in","r",stdin);\ freopen(x".out","w",stdout)#define filein2(filename,name) ifstream name(filename,ios::in)#define fileout2(filename,name) ofstream name(filename,ios::out)#define file(filename,name) fstream name(filename,ios::in|ios::out)#define Pause system("pause")#define Cls system("cls")#define fs first#define sc second#define PC(x) putchar(x)#define GC(x) x=getchar()#define Endl PC('\n')#define SF scanf#define PF printfinline int Read()&#123; int X=0,w=0;char ch=0;while(!isdigit(ch))&#123;w|=ch=='-';ch=getchar();&#125;while(isdigit(ch))X=(X&lt;&lt;3)+(X&lt;&lt;1)+(ch^48),ch=getchar(); return w?-X:X;&#125;inline void Write(int x)&#123;if(x&lt;0)putchar('-'),x=-x;if(x&gt;9)Write(x/10);putchar(x%10+'0');&#125;inline LL powmod(LL a,LL b)&#123;LL RES=1;a%=MOD;assert(b&gt;=0);for(;b;b&gt;&gt;=1)&#123;if(b&amp;1)RES=RES*a%MOD;a=a*a%MOD;&#125;return RES%MOD;&#125;inline LL gcdll(LL a,LL b)&#123;return b?gcdll(b,a%b):a;&#125;const int dx[]=&#123;1,1,2,2,-1,-1,-2,-2&#125;;const int dy[]=&#123;2,-2,1,-1,2,-2,1,-1&#125;;/************************************************************Begin************************************************************/const int maxn=10;int n,cnt[maxn][maxn];bool vis[maxn][maxn];pair&lt;int,int&gt; pre[maxn][maxn];vector&lt;pair&lt;int,int&gt; &gt; v;inline bool ok()&#123; rep(i,n) rep(j,n) if(!vis[i][j]) return 0; return 1;&#125;inline void print(int x,int y)&#123; if(pre[x][y].fs!=-1) print(pre[x][y].fs,pre[x][y].sc); PF("%c%c\n",char(x+'a'),char(y+'1'));&#125;inline bool cmp(pair&lt;int,int&gt; x,pair&lt;int,int&gt; y)&#123; return cnt[x.fs][x.sc]&lt;cnt[y.fs][y.sc];&#125;inline void dfs(int x,int y)&#123; vis[x][y]=1; if(ok()) &#123; print(x,y); exit(0); &#125; vector&lt;pair&lt;int,int&gt; &gt; w;w.clear(); rep(i,8) &#123; int cx=x+dx[i],cy=y+dy[i]; if(cx&gt;=0&amp;&amp;cx&lt;n&amp;&amp;cy&gt;=0&amp;&amp;cy&lt;n&amp;&amp;!vis[cx][cy]) w.push_back(&#123;cx,cy&#125;); &#125; sort(All(w),cmp); repV(i,w) &#123; int cx=i.fs,cy=i.sc; pre[cx][cy]=&#123;x,y&#125;; dfs(cx,cy); &#125; vis[x][y]=0;&#125;int main()&#123; SF("%d",&amp;n); rep(i,n) rep(j,n) &#123; v.push_back(&#123;i,j&#125;); rep(k,8) &#123; int ci=i+dx[k],cj=j+dy[k]; if(ci&gt;=0&amp;&amp;ci&lt;n&amp;&amp;cj&gt;=0&amp;&amp;cj&lt;n) cnt[i][j]++; &#125; &#125; sort(All(v),cmp); repV(it,v) &#123; int i=it.fs,j=it.sc; MC(vis); MC(pre); pre[i][j]=&#123;-1,-1&#125;; dfs(i,j); &#125; PF("IMPOSSIBLE"); return 0;&#125;/*************************************************************End**************************************************************/]]></content>
      <categories>
        <category>算法</category>
        <category>Ural</category>
      </categories>
      <tags>
        <tag>回溯</tag>
        <tag>启发式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Ural 1248 Sequence Sum 题解]]></title>
    <url>%2F2019%2F08%2F18%2FUral-1248-Sequence-Sum-%E9%A2%98%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[Ural 1248 Sequence Sum 题解题意给定$n$个用科学计数法表示的实数$(10^{-100}\sim10^{100})$，输出它们的和。 Tip: 一个实数可以用科学计数法表示为$x\times10^y$，其中$1\le x&lt;10$ $x$为实数，$y$是整数。输入时表示为$xey$。保证输入的实数有$19$位有效数字。输出时用科学计数法，必须包括$19$位正确数字。 题解 读入字符串，把它们换成正常形态放入数组。 小数点对齐。 计算。 换成科学计数法输出。 Tip: 口胡得很简单，写起来可能有点麻烦，要仔细。 程序123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273// #pragma GCC optimize(2)// #pragma G++ optimize(2)// #pragma comment(linker,"/STACK:102400000,102400000")// #include &lt;bits/stdc++.h&gt;#include &lt;map&gt;#include &lt;set&gt;#include &lt;list&gt;#include &lt;array&gt;#include &lt;cfenv&gt;#include &lt;cmath&gt;#include &lt;ctime&gt;#include &lt;deque&gt;#include &lt;mutex&gt;#include &lt;queue&gt;#include &lt;ratio&gt;#include &lt;regex&gt;#include &lt;stack&gt;#include &lt;tuple&gt;#include &lt;atomic&gt;#include &lt;bitset&gt;#include &lt;cctype&gt;#include &lt;cerrno&gt;#include &lt;cfloat&gt;#include &lt;chrono&gt;#include &lt;cstdio&gt;#include &lt;cwchar&gt;#include &lt;future&gt;#include &lt;limits&gt;#include &lt;locale&gt;#include &lt;memory&gt;#include &lt;random&gt;#include &lt;string&gt;#include &lt;thread&gt;#include &lt;vector&gt;#include &lt;cassert&gt;#include &lt;climits&gt;#include &lt;clocale&gt;#include &lt;complex&gt;#include &lt;csetjmp&gt;#include &lt;csignal&gt;#include &lt;cstdarg&gt;#include &lt;cstddef&gt;#include &lt;cstdint&gt;#include &lt;cstdlib&gt;#include &lt;cstring&gt;#include &lt;ctgmath&gt;#include &lt;cwctype&gt;#include &lt;fstream&gt;#include &lt;iomanip&gt;#include &lt;numeric&gt;#include &lt;sstream&gt;#include &lt;ccomplex&gt;#include &lt;cstdbool&gt;#include &lt;iostream&gt;#include &lt;typeinfo&gt;#include &lt;valarray&gt;#include &lt;algorithm&gt;#include &lt;cinttypes&gt;#include &lt;cstdalign&gt;#include &lt;stdexcept&gt;#include &lt;typeindex&gt;#include &lt;functional&gt;#include &lt;forward_list&gt;#include &lt;system_error&gt;#include &lt;unordered_map&gt;#include &lt;unordered_set&gt;#include &lt;scoped_allocator&gt;#include &lt;condition_variable&gt;// #include &lt;conio.h&gt;// #include &lt;windows.h&gt;using namespace std;typedef long long LL;typedef unsigned int ui;typedef unsigned long long ull;typedef float fl;typedef double ld;typedef long double LD;typedef pair&lt;int,int&gt; pii;#if (WIN32) || (WIN64) || (__WIN32) || (__WIN64) || (_WIN32) || (_WIN64) || (WINDOWS)#define lld "%I64d"#define llu "%I64u"#else#define lld "%lld"#define llu "%llu"#endif#define ui(n) ((unsigned int)(n))#define LL(n) ((long long)(n))#define ull(n) ((unsigned long long)(n))#define fl(n) ((float)(n))#define ld(n) ((double)(n))#define LD(n) ((long double)(n))#define char(n) ((char)(n))#define Bool(n) ((bool)(n))#define fixpoint(n) fixed&lt;&lt;setprecision(n)const int INF=1061109567;const int NINF=-1044266559;const LL LINF=4557430888798830399;const ld eps=1e-15;#define MOD (1000000007)#define PI (3.1415926535897932384626433832795028841971)/*#define MB_LEN_MAX 5#define SHRT_MIN (-32768)#define SHRT_MAX 32767#define USHRT_MAX 0xffffU#define INT_MIN (-2147483647 - 1)#define INT_MAX 2147483647#define UINT_MAX 0xffffffffU#define LONG_MIN (-2147483647L - 1)#define LONG_MAX 2147483647L#define ULONG_MAX 0xffffffffUL#define LLONG_MAX 9223372036854775807ll#define LLONG_MIN (-9223372036854775807ll - 1)#define ULLONG_MAX 0xffffffffffffffffull*/#define MP make_pair#define MT make_tuple#define All(a) (a).begin(),(a).end()#define pall(a) (a).rbegin(),(a).rend()#define log2(x) log(x)/log(2)#define Log(x,y) log(x)/log(y)#define SZ(a) ((int)(a).size())#define rep(i,n) for(int i=0;i&lt;((int)(n));i++)#define rep1(i,n) for(int i=1;i&lt;=((int)(n));i++)#define repa(i,a,n) for(int i=((int)(a));i&lt;((int)(n));i++)#define repa1(i,a,n) for(int i=((int)(a));i&lt;=((int)(n));i++)#define repd(i,n) for(int i=((int)(n))-1;i&gt;=0;i--)#define repd1(i,n) for(int i=((int)(n));i&gt;=1;i--)#define repda(i,n,a) for(int i=((int)(n));i&gt;((int)(a));i--)#define repda1(i,n,a) for(int i=((int)(n));i&gt;=((int)(a));i--)#define FOR(i,a,n,step) for(int i=((int)(a));i&lt;((int)(n));i+=((int)(step)))#define repv(itr,v) for(__typeof((v).begin()) itr=(v).begin();itr!=(v).end();itr++)#define repV(i,v) for(auto i:v)#define repE(i,v) for(auto &amp;i:v)#define MS(x,y) memset(x,y,sizeof(x))#define MC(x) MS(x,0)#define MINF(x) MS(x,63)#define MCP(x,y) memcpy(x,y,sizeof(y))#define sqr(x) ((x)*(x))#define UN(v) sort(All(v)),v.erase(unique(All(v)),v.end())#define filein(x) freopen(x,"r",stdin)#define fileout(x) freopen(x,"w",stdout)#define fileio(x)\ freopen(x".in","r",stdin);\ freopen(x".out","w",stdout)#define filein2(filename,name) ifstream name(filename,ios::in)#define fileout2(filename,name) ofstream name(filename,ios::out)#define file(filename,name) fstream name(filename,ios::in|ios::out)#define Pause system("pause")#define Cls system("cls")#define fs first#define sc second#define PC(x) putchar(x)#define GC(x) x=getchar()#define Endl PC('\n')#define SF scanf#define PF printfinline int Read()&#123; int X=0,w=0;char ch=0;while(!isdigit(ch))&#123;w|=ch=='-';ch=getchar();&#125;while(isdigit(ch))X=(X&lt;&lt;3)+(X&lt;&lt;1)+(ch^48),ch=getchar(); return w?-X:X;&#125;inline void Write(int x)&#123;if(x&lt;0)putchar('-'),x=-x;if(x&gt;9)Write(x/10);putchar(x%10+'0');&#125;inline LL powmod(LL a,LL b)&#123;LL RES=1;a%=MOD;assert(b&gt;=0);for(;b;b&gt;&gt;=1)&#123;if(b&amp;1)RES=RES*a%MOD;a=a*a%MOD;&#125;return RES%MOD;&#125;inline LL gcdll(LL a,LL b)&#123;return b?gcdll(b,a%b):a;&#125;const int dx[]=&#123;0,1,0,-1,1,-1,-1,1&#125;;const int dy[]=&#123;1,0,-1,0,-1,-1,1,1&#125;;/************************************************************Begin************************************************************/const int maxn=1010;const int Dot=500;int n,dig[maxn][maxn];inline int Atoi(string x)&#123; int res=0; repV(i,x) if(isdigit(i)) res=(res+i-'0')*10;res/=10; return (x[0]=='-'?-res:res);&#125;inline void func(int k,string x)&#123; int e=x.find("e"); string a=x.substr(0,e),b=x.substr(e+1); if(a.find(".")==string::npos) a+='.'; rep(i,101) a='0'+a; rep(i,101) a+='0'; int dot=a.find(".")+Atoi(b)-(b[0]=='-'?1:0); int hav=0; repd(i,dot+1) &#123; if(a[i]=='.') &#123; hav=1; continue; &#125; dig[k][Dot-(dot-i+1)+hav]=a[i]-'0'; &#125; hav=0; repa(i,dot+1,a.size()) &#123; if(a[i]=='.') &#123; hav=1; continue; &#125; dig[k][Dot+(i-dot)-hav]=a[i]-'0'; &#125;&#125;int main()&#123; cin&gt;&gt;n; rep(i,n) &#123; string x;cin&gt;&gt;x; func(i,x); &#125; rep(i,n) rep(j,1000) dig[n][j]+=dig[i][j]; repd(j,1000) &#123; while(dig[n][j]&gt;=10) &#123; int hav=0; if(j-1==Dot) hav=1; dig[n][j-1-hav]+=dig[n][j]/10; dig[n][j]%=10; &#125; &#125; int w=INF,e=0; rep(i,Dot) if(dig[n][i]) &#123; w=i; e=Dot-w-1; break; &#125; if(w==INF) &#123; repa(i,Dot+1,1000) if(dig[n][i]) &#123; w=i; e=i-Dot; break; &#125; e=-e; &#125; cout&lt;&lt;dig[n][w]&lt;&lt;'.'; repa(i,w+1,w+20) if(i!=Dot) cout&lt;&lt;dig[n][i]; cout&lt;&lt;'e'&lt;&lt;e; return 0;&#125;/*************************************************************End**************************************************************/]]></content>
      <categories>
        <category>算法</category>
        <category>Ural</category>
      </categories>
      <tags>
        <tag>模拟</tag>
        <tag>数论</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Ural 1238 Folding 题解]]></title>
    <url>%2F2019%2F08%2F18%2FUral-1238-Folding-%E9%A2%98%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[Ural 1238 Folding 题解题意定义折叠、展开为： 单个大写英文字母是一个折叠的串，把它展开后是它本身。 如果$S$和$Q$是折叠的串，则$SQ$也是折叠的串。如果$S$展开后为$S’$，$Q$展开后为$Q’$，则$SQ$展开后为$S’Q’$。 如果$S$是个折叠的串，则$X(S)$也是折叠的串，其中$X$是一个十进制大于$1$的整数，如果$S$展开为$S’$，则$X(S)$展开后为$S’$重复$X$次。 给定一个字符串(长度小于等于$100$)，求把它折叠后有最小长度的那个字符串。 题解考虑记忆化搜索(DP也可以)。 定义$f(s)$为$s$字符串折叠后有最小长度的那个字符串。 边界为当$|s|\le4$($|s|$为$s$的长度)时，$f(s)=s$。 给定$s$，求出$f(s)$有以下几种方式 $f(s)=s$。 设$1&lt;x\le|s|,|s|\%x=0$且有字符串$q$，$q$重复$x$次为$s$，$f(s)=x”(“+f(q)+”)”$。 设$0&lt;i&lt;|s|$，$f(s)=f(s[0..i-1])+f(s[i..|s|-1])$。 取长度最小的值即可，不要忘了记忆化。 程序123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230// #pragma GCC optimize(2)// #pragma G++ optimize(2)// #pragma comment(linker,"/STACK:102400000,102400000")// #include &lt;bits/stdc++.h&gt;#include &lt;map&gt;#include &lt;set&gt;#include &lt;list&gt;#include &lt;array&gt;#include &lt;cfenv&gt;#include &lt;cmath&gt;#include &lt;ctime&gt;#include &lt;deque&gt;#include &lt;mutex&gt;#include &lt;queue&gt;#include &lt;ratio&gt;#include &lt;regex&gt;#include &lt;stack&gt;#include &lt;tuple&gt;#include &lt;atomic&gt;#include &lt;bitset&gt;#include &lt;cctype&gt;#include &lt;cerrno&gt;#include &lt;cfloat&gt;#include &lt;chrono&gt;#include &lt;cstdio&gt;#include &lt;cwchar&gt;#include &lt;future&gt;#include &lt;limits&gt;#include &lt;locale&gt;#include &lt;memory&gt;#include &lt;random&gt;#include &lt;string&gt;#include &lt;thread&gt;#include &lt;vector&gt;#include &lt;cassert&gt;#include &lt;climits&gt;#include &lt;clocale&gt;#include &lt;complex&gt;#include &lt;csetjmp&gt;#include &lt;csignal&gt;#include &lt;cstdarg&gt;#include &lt;cstddef&gt;#include &lt;cstdint&gt;#include &lt;cstdlib&gt;#include &lt;cstring&gt;#include &lt;ctgmath&gt;#include &lt;cwctype&gt;#include &lt;fstream&gt;#include &lt;iomanip&gt;#include &lt;numeric&gt;#include &lt;sstream&gt;#include &lt;ccomplex&gt;#include &lt;cstdbool&gt;#include &lt;iostream&gt;#include &lt;typeinfo&gt;#include &lt;valarray&gt;#include &lt;algorithm&gt;#include &lt;cinttypes&gt;#include &lt;cstdalign&gt;#include &lt;stdexcept&gt;#include &lt;typeindex&gt;#include &lt;functional&gt;#include &lt;forward_list&gt;#include &lt;system_error&gt;#include &lt;unordered_map&gt;#include &lt;unordered_set&gt;#include &lt;scoped_allocator&gt;#include &lt;condition_variable&gt;// #include &lt;conio.h&gt;// #include &lt;windows.h&gt;using namespace std;typedef long long LL;typedef unsigned int ui;typedef unsigned long long ull;typedef float fl;typedef double ld;typedef long double LD;typedef pair&lt;int,int&gt; pii;#if (WIN32) || (WIN64) || (__WIN32) || (__WIN64) || (_WIN32) || (_WIN64) || (WINDOWS)#define lld "%I64d"#define llu "%I64u"#else#define lld "%lld"#define llu "%llu"#endif#define ui(n) ((unsigned int)(n))#define LL(n) ((long long)(n))#define ull(n) ((unsigned long long)(n))#define fl(n) ((float)(n))#define ld(n) ((double)(n))#define LD(n) ((long double)(n))#define char(n) ((char)(n))#define Bool(n) ((bool)(n))#define fixpoint(n) fixed&lt;&lt;setprecision(n)const int INF=1061109567;const int NINF=-1044266559;const LL LINF=4557430888798830399;const ld eps=1e-15;#define MOD (1000000007)#define PI (3.1415926535897932384626433832795028841971)/*#define MB_LEN_MAX 5#define SHRT_MIN (-32768)#define SHRT_MAX 32767#define USHRT_MAX 0xffffU#define INT_MIN (-2147483647 - 1)#define INT_MAX 2147483647#define UINT_MAX 0xffffffffU#define LONG_MIN (-2147483647L - 1)#define LONG_MAX 2147483647L#define ULONG_MAX 0xffffffffUL#define LLONG_MAX 9223372036854775807ll#define LLONG_MIN (-9223372036854775807ll - 1)#define ULLONG_MAX 0xffffffffffffffffull*/#define MP make_pair#define MT make_tuple#define All(a) (a).begin(),(a).end()#define pall(a) (a).rbegin(),(a).rend()#define log2(x) log(x)/log(2)#define Log(x,y) log(x)/log(y)#define SZ(a) ((int)(a).size())#define rep(i,n) for(int i=0;i&lt;((int)(n));i++)#define rep1(i,n) for(int i=1;i&lt;=((int)(n));i++)#define repa(i,a,n) for(int i=((int)(a));i&lt;((int)(n));i++)#define repa1(i,a,n) for(int i=((int)(a));i&lt;=((int)(n));i++)#define repd(i,n) for(int i=((int)(n))-1;i&gt;=0;i--)#define repd1(i,n) for(int i=((int)(n));i&gt;=1;i--)#define repda(i,n,a) for(int i=((int)(n));i&gt;((int)(a));i--)#define repda1(i,n,a) for(int i=((int)(n));i&gt;=((int)(a));i--)#define FOR(i,a,n,step) for(int i=((int)(a));i&lt;((int)(n));i+=((int)(step)))#define repv(itr,v) for(__typeof((v).begin()) itr=(v).begin();itr!=(v).end();itr++)#define repV(i,v) for(auto i:v)#define repE(i,v) for(auto &amp;i:v)#define MS(x,y) memset(x,y,sizeof(x))#define MC(x) MS(x,0)#define MINF(x) MS(x,63)#define MCP(x,y) memcpy(x,y,sizeof(y))#define sqr(x) ((x)*(x))#define UN(v) sort(All(v)),v.erase(unique(All(v)),v.end())#define filein(x) freopen(x,"r",stdin)#define fileout(x) freopen(x,"w",stdout)#define fileio(x)\ freopen(x".in","r",stdin);\ freopen(x".out","w",stdout)#define filein2(filename,name) ifstream name(filename,ios::in)#define fileout2(filename,name) ofstream name(filename,ios::out)#define file(filename,name) fstream name(filename,ios::in|ios::out)#define Pause system("pause")#define Cls system("cls")#define fs first#define sc second#define PC(x) putchar(x)#define GC(x) x=getchar()#define Endl PC('\n')#define SF scanf#define PF printfinline int Read()&#123; int X=0,w=0;char ch=0;while(!isdigit(ch))&#123;w|=ch=='-';ch=getchar();&#125;while(isdigit(ch))X=(X&lt;&lt;3)+(X&lt;&lt;1)+(ch^48),ch=getchar(); return w?-X:X;&#125;inline void Write(int x)&#123;if(x&lt;0)putchar('-'),x=-x;if(x&gt;9)Write(x/10);putchar(x%10+'0');&#125;inline LL powmod(LL a,LL b)&#123;LL RES=1;a%=MOD;assert(b&gt;=0);for(;b;b&gt;&gt;=1)&#123;if(b&amp;1)RES=RES*a%MOD;a=a*a%MOD;&#125;return RES%MOD;&#125;inline LL gcdll(LL a,LL b)&#123;return b?gcdll(b,a%b):a;&#125;const int dx[]=&#123;0,1,0,-1,1,-1,-1,1&#125;;const int dy[]=&#123;1,0,-1,0,-1,-1,1,1&#125;;/************************************************************Begin************************************************************/const int maxn=110;inline string Itoa(int x)&#123; string res=""; while(x) &#123; res+=char(x%10+'0'); x/=10; &#125; reverse(All(res)); return res;&#125;map&lt;string,string&gt; vis;inline string sol(string s)&#123; if(vis.count(s)) return vis[s]; if(s.size()&lt;=4) return vis[s]=s; string ans=s; rep1(i,s.size()) if(i&gt;1&amp;&amp;s.size()%i==0) &#123; int len=s.size()/i; string x=s.substr(0,len); bool f=1; for(int j=0;j&lt;s.size();j+=len) if(s.substr(j,len)!=x) f=0; if(f) &#123; string res=Itoa(i)+'('+sol(x)+')'; if(ans.size()&gt;res.size()) ans=res; &#125; &#125; rep1(i,s.size()-1) &#123; string res=sol(s.substr(0,i))+sol(s.substr(i)); if(ans.size()&gt;res.size()) ans=res; &#125; return vis[s]=ans;&#125;int main()&#123; string s; cin&gt;&gt;s; cout&lt;&lt;sol(s); return 0;&#125;/*************************************************************End**************************************************************/]]></content>
      <categories>
        <category>算法</category>
        <category>Ural</category>
      </categories>
      <tags>
        <tag>DP</tag>
        <tag>记忆化搜索</tag>
        <tag>字符串</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Ural 1201 Which Day Is It 题解]]></title>
    <url>%2F2019%2F08%2F18%2FUral-1201-Which-Day-Is-It-%E9%A2%98%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[Ural 1201 Which Day Is It? 题解题意打印一个月历。 输入输入日$(1\sim31)$、月$(1\sim12)$、年$(1600\sim2400)$。 输出123456789输入: 16 3 2002输出:mon........4...11...18...25tue........5...12...19...26wed........6...13...20...27thu........7...14...21...28fri...1....8...15...22...29sat...2....9..[16]..23...30sun...3...10...17...24...31 123456789输入: 1 3 2002输出:mon........4...11...18...25tue........5...12...19...26wed........6...13...20...27thu........7...14...21...28fri.[.1]...8...15...22...29sat...2....9...16...23...30sun...3...10...17...24...31 打印$7$行，mon tue…这些都懂吧。在输入的那天打上[]。 Tips: 样例输出中的.其实是 (空格)。 输出的第一列日期前有三个.，第二列即以后一位数前有$4$个，两位数前有$3$个。 例: 123456789输入: 30 1 2012输出:mon........2....9...16...23..[30]tue........3...10...17...24...31wed........4...11...18...25.....thu........5...12...19...26.....fri........6...13...20...27.....sat........7...14...21...28.....sun...1....8...15...22...29..... 如果输入的那一天是个一位数，则打印$[.x]$。 题解 找出这一个月的第一天是星期几。 知道1.1.1(公元元年1月1日)是星期一。 暴力推一下就可以了。 打印月历。 Tip: 口胡得很简单，写起来可能有点麻烦，要仔细。 程序123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270// #pragma GCC optimize(2)// #pragma G++ optimize(2)// #pragma comment(linker,"/STACK:102400000,102400000")// #include &lt;bits/stdc++.h&gt;#include &lt;map&gt;#include &lt;set&gt;#include &lt;list&gt;#include &lt;array&gt;#include &lt;cfenv&gt;#include &lt;cmath&gt;#include &lt;ctime&gt;#include &lt;deque&gt;#include &lt;mutex&gt;#include &lt;queue&gt;#include &lt;ratio&gt;#include &lt;regex&gt;#include &lt;stack&gt;#include &lt;tuple&gt;#include &lt;atomic&gt;#include &lt;bitset&gt;#include &lt;cctype&gt;#include &lt;cerrno&gt;#include &lt;cfloat&gt;#include &lt;chrono&gt;#include &lt;cstdio&gt;#include &lt;cwchar&gt;#include &lt;future&gt;#include &lt;limits&gt;#include &lt;locale&gt;#include &lt;memory&gt;#include &lt;random&gt;#include &lt;string&gt;#include &lt;thread&gt;#include &lt;vector&gt;#include &lt;cassert&gt;#include &lt;climits&gt;#include &lt;clocale&gt;#include &lt;complex&gt;#include &lt;csetjmp&gt;#include &lt;csignal&gt;#include &lt;cstdarg&gt;#include &lt;cstddef&gt;#include &lt;cstdint&gt;#include &lt;cstdlib&gt;#include &lt;cstring&gt;#include &lt;ctgmath&gt;#include &lt;cwctype&gt;#include &lt;fstream&gt;#include &lt;iomanip&gt;#include &lt;numeric&gt;#include &lt;sstream&gt;#include &lt;ccomplex&gt;#include &lt;cstdbool&gt;#include &lt;iostream&gt;#include &lt;typeinfo&gt;#include &lt;valarray&gt;#include &lt;algorithm&gt;#include &lt;cinttypes&gt;#include &lt;cstdalign&gt;#include &lt;stdexcept&gt;#include &lt;typeindex&gt;#include &lt;functional&gt;#include &lt;forward_list&gt;#include &lt;system_error&gt;#include &lt;unordered_map&gt;#include &lt;unordered_set&gt;#include &lt;scoped_allocator&gt;#include &lt;condition_variable&gt;// #include &lt;conio.h&gt;// #include &lt;windows.h&gt;using namespace std;typedef long long LL;typedef unsigned int ui;typedef unsigned long long ull;typedef float fl;typedef double ld;typedef long double LD;typedef pair&lt;int,int&gt; pii;#if (WIN32) || (WIN64) || (__WIN32) || (__WIN64) || (_WIN32) || (_WIN64) || (WINDOWS)#define lld "%I64d"#define llu "%I64u"#else#define lld "%lld"#define llu "%llu"#endif#define ui(n) ((unsigned int)(n))#define LL(n) ((long long)(n))#define ull(n) ((unsigned long long)(n))#define fl(n) ((float)(n))#define ld(n) ((double)(n))#define LD(n) ((long double)(n))#define char(n) ((char)(n))#define Bool(n) ((bool)(n))#define fixpoint(n) fixed&lt;&lt;setprecision(n)const int INF=1061109567;const int NINF=-1044266559;const LL LINF=4557430888798830399;const ld eps=1e-15;#define MOD (1000000007)#define PI (3.1415926535897932384626433832795028841971)/*#define MB_LEN_MAX 5#define SHRT_MIN (-32768)#define SHRT_MAX 32767#define USHRT_MAX 0xffffU#define INT_MIN (-2147483647 - 1)#define INT_MAX 2147483647#define UINT_MAX 0xffffffffU#define LONG_MIN (-2147483647L - 1)#define LONG_MAX 2147483647L#define ULONG_MAX 0xffffffffUL#define LLONG_MAX 9223372036854775807ll#define LLONG_MIN (-9223372036854775807ll - 1)#define ULLONG_MAX 0xffffffffffffffffull*/#define MP make_pair#define MT make_tuple#define All(a) (a).begin(),(a).end()#define pall(a) (a).rbegin(),(a).rend()#define log2(x) log(x)/log(2)#define Log(x,y) log(x)/log(y)#define SZ(a) ((int)(a).size())#define rep(i,n) for(int i=0;i&lt;((int)(n));i++)#define rep1(i,n) for(int i=1;i&lt;=((int)(n));i++)#define repa(i,a,n) for(int i=((int)(a));i&lt;((int)(n));i++)#define repa1(i,a,n) for(int i=((int)(a));i&lt;=((int)(n));i++)#define repd(i,n) for(int i=((int)(n))-1;i&gt;=0;i--)#define repd1(i,n) for(int i=((int)(n));i&gt;=1;i--)#define repda(i,n,a) for(int i=((int)(n));i&gt;((int)(a));i--)#define repda1(i,n,a) for(int i=((int)(n));i&gt;=((int)(a));i--)#define FOR(i,a,n,step) for(int i=((int)(a));i&lt;((int)(n));i+=((int)(step)))#define repv(itr,v) for(__typeof((v).begin()) itr=(v).begin();itr!=(v).end();itr++)#define repV(i,v) for(auto i:v)#define repE(i,v) for(auto &amp;i:v)#define MS(x,y) memset(x,y,sizeof(x))#define MC(x) MS(x,0)#define MINF(x) MS(x,63)#define MCP(x,y) memcpy(x,y,sizeof(y))#define sqr(x) ((x)*(x))#define UN(v) sort(All(v)),v.erase(unique(All(v)),v.end())#define filein(x) freopen(x,"r",stdin)#define fileout(x) freopen(x,"w",stdout)#define fileio(x)\ freopen(x".in","r",stdin);\ freopen(x".out","w",stdout)#define filein2(filename,name) ifstream name(filename,ios::in)#define fileout2(filename,name) ofstream name(filename,ios::out)#define file(filename,name) fstream name(filename,ios::in|ios::out)#define Pause system("pause")#define Cls system("cls")#define fs first#define sc second#define PC(x) putchar(x)#define GC(x) x=getchar()#define Endl PC('\n')#define SF scanf#define PF printfinline int Read()&#123; int X=0,w=0;char ch=0;while(!isdigit(ch))&#123;w|=ch=='-';ch=getchar();&#125;while(isdigit(ch))X=(X&lt;&lt;3)+(X&lt;&lt;1)+(ch^48),ch=getchar(); return w?-X:X;&#125;inline void Write(int x)&#123;if(x&lt;0)putchar('-'),x=-x;if(x&gt;9)Write(x/10);putchar(x%10+'0');&#125;inline LL powmod(LL a,LL b)&#123;LL RES=1;a%=MOD;assert(b&gt;=0);for(;b;b&gt;&gt;=1)&#123;if(b&amp;1)RES=RES*a%MOD;a=a*a%MOD;&#125;return RES%MOD;&#125;inline LL gcdll(LL a,LL b)&#123;return b?gcdll(b,a%b):a;&#125;const int dx[]=&#123;0,1,0,-1,1,-1,-1,1&#125;;const int dy[]=&#123;1,0,-1,0,-1,-1,1,1&#125;;/************************************************************Begin************************************************************/const int maxn=INF;const int days[]=&#123;0,31,0,31,30,31,30,31,31,30,31,30,31&#125;;const string weeks[]=&#123;"","mon","tue","wed","thu","fri","sat","sun"&#125;;// 1.1.1 =&gt; moninline int getday(int year,int month)&#123; if(month==2) &#123; if(year%400==0) return 29; if(year%100==0) return 28; return year%4==0?29:28; &#125; else return days[month];&#125;inline bool cmp(int y1,int m1,int y2,int m2)&#123; if(y1==y2) return m1&lt;m2; else return y1&lt;y2;&#125;inline int getweek(int year,int month)&#123; int y=1,m=1,w=0; while(y!=year||m!=month) &#123; if(cmp(y,m,year,month)) &#123; w=(w+getday(y,m)%7)%7; m++; if(m==13) &#123; y++; m=1; &#125; &#125; &#125; return w+1;&#125;inline void print(int year,int month,int day)&#123; vector&lt;int&gt; w[8]; int lst=getweek(year,month); w[lst].push_back(1); rep1(i,lst-1) w[i].push_back(0); int pos[15]; pos[0]=6; rep1(i,5) pos[i]=pos[i-1]+5; repa1(i,2,getday(year,month)) &#123; lst++; if(lst==8) lst=1; w[lst].push_back(i); &#125; string str[8]; rep1(i,7) &#123; str[i]=weeks[i]; rep(j,100) str[i]+=" "; rep(j,w[i].size()) &#123; int x=w[i][j]; if(x) str[i][pos[j]]=(x%10+'0'); if(x/10) str[i][pos[j]-1]=(x/10+'0'); if(x==day) &#123; str[i][pos[j]-2]='['; str[i][pos[j]+1]=']'; &#125; &#125; &#125; rep1(i,7) cout&lt;&lt;str[i]&lt;&lt;endl;&#125;int main()&#123; int year,month,day; cin&gt;&gt;day&gt;&gt;month&gt;&gt;year; print(year,month,day); return 0;&#125;/*************************************************************End**************************************************************/]]></content>
      <categories>
        <category>算法</category>
        <category>Ural</category>
      </categories>
      <tags>
        <tag>模拟</tag>
        <tag>暴力</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Codeforces 718A Efim and Strange Grade 程序分析]]></title>
    <url>%2F2019%2F08%2F18%2FCodeforces-718A-Efim-and-Strange-Grade-%E7%A8%8B%E5%BA%8F%E5%88%86%E6%9E%90%2F</url>
    <content type="text"><![CDATA[Codeforces 718A Efim and Strange Grade 程序分析 jerry的程序123456789101112131415161718192021222324252627282930313233343536373839404142434445using namespace std;typedef long long ll; string buf;int i; void up(int at)&#123; at--; if (at &lt; 0) &#123; buf = '1' + buf; i++; return; &#125; if (buf[at] == '.') at--; buf[at]++; if (buf[at] == '9'+1) &#123; buf[at] = '0'; up(at); &#125;&#125; int main()&#123; cin.sync_with_stdio(false); cin.tie(0); int n, k; cin &gt;&gt; n &gt;&gt; k &gt;&gt; buf; while (buf[i] != '.') i++; i++; while (i &lt; buf.length() &amp;&amp; buf[i] &lt;= '4') i++; if (i == buf.length()) &#123; cout &lt;&lt; buf &lt;&lt; endl; return 0; &#125; for (;buf[i] != '.' &amp;&amp; k;i--) if (buf[i] &gt;= '5') &#123; buf.resize(i); up(i); k--; &#125; if (buf.back() == '.') buf.pop_back(); cout &lt;&lt; buf &lt;&lt; endl; return 0;&#125; 首先，先找到小数点第一个后大于等于$5$的数位，如果没有的话直接输出原数。 从那个数位起，从后往前循环到小数点处，如果还当前数位大于等于$5$且有进位的机会，则先把这个数的结尾改成这个位置，因为之后的所有数都会被清零，然后调用up函数进位，如果有$9$的数继续递归，否则退出，如果整数部分首位还要进位，需要在最前面加上$1$。 最后注意最后一个字符如果是小数点要删去。 总结：用一个函数来执行进位，如果还有进位机会只需继续调用函数就行了，这样处理起来十分方便。 izrak的程序1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include &lt;bits/stdc++.h&gt; #define FO(i,a,b) for (int i = (a); i &lt; (b); i++)#define sz(v) int(v.size()) using namespace std; char s[200005]; int main() &#123; int l, t; scanf("%d %d", &amp;l, &amp;t); scanf("%s", s+1); s[0] = '0'; for (int i = 0; i &lt;= l; i++) &#123; if (s[i] == '.') &#123; for (int j = i+1; j &lt;= l; j++) if (s[j] &gt;= '5') &#123; s[j] = 0; bool roundup = true; t--; for (int k = j-1; k &gt; i; k--) &#123; // s[k]++ if (roundup) &#123; s[k]++; if (s[k] &gt;= '5' &amp;&amp; t) &#123; s[k] = 0; t--; roundup = true; &#125; else roundup = false; &#125; &#125; if (roundup) &#123; s[i] = 0; for (int k = i-1; k &gt;= 0; k--) &#123; s[k]++; if (s[k] &lt;= '9') break; else s[k] = '0'; &#125; &#125; break; &#125; &#125; &#125; if (s[0] != '0') &#123; printf("%s\n", s); &#125; else &#123; printf("%s\n", s+1); &#125;&#125; 这个程序读入时在数字前加上一个前导零，以便处理整数部分首位进位情况。 第一层循环找到小数点的位置，第二层循环找到小数点后第一位大于等于$5$的数字，第三层循环(最多进位到小数点)，roundup记录是否继续进位，如果进位后还有大于等于$5$的数字且还有进位机会，则继续进位。如果第三层循环结束后，仍需继续进位，则在整数部分进位。进位时每进位一次，就把这一位设置为\0，这样输出时只会输出到第一个\0的位置便结束。 注意最后需判断如果开始时加上的前导零仍是零，就不能输出。 总结：用bool变量roundup维护需不需要继续进位，进了位的位置就标为\0，如果在小数点前面进位直接循环处理即可，这样处理起来不容易错。]]></content>
      <categories>
        <category>算法</category>
        <category>Codeforces</category>
      </categories>
      <tags>
        <tag>数学</tag>
        <tag>DP</tag>
        <tag>模拟</tag>
        <tag>贪心</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2019 Multi-University Training Contest 2 1010 Just Skip The Problem 自闭记]]></title>
    <url>%2F2019%2F08%2F18%2F2019-Multi-University-Training-Contest-2-1010-Just-Skip-The-Problem-%E8%87%AA%E9%97%AD%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[2019 Multi-University Training Contest 2: 1010 Just Skip The Problem 自闭记题意多测。每次给你一个数$n$，你可以同时问无数次，每次问的是一个数$y_i$，你会得到的回答是$x\&amp;y_i$是否为$y_i$，问你问的最少的次数的种数$\%1e6+3$，可以调换顺序。 10min 得出数学方法求$n!\%1e6+3$。 50min 自闭 5min 写出裸暴力，优化10min，交一发TLE 30min 网上找各种快速阶乘题解、优化，发现板子全是错的：$3!$打出$60$、不会清空$\dots\dots$，写到自闭 5min 发现一旦$n\ge1e6+3$时取了模后就为$0$了$\dots\dots$，自闭 2min AC直接码，2min AC$\dots\dots$ 总结：以后多多总结性质。]]></content>
      <categories>
        <category>算法</category>
        <category>hdu</category>
        <category>多校</category>
      </categories>
      <tags>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Ural 1029 Ministry 题解]]></title>
    <url>%2F2019%2F08%2F12%2FUral-1029-Ministry-%E9%A2%98%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[Ural 1029 Ministry 题解题意给定一个$n\times m(1\le n \le10,1\le m \le500)$的矩阵，矩阵中的每个值都是一个小于等于$10^9$的正整数。 现在从第$1$行的任意位置开始，在第$n$行的任意位置结束。每次有$3$种移动选择(不能移动到矩阵外)。 设当前位置为$(i,j)$ 移动到$(i+1,j)$ 移动到$(i,j-1)$ 移动到$(i,j+1)$ 每条路径的价值是路径走过所有的位置上的值的和(小于等于$10^9$)。 问在所有路径中，路径价值最小的，输出这条路径所有位置的列号。 题解考虑记忆化搜索(DP也可以)。 对于每个点，记忆化搜索可以移动到它的$3$种位置，取最小值即可，顺便记录一下路径。 也可以无脑最短路。 Tips: WA$1$的同学不要着急，Test$1$并不是样例，仔细找找有没有错误。 设$(i,j)$的答案为$dp(i,j)$，矩阵中的值为$a(i,j)$，状态转移方程如果是$dp(i,j)=\min\{dp(i-1,j),dp(i,j-1),dp(i,j+1) \}+a(i,j)$可能会WA$1$，改为$dp(i,j)=\min\{dp(i-1,j)+a(i,j),dp(i,j-1)+a(i,j),dp(i,j+1)+a(i,j) \}$即可AC。目前并不知道原因(我太弱了)，如果有知道的可以在评论区留言，谢谢！ 程序AC程序123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228// #pragma GCC optimize(2)// #pragma G++ optimize(2)// #pragma comment(linker,"/STACK:102400000,102400000")// #include &lt;bits/stdc++.h&gt;#include &lt;map&gt;#include &lt;set&gt;#include &lt;list&gt;#include &lt;array&gt;#include &lt;cfenv&gt;#include &lt;cmath&gt;#include &lt;ctime&gt;#include &lt;deque&gt;#include &lt;mutex&gt;#include &lt;queue&gt;#include &lt;ratio&gt;#include &lt;regex&gt;#include &lt;stack&gt;#include &lt;tuple&gt;#include &lt;atomic&gt;#include &lt;bitset&gt;#include &lt;cctype&gt;#include &lt;cerrno&gt;#include &lt;cfloat&gt;#include &lt;chrono&gt;#include &lt;cstdio&gt;#include &lt;cwchar&gt;#include &lt;future&gt;#include &lt;limits&gt;#include &lt;locale&gt;#include &lt;memory&gt;#include &lt;random&gt;#include &lt;string&gt;#include &lt;thread&gt;#include &lt;vector&gt;#include &lt;cassert&gt;#include &lt;climits&gt;#include &lt;clocale&gt;#include &lt;complex&gt;#include &lt;csetjmp&gt;#include &lt;csignal&gt;#include &lt;cstdarg&gt;#include &lt;cstddef&gt;#include &lt;cstdint&gt;#include &lt;cstdlib&gt;#include &lt;cstring&gt;#include &lt;ctgmath&gt;#include &lt;cwctype&gt;#include &lt;fstream&gt;#include &lt;iomanip&gt;#include &lt;numeric&gt;#include &lt;sstream&gt;#include &lt;ccomplex&gt;#include &lt;cstdbool&gt;#include &lt;iostream&gt;#include &lt;typeinfo&gt;#include &lt;valarray&gt;#include &lt;algorithm&gt;#include &lt;cinttypes&gt;#include &lt;cstdalign&gt;#include &lt;stdexcept&gt;#include &lt;typeindex&gt;#include &lt;functional&gt;#include &lt;forward_list&gt;#include &lt;system_error&gt;#include &lt;unordered_map&gt;#include &lt;unordered_set&gt;#include &lt;scoped_allocator&gt;#include &lt;condition_variable&gt;// #include &lt;conio.h&gt;// #include &lt;windows.h&gt;using namespace std;typedef long long LL;typedef unsigned int ui;typedef unsigned long long ull;typedef float fl;typedef double ld;typedef long double LD;typedef pair&lt;int,int&gt; pii;#if (WIN32) || (WIN64) || (__WIN32) || (__WIN64) || (_WIN32) || (_WIN64) || (WINDOWS)#define lld "%I64d"#define llu "%I64u"#else#define lld "%lld"#define llu "%llu"#endif#define ui(n) ((unsigned int)(n))#define LL(n) ((long long)(n))#define ull(n) ((unsigned long long)(n))#define fl(n) ((float)(n))#define ld(n) ((double)(n))#define LD(n) ((long double)(n))#define char(n) ((char)(n))#define Bool(n) ((bool)(n))#define fixpoint(n) fixed&lt;&lt;setprecision(n)const int INF=1061109567;const int NINF=-1044266559;const LL LINF=4557430888798830399;const ld eps=1e-15;#define MOD (1000000007)#define PI (3.1415926535897932384626433832795028841971)/*#define MB_LEN_MAX 5#define SHRT_MIN (-32768)#define SHRT_MAX 32767#define USHRT_MAX 0xffffU#define INT_MIN (-2147483647 - 1)#define INT_MAX 2147483647#define UINT_MAX 0xffffffffU#define LONG_MIN (-2147483647L - 1)#define LONG_MAX 2147483647L#define ULONG_MAX 0xffffffffUL#define LLONG_MAX 9223372036854775807ll#define LLONG_MIN (-9223372036854775807ll - 1)#define ULLONG_MAX 0xffffffffffffffffull*/#define MP make_pair#define MT make_tuple#define All(a) (a).begin(),(a).end()#define pall(a) (a).rbegin(),(a).rend()#define log2(x) log(x)/log(2)#define Log(x,y) log(x)/log(y)#define SZ(a) ((int)(a).size())#define rep(i,n) for(int i=0;i&lt;((int)(n));i++)#define rep1(i,n) for(int i=1;i&lt;=((int)(n));i++)#define repa(i,a,n) for(int i=((int)(a));i&lt;((int)(n));i++)#define repa1(i,a,n) for(int i=((int)(a));i&lt;=((int)(n));i++)#define repd(i,n) for(int i=((int)(n))-1;i&gt;=0;i--)#define repd1(i,n) for(int i=((int)(n));i&gt;=1;i--)#define repda(i,n,a) for(int i=((int)(n));i&gt;((int)(a));i--)#define repda1(i,n,a) for(int i=((int)(n));i&gt;=((int)(a));i--)#define FOR(i,a,n,step) for(int i=((int)(a));i&lt;((int)(n));i+=((int)(step)))#define repv(itr,v) for(__typeof((v).begin()) itr=(v).begin();itr!=(v).end();itr++)#define repV(i,v) for(auto i:v)#define repE(i,v) for(auto &amp;i:v)#define MS(x,y) memset(x,y,sizeof(x))#define MC(x) MS(x,0)#define MINF(x) MS(x,63)#define MCP(x,y) memcpy(x,y,sizeof(y))#define sqr(x) ((x)*(x))#define UN(v) sort(All(v)),v.erase(unique(All(v)),v.end())#define filein(x) freopen(x,"r",stdin)#define fileout(x) freopen(x,"w",stdout)#define fileio(x)\ freopen(x".in","r",stdin);\ freopen(x".out","w",stdout)#define filein2(filename,name) ifstream name(filename,ios::in)#define fileout2(filename,name) ofstream name(filename,ios::out)#define file(filename,name) fstream name(filename,ios::in|ios::out)#define Pause system("pause")#define Cls system("cls")#define fs first#define sc second#define PC(x) putchar(x)#define GC(x) x=getchar()#define Endl PC('\n')#define SF scanf#define PF printfinline int Read()&#123; int X=0,w=0;char ch=0;while(!isdigit(ch))&#123;w|=ch=='-';ch=getchar();&#125;while(isdigit(ch))X=(X&lt;&lt;3)+(X&lt;&lt;1)+(ch^48),ch=getchar(); return w?-X:X;&#125;inline void Write(int x)&#123;if(x&lt;0)putchar('-'),x=-x;if(x&gt;9)Write(x/10);putchar(x%10+'0');&#125;inline LL powmod(LL a,LL b)&#123;LL RES=1;a%=MOD;assert(b&gt;=0);for(;b;b&gt;&gt;=1)&#123;if(b&amp;1)RES=RES*a%MOD;a=a*a%MOD;&#125;return RES%MOD;&#125;inline LL gcdll(LL a,LL b)&#123;return b?gcdll(b,a%b):a;&#125;const int dx[]=&#123;0,1,0,-1,1,-1,-1,1&#125;;const int dy[]=&#123;1,0,-1,0,-1,-1,1,1&#125;;/************************************************************Begin************************************************************/const int maxn=110,maxm=510;int n,m,a[maxn][maxm],dp[maxn][maxm];pair&lt;int,int&gt; pre[maxn][maxm];inline int sol(int x,int y)&#123; if(y&lt;1||y&gt;m) return dp[x][y]=INF; if(dp[x][y]!=-1) return dp[x][y]; else dp[x][y]=0; int res=sol(x-1,y)+a[x][y]; dp[x][y]=res; pre[x][y]=&#123;x-1,y&#125;; res=sol(x,y-1)+a[x][y]; if(res&lt;dp[x][y]) &#123; dp[x][y]=res; pre[x][y]=&#123;x,y-1&#125;; &#125; res=sol(x,y+1)+a[x][y]; if(res&lt;dp[x][y]) &#123; dp[x][y]=res; pre[x][y]=&#123;x,y+1&#125;; &#125; return dp[x][y];&#125;inline void print(int x,int y)&#123; if(x&gt;1) print(pre[x][y].fs,pre[x][y].sc); cout&lt;&lt;y&lt;&lt;' ';&#125;int main()&#123; cin&gt;&gt;n&gt;&gt;m; rep1(i,n) rep1(j,m) cin&gt;&gt;a[i][j]; MS(dp,-1); rep1(j,m) dp[1][j]=a[1][j]; int ans=1; rep1(j,m) if(sol(n,j)&lt;sol(n,ans)) ans=j; print(n,ans); return 0;&#125;/*************************************************************End**************************************************************/ WA$1$程序123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229// #pragma GCC optimize(2)// #pragma G++ optimize(2)// #pragma comment(linker,"/STACK:102400000,102400000")// #include &lt;bits/stdc++.h&gt;#include &lt;map&gt;#include &lt;set&gt;#include &lt;list&gt;#include &lt;array&gt;#include &lt;cfenv&gt;#include &lt;cmath&gt;#include &lt;ctime&gt;#include &lt;deque&gt;#include &lt;mutex&gt;#include &lt;queue&gt;#include &lt;ratio&gt;#include &lt;regex&gt;#include &lt;stack&gt;#include &lt;tuple&gt;#include &lt;atomic&gt;#include &lt;bitset&gt;#include &lt;cctype&gt;#include &lt;cerrno&gt;#include &lt;cfloat&gt;#include &lt;chrono&gt;#include &lt;cstdio&gt;#include &lt;cwchar&gt;#include &lt;future&gt;#include &lt;limits&gt;#include &lt;locale&gt;#include &lt;memory&gt;#include &lt;random&gt;#include &lt;string&gt;#include &lt;thread&gt;#include &lt;vector&gt;#include &lt;cassert&gt;#include &lt;climits&gt;#include &lt;clocale&gt;#include &lt;complex&gt;#include &lt;csetjmp&gt;#include &lt;csignal&gt;#include &lt;cstdarg&gt;#include &lt;cstddef&gt;#include &lt;cstdint&gt;#include &lt;cstdlib&gt;#include &lt;cstring&gt;#include &lt;ctgmath&gt;#include &lt;cwctype&gt;#include &lt;fstream&gt;#include &lt;iomanip&gt;#include &lt;numeric&gt;#include &lt;sstream&gt;#include &lt;ccomplex&gt;#include &lt;cstdbool&gt;#include &lt;iostream&gt;#include &lt;typeinfo&gt;#include &lt;valarray&gt;#include &lt;algorithm&gt;#include &lt;cinttypes&gt;#include &lt;cstdalign&gt;#include &lt;stdexcept&gt;#include &lt;typeindex&gt;#include &lt;functional&gt;#include &lt;forward_list&gt;#include &lt;system_error&gt;#include &lt;unordered_map&gt;#include &lt;unordered_set&gt;#include &lt;scoped_allocator&gt;#include &lt;condition_variable&gt;// #include &lt;conio.h&gt;// #include &lt;windows.h&gt;using namespace std;typedef long long LL;typedef unsigned int ui;typedef unsigned long long ull;typedef float fl;typedef double ld;typedef long double LD;typedef pair&lt;int,int&gt; pii;#if (WIN32) || (WIN64) || (__WIN32) || (__WIN64) || (_WIN32) || (_WIN64) || (WINDOWS)#define lld "%I64d"#define llu "%I64u"#else#define lld "%lld"#define llu "%llu"#endif#define ui(n) ((unsigned int)(n))#define LL(n) ((long long)(n))#define ull(n) ((unsigned long long)(n))#define fl(n) ((float)(n))#define ld(n) ((double)(n))#define LD(n) ((long double)(n))#define char(n) ((char)(n))#define Bool(n) ((bool)(n))#define fixpoint(n) fixed&lt;&lt;setprecision(n)const int INF=1061109567;const int NINF=-1044266559;const LL LINF=4557430888798830399;const ld eps=1e-15;#define MOD (1000000007)#define PI (3.1415926535897932384626433832795028841971)/*#define MB_LEN_MAX 5#define SHRT_MIN (-32768)#define SHRT_MAX 32767#define USHRT_MAX 0xffffU#define INT_MIN (-2147483647 - 1)#define INT_MAX 2147483647#define UINT_MAX 0xffffffffU#define LONG_MIN (-2147483647L - 1)#define LONG_MAX 2147483647L#define ULONG_MAX 0xffffffffUL#define LLONG_MAX 9223372036854775807ll#define LLONG_MIN (-9223372036854775807ll - 1)#define ULLONG_MAX 0xffffffffffffffffull*/#define MP make_pair#define MT make_tuple#define All(a) (a).begin(),(a).end()#define pall(a) (a).rbegin(),(a).rend()#define log2(x) log(x)/log(2)#define Log(x,y) log(x)/log(y)#define SZ(a) ((int)(a).size())#define rep(i,n) for(int i=0;i&lt;((int)(n));i++)#define rep1(i,n) for(int i=1;i&lt;=((int)(n));i++)#define repa(i,a,n) for(int i=((int)(a));i&lt;((int)(n));i++)#define repa1(i,a,n) for(int i=((int)(a));i&lt;=((int)(n));i++)#define repd(i,n) for(int i=((int)(n))-1;i&gt;=0;i--)#define repd1(i,n) for(int i=((int)(n));i&gt;=1;i--)#define repda(i,n,a) for(int i=((int)(n));i&gt;((int)(a));i--)#define repda1(i,n,a) for(int i=((int)(n));i&gt;=((int)(a));i--)#define FOR(i,a,n,step) for(int i=((int)(a));i&lt;((int)(n));i+=((int)(step)))#define repv(itr,v) for(__typeof((v).begin()) itr=(v).begin();itr!=(v).end();itr++)#define repV(i,v) for(auto i:v)#define repE(i,v) for(auto &amp;i:v)#define MS(x,y) memset(x,y,sizeof(x))#define MC(x) MS(x,0)#define MINF(x) MS(x,63)#define MCP(x,y) memcpy(x,y,sizeof(y))#define sqr(x) ((x)*(x))#define UN(v) sort(All(v)),v.erase(unique(All(v)),v.end())#define filein(x) freopen(x,"r",stdin)#define fileout(x) freopen(x,"w",stdout)#define fileio(x)\ freopen(x".in","r",stdin);\ freopen(x".out","w",stdout)#define filein2(filename,name) ifstream name(filename,ios::in)#define fileout2(filename,name) ofstream name(filename,ios::out)#define file(filename,name) fstream name(filename,ios::in|ios::out)#define Pause system("pause")#define Cls system("cls")#define fs first#define sc second#define PC(x) putchar(x)#define GC(x) x=getchar()#define Endl PC('\n')#define SF scanf#define PF printfinline int Read()&#123; int X=0,w=0;char ch=0;while(!isdigit(ch))&#123;w|=ch=='-';ch=getchar();&#125;while(isdigit(ch))X=(X&lt;&lt;3)+(X&lt;&lt;1)+(ch^48),ch=getchar(); return w?-X:X;&#125;inline void Write(int x)&#123;if(x&lt;0)putchar('-'),x=-x;if(x&gt;9)Write(x/10);putchar(x%10+'0');&#125;inline LL powmod(LL a,LL b)&#123;LL RES=1;a%=MOD;assert(b&gt;=0);for(;b;b&gt;&gt;=1)&#123;if(b&amp;1)RES=RES*a%MOD;a=a*a%MOD;&#125;return RES%MOD;&#125;inline LL gcdll(LL a,LL b)&#123;return b?gcdll(b,a%b):a;&#125;const int dx[]=&#123;0,1,0,-1,1,-1,-1,1&#125;;const int dy[]=&#123;1,0,-1,0,-1,-1,1,1&#125;;/************************************************************Begin************************************************************/const int maxn=110,maxm=510;int n,m,a[maxn][maxm],dp[maxn][maxm];pair&lt;int,int&gt; pre[maxn][maxm];inline int sol(int x,int y)&#123; if(y&lt;1||y&gt;m) return dp[x][y]=INF; if(dp[x][y]!=-1) return dp[x][y]; else dp[x][y]=0; int res=sol(x-1,y); dp[x][y]=res; pre[x][y]=&#123;x-1,y&#125;; res=sol(x,y-1); if(res&lt;dp[x][y]) &#123; dp[x][y]=res; pre[x][y]=&#123;x,y-1&#125;; &#125; res=sol(x,y+1); if(res&lt;dp[x][y]) &#123; dp[x][y]=res; pre[x][y]=&#123;x,y+1&#125;; &#125; dp[x][y]+=a[x][y]; return dp[x][y];&#125;inline void print(int x,int y)&#123; if(x&gt;1) print(pre[x][y].fs,pre[x][y].sc); cout&lt;&lt;y&lt;&lt;' ';&#125;int main()&#123; cin&gt;&gt;n&gt;&gt;m; rep1(i,n) rep1(j,m) cin&gt;&gt;a[i][j]; MS(dp,-1); rep1(j,m) dp[1][j]=a[1][j]; int ans=1; rep1(j,m) if(sol(n,j)&lt;sol(n,ans)) ans=j; print(n,ans); return 0;&#125;/*************************************************************End**************************************************************/]]></content>
      <categories>
        <category>算法</category>
        <category>Ural</category>
      </categories>
      <tags>
        <tag>DP</tag>
        <tag>记忆化搜索</tag>
        <tag>最短路</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Ural 1250 Sea Burial 题解]]></title>
    <url>%2F2019%2F08%2F12%2FUral-1250-Sea-Burial-%E9%A2%98%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[Ural 1250 Sea Burial 题解题意给定一个$n\times m$的地图，.为水，#为陆，地图的外部是水(地图被水包围)。水为八连通，陆为四联通。联通的水称为海，联通的陆称为岛。海内可能有岛，岛内可能有海。给定$x,y$求在包含$(x,y)$(保证$(x,y)$为水)的海里面有多少岛。 输入第一行包含$m,n,y,x(1\le n,m\le 500,1\le x \le n,1\le y \le m)$ 以下若干行为一个$n\times m$的地图 题解考虑BFS或DFS(以下简称BFS) 从$(x,y)$BFS，找出包含$(x,y)$的海。 从地图外部(水)BFS，找出在包含$(x,y)$的海的外面部分。 执行完前两步，就可以知道包含$(x,y)$的海里面的部分，数出包含$(x,y)$的海里面的部分有多少岛即可。 Tip: 运用二进制可以使程序简便。记陆为$1$，岛为$2$。设我们需要的值为$x$，当前的值为$y$，只需判断$(x\&amp;y)$是否大于$0$即可。第1步时$x=2$，第2步时$x=3$(想一想，为什么，答案最后揭晓)，第3步时$x=1$。 程序 BFS 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239// #pragma GCC optimize(2)// #pragma G++ optimize(2)// #pragma comment(linker,"/STACK:102400000,102400000")// #include &lt;bits/stdc++.h&gt;#include &lt;map&gt;#include &lt;set&gt;#include &lt;list&gt;#include &lt;array&gt;#include &lt;cfenv&gt;#include &lt;cmath&gt;#include &lt;ctime&gt;#include &lt;deque&gt;#include &lt;mutex&gt;#include &lt;queue&gt;#include &lt;ratio&gt;#include &lt;regex&gt;#include &lt;stack&gt;#include &lt;tuple&gt;#include &lt;atomic&gt;#include &lt;bitset&gt;#include &lt;cctype&gt;#include &lt;cerrno&gt;#include &lt;cfloat&gt;#include &lt;chrono&gt;#include &lt;cstdio&gt;#include &lt;cwchar&gt;#include &lt;future&gt;#include &lt;limits&gt;#include &lt;locale&gt;#include &lt;memory&gt;#include &lt;random&gt;#include &lt;string&gt;#include &lt;thread&gt;#include &lt;vector&gt;#include &lt;cassert&gt;#include &lt;climits&gt;#include &lt;clocale&gt;#include &lt;complex&gt;#include &lt;csetjmp&gt;#include &lt;csignal&gt;#include &lt;cstdarg&gt;#include &lt;cstddef&gt;#include &lt;cstdint&gt;#include &lt;cstdlib&gt;#include &lt;cstring&gt;#include &lt;ctgmath&gt;#include &lt;cwctype&gt;#include &lt;fstream&gt;#include &lt;iomanip&gt;#include &lt;numeric&gt;#include &lt;sstream&gt;#include &lt;ccomplex&gt;#include &lt;cstdbool&gt;#include &lt;iostream&gt;#include &lt;typeinfo&gt;#include &lt;valarray&gt;#include &lt;algorithm&gt;#include &lt;cinttypes&gt;#include &lt;cstdalign&gt;#include &lt;stdexcept&gt;#include &lt;typeindex&gt;#include &lt;functional&gt;#include &lt;forward_list&gt;#include &lt;system_error&gt;#include &lt;unordered_map&gt;#include &lt;unordered_set&gt;#include &lt;scoped_allocator&gt;#include &lt;condition_variable&gt;// #include &lt;conio.h&gt;// #include &lt;windows.h&gt;using namespace std;typedef long long LL;typedef unsigned int ui;typedef unsigned long long ull;typedef float fl;typedef double ld;typedef long double LD;typedef pair&lt;int,int&gt; pii;#if (WIN32) || (WIN64) || (__WIN32) || (__WIN64) || (_WIN32) || (_WIN64) || (WINDOWS)#define lld "%I64d"#define llu "%I64u"#else#define lld "%lld"#define llu "%llu"#endif#define ui(n) ((unsigned int)(n))#define LL(n) ((long long)(n))#define ull(n) ((unsigned long long)(n))#define fl(n) ((float)(n))#define ld(n) ((double)(n))#define LD(n) ((long double)(n))#define char(n) ((char)(n))#define Bool(n) ((bool)(n))#define fixpoint(n) fixed&lt;&lt;setprecision(n)const int INF=1061109567;const int NINF=-1044266559;const LL LINF=4557430888798830399;const ld eps=1e-15;#define MOD (1000000007)#define PI (3.1415926535897932384626433832795028841971)/*#define MB_LEN_MAX 5#define SHRT_MIN (-32768)#define SHRT_MAX 32767#define USHRT_MAX 0xffffU#define INT_MIN (-2147483647 - 1)#define INT_MAX 2147483647#define UINT_MAX 0xffffffffU#define LONG_MIN (-2147483647L - 1)#define LONG_MAX 2147483647L#define ULONG_MAX 0xffffffffUL#define LLONG_MAX 9223372036854775807ll#define LLONG_MIN (-9223372036854775807ll - 1)#define ULLONG_MAX 0xffffffffffffffffull*/#define MP make_pair#define MT make_tuple#define All(a) (a).begin(),(a).end()#define pall(a) (a).rbegin(),(a).rend()#define log2(x) log(x)/log(2)#define Log(x,y) log(x)/log(y)#define SZ(a) ((int)(a).size())#define rep(i,n) for(int i=0;i&lt;((int)(n));i++)#define rep1(i,n) for(int i=1;i&lt;=((int)(n));i++)#define repa(i,a,n) for(int i=((int)(a));i&lt;((int)(n));i++)#define repa1(i,a,n) for(int i=((int)(a));i&lt;=((int)(n));i++)#define repd(i,n) for(int i=((int)(n))-1;i&gt;=0;i--)#define repd1(i,n) for(int i=((int)(n));i&gt;=1;i--)#define repda(i,n,a) for(int i=((int)(n));i&gt;((int)(a));i--)#define repda1(i,n,a) for(int i=((int)(n));i&gt;=((int)(a));i--)#define FOR(i,a,n,step) for(int i=((int)(a));i&lt;((int)(n));i+=((int)(step)))#define repv(itr,v) for(__typeof((v).begin()) itr=(v).begin();itr!=(v).end();itr++)#define repV(i,v) for(auto i:v)#define repE(i,v) for(auto &amp;i:v)#define MS(x,y) memset(x,y,sizeof(x))#define MC(x) MS(x,0)#define MINF(x) MS(x,63)#define MCP(x,y) memcpy(x,y,sizeof(y))#define sqr(x) ((x)*(x))#define UN(v) sort(All(v)),v.erase(unique(All(v)),v.end())#define filein(x) freopen(x,"r",stdin)#define fileout(x) freopen(x,"w",stdout)#define fileio(x)\ freopen(x".in","r",stdin);\ freopen(x".out","w",stdout)#define filein2(filename,name) ifstream name(filename,ios::in)#define fileout2(filename,name) ofstream name(filename,ios::out)#define file(filename,name) fstream name(filename,ios::in|ios::out)#define Pause system("pause")#define Cls system("cls")#define fs first#define sc second#define PC(x) putchar(x)#define GC(x) x=getchar()#define Endl PC('\n')#define SF scanf#define PF printfinline int Read()&#123; int X=0,w=0;char ch=0;while(!isdigit(ch))&#123;w|=ch=='-';ch=getchar();&#125;while(isdigit(ch))X=(X&lt;&lt;3)+(X&lt;&lt;1)+(ch^48),ch=getchar(); return w?-X:X;&#125;inline void Write(int x)&#123;if(x&lt;0)putchar('-'),x=-x;if(x&gt;9)Write(x/10);putchar(x%10+'0');&#125;inline LL powmod(LL a,LL b)&#123;LL RES=1;a%=MOD;assert(b&gt;=0);for(;b;b&gt;&gt;=1)&#123;if(b&amp;1)RES=RES*a%MOD;a=a*a%MOD;&#125;return RES%MOD;&#125;inline LL gcdll(LL a,LL b)&#123;return b?gcdll(b,a%b):a;&#125;const int dx[]=&#123;0,1,0,-1,1,-1,-1,1&#125;;const int dy[]=&#123;1,0,-1,0,-1,-1,1,1&#125;;/************************************************************Begin************************************************************/const int maxn=510;int n,m,X,Y,s[maxn][maxn],ans; // '#'=&gt;1(01) '.'=&gt;2(10)bool vis[maxn][maxn];inline void bfs(int sx,int sy,int status)&#123; vis[sx][sy]=1; queue&lt;pair&lt;int,int&gt; &gt; q;q.push(&#123;sx,sy&#125;); while(!q.empty()) &#123; int x=q.front().fs,y=q.front().sc;q.pop(); rep(i,8) &#123; if(s[x][y]==1&amp;&amp;i&gt;3) break; int cx=x+dx[i],cy=y+dy[i]; if(cx&gt;0&amp;&amp;cx&lt;=n&amp;&amp;cy&gt;0&amp;&amp;cy&lt;=m&amp;&amp;!vis[cx][cy]&amp;&amp;(s[cx][cy]&amp;status)) &#123; vis[cx][cy]=1; q.push(&#123;cx,cy&#125;); &#125; &#125; &#125;&#125;int main()&#123; cin&gt;&gt;m&gt;&gt;n&gt;&gt;Y&gt;&gt;X; rep1(i,n) rep1(j,m) &#123; char c;cin&gt;&gt;c; s[i][j]=(c=='#'?1:2); &#125; // step 1 bfs(X,Y,2); // step 2 rep1(i,n) &#123; bfs(i,0,3); bfs(i,m+1,3); &#125; rep1(j,m) &#123; bfs(0,j,3); bfs(n+1,j,3); &#125; //step 3 rep1(i,n) rep1(j,m) if(!vis[i][j]&amp;&amp;s[i][j]==1) &#123; ans++; bfs(i,j,1); &#125; cout&lt;&lt;ans; return 0;&#125;/*************************************************************End**************************************************************/ DFS(与BFS十分类似) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229// #pragma GCC optimize(2)// #pragma G++ optimize(2)// #pragma comment(linker,"/STACK:102400000,102400000")// #include &lt;bits/stdc++.h&gt;#include &lt;map&gt;#include &lt;set&gt;#include &lt;list&gt;#include &lt;array&gt;#include &lt;cfenv&gt;#include &lt;cmath&gt;#include &lt;ctime&gt;#include &lt;deque&gt;#include &lt;mutex&gt;#include &lt;queue&gt;#include &lt;ratio&gt;#include &lt;regex&gt;#include &lt;stack&gt;#include &lt;tuple&gt;#include &lt;atomic&gt;#include &lt;bitset&gt;#include &lt;cctype&gt;#include &lt;cerrno&gt;#include &lt;cfloat&gt;#include &lt;chrono&gt;#include &lt;cstdio&gt;#include &lt;cwchar&gt;#include &lt;future&gt;#include &lt;limits&gt;#include &lt;locale&gt;#include &lt;memory&gt;#include &lt;random&gt;#include &lt;string&gt;#include &lt;thread&gt;#include &lt;vector&gt;#include &lt;cassert&gt;#include &lt;climits&gt;#include &lt;clocale&gt;#include &lt;complex&gt;#include &lt;csetjmp&gt;#include &lt;csignal&gt;#include &lt;cstdarg&gt;#include &lt;cstddef&gt;#include &lt;cstdint&gt;#include &lt;cstdlib&gt;#include &lt;cstring&gt;#include &lt;ctgmath&gt;#include &lt;cwctype&gt;#include &lt;fstream&gt;#include &lt;iomanip&gt;#include &lt;numeric&gt;#include &lt;sstream&gt;#include &lt;ccomplex&gt;#include &lt;cstdbool&gt;#include &lt;iostream&gt;#include &lt;typeinfo&gt;#include &lt;valarray&gt;#include &lt;algorithm&gt;#include &lt;cinttypes&gt;#include &lt;cstdalign&gt;#include &lt;stdexcept&gt;#include &lt;typeindex&gt;#include &lt;functional&gt;#include &lt;forward_list&gt;#include &lt;system_error&gt;#include &lt;unordered_map&gt;#include &lt;unordered_set&gt;#include &lt;scoped_allocator&gt;#include &lt;condition_variable&gt;// #include &lt;conio.h&gt;// #include &lt;windows.h&gt;using namespace std;typedef long long LL;typedef unsigned int ui;typedef unsigned long long ull;typedef float fl;typedef double ld;typedef long double LD;typedef pair&lt;int,int&gt; pii;#if (WIN32) || (WIN64) || (__WIN32) || (__WIN64) || (_WIN32) || (_WIN64) || (WINDOWS)#define lld "%I64d"#define llu "%I64u"#else#define lld "%lld"#define llu "%llu"#endif#define ui(n) ((unsigned int)(n))#define LL(n) ((long long)(n))#define ull(n) ((unsigned long long)(n))#define fl(n) ((float)(n))#define ld(n) ((double)(n))#define LD(n) ((long double)(n))#define char(n) ((char)(n))#define Bool(n) ((bool)(n))#define fixpoint(n) fixed&lt;&lt;setprecision(n)const int INF=1061109567;const int NINF=-1044266559;const LL LINF=4557430888798830399;const ld eps=1e-15;#define MOD (1000000007)#define PI (3.1415926535897932384626433832795028841971)/*#define MB_LEN_MAX 5#define SHRT_MIN (-32768)#define SHRT_MAX 32767#define USHRT_MAX 0xffffU#define INT_MIN (-2147483647 - 1)#define INT_MAX 2147483647#define UINT_MAX 0xffffffffU#define LONG_MIN (-2147483647L - 1)#define LONG_MAX 2147483647L#define ULONG_MAX 0xffffffffUL#define LLONG_MAX 9223372036854775807ll#define LLONG_MIN (-9223372036854775807ll - 1)#define ULLONG_MAX 0xffffffffffffffffull*/#define MP make_pair#define MT make_tuple#define All(a) (a).begin(),(a).end()#define pall(a) (a).rbegin(),(a).rend()#define log2(x) log(x)/log(2)#define Log(x,y) log(x)/log(y)#define SZ(a) ((int)(a).size())#define rep(i,n) for(int i=0;i&lt;((int)(n));i++)#define rep1(i,n) for(int i=1;i&lt;=((int)(n));i++)#define repa(i,a,n) for(int i=((int)(a));i&lt;((int)(n));i++)#define repa1(i,a,n) for(int i=((int)(a));i&lt;=((int)(n));i++)#define repd(i,n) for(int i=((int)(n))-1;i&gt;=0;i--)#define repd1(i,n) for(int i=((int)(n));i&gt;=1;i--)#define repda(i,n,a) for(int i=((int)(n));i&gt;((int)(a));i--)#define repda1(i,n,a) for(int i=((int)(n));i&gt;=((int)(a));i--)#define FOR(i,a,n,step) for(int i=((int)(a));i&lt;((int)(n));i+=((int)(step)))#define repv(itr,v) for(__typeof((v).begin()) itr=(v).begin();itr!=(v).end();itr++)#define repV(i,v) for(auto i:v)#define repE(i,v) for(auto &amp;i:v)#define MS(x,y) memset(x,y,sizeof(x))#define MC(x) MS(x,0)#define MINF(x) MS(x,63)#define MCP(x,y) memcpy(x,y,sizeof(y))#define sqr(x) ((x)*(x))#define UN(v) sort(All(v)),v.erase(unique(All(v)),v.end())#define filein(x) freopen(x,"r",stdin)#define fileout(x) freopen(x,"w",stdout)#define fileio(x)\ freopen(x".in","r",stdin);\ freopen(x".out","w",stdout)#define filein2(filename,name) ifstream name(filename,ios::in)#define fileout2(filename,name) ofstream name(filename,ios::out)#define file(filename,name) fstream name(filename,ios::in|ios::out)#define Pause system("pause")#define Cls system("cls")#define fs first#define sc second#define PC(x) putchar(x)#define GC(x) x=getchar()#define Endl PC('\n')#define SF scanf#define PF printfinline int Read()&#123; int X=0,w=0;char ch=0;while(!isdigit(ch))&#123;w|=ch=='-';ch=getchar();&#125;while(isdigit(ch))X=(X&lt;&lt;3)+(X&lt;&lt;1)+(ch^48),ch=getchar(); return w?-X:X;&#125;inline void Write(int x)&#123;if(x&lt;0)putchar('-'),x=-x;if(x&gt;9)Write(x/10);putchar(x%10+'0');&#125;inline LL powmod(LL a,LL b)&#123;LL RES=1;a%=MOD;assert(b&gt;=0);for(;b;b&gt;&gt;=1)&#123;if(b&amp;1)RES=RES*a%MOD;a=a*a%MOD;&#125;return RES%MOD;&#125;inline LL gcdll(LL a,LL b)&#123;return b?gcdll(b,a%b):a;&#125;const int dx[]=&#123;0,1,0,-1,1,-1,-1,1&#125;;const int dy[]=&#123;1,0,-1,0,-1,-1,1,1&#125;;/************************************************************Begin************************************************************/const int maxn=510;int n,m,X,Y,s[maxn][maxn],ans; // '#'=&gt;1(01) '.'=&gt;2(10)bool vis[maxn][maxn];inline void dfs(int x,int y,int status)&#123; vis[x][y]=1; rep(i,8) &#123; if(s[x][y]==1&amp;&amp;i&gt;3) break; int cx=x+dx[i],cy=y+dy[i]; if(cx&gt;0&amp;&amp;cx&lt;=n&amp;&amp;cy&gt;0&amp;&amp;cy&lt;=m&amp;&amp;!vis[cx][cy]&amp;&amp;(s[cx][cy]&amp;status)) dfs(cx,cy,status); &#125;&#125;int main()&#123; cin&gt;&gt;m&gt;&gt;n&gt;&gt;Y&gt;&gt;X; rep1(i,n) rep1(j,m) &#123; char c;cin&gt;&gt;c; s[i][j]=(c=='#'?1:2); &#125; // step 1 dfs(X,Y,2); // step 2 rep1(i,n) &#123; dfs(i,0,3); dfs(i,m+1,3); &#125; rep1(j,m) &#123; dfs(0,j,3); dfs(n+1,j,3); &#125; //step 3 rep1(i,n) rep1(j,m) if(!vis[i][j]&amp;&amp;s[i][j]==1) &#123; ans++; dfs(i,j,1); &#125; cout&lt;&lt;ans; return 0;&#125;/*************************************************************End**************************************************************/ Tip’s answer: 第2步是需要找出在包含$(x,y)$的海的外面部分，而外面部分不分海陆，$x=3$即$x=(11)_2$，这样$1\&amp;3$与$2\&amp;3$都大于$0$了。]]></content>
      <categories>
        <category>算法</category>
        <category>Ural</category>
      </categories>
      <tags>
        <tag>图论</tag>
        <tag>BFS</tag>
        <tag>DFS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2019%2F08%2F12%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Hello WorldHappy Coding, Happy OI 12345678#include &lt;bits/stdc++.h&gt;using namespace std;int main()&#123; cout&lt;&lt;"Happy Coding, Happy OI!"; return 0;&#125;]]></content>
  </entry>
</search>
