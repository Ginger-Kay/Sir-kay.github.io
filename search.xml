<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Ural 1298 Knight 题解]]></title>
    <url>%2F2019%2F08%2F18%2FUral-1298-Knight-%E9%A2%98%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[Ural 1298 Knight 题解题意给定一个$n\times n(1\le n\le8)$的国际象棋棋盘和一个骑士(基本上相当于中国象棋的马)，问可否用经过每个格子$1$次。如果可以，输出路径，否则输出IMPOSSIBLE。 题解考虑回溯。暴力程序十分好写，但是会超时。 可以用启发式优化。 设当前点为$(x,y)$，可到达的点为$(x’,y’)$。优先选择$(x’,y’)$状态种数少的回溯，即可以转移的格子的数量少。 这样优化后就可以过了。 Tip: 优化后很快，为$0.015s$。 程序123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260// #pragma GCC optimize(2)// #pragma G++ optimize(2)// #pragma comment(linker,"/STACK:102400000,102400000")// #include &lt;bits/stdc++.h&gt;#include &lt;map&gt;#include &lt;set&gt;#include &lt;list&gt;#include &lt;array&gt;#include &lt;cfenv&gt;#include &lt;cmath&gt;#include &lt;ctime&gt;#include &lt;deque&gt;#include &lt;mutex&gt;#include &lt;queue&gt;#include &lt;ratio&gt;#include &lt;regex&gt;#include &lt;stack&gt;#include &lt;tuple&gt;#include &lt;atomic&gt;#include &lt;bitset&gt;#include &lt;cctype&gt;#include &lt;cerrno&gt;#include &lt;cfloat&gt;#include &lt;chrono&gt;#include &lt;cstdio&gt;#include &lt;cwchar&gt;#include &lt;future&gt;#include &lt;limits&gt;#include &lt;locale&gt;#include &lt;memory&gt;#include &lt;random&gt;#include &lt;string&gt;#include &lt;thread&gt;#include &lt;vector&gt;#include &lt;cassert&gt;#include &lt;climits&gt;#include &lt;clocale&gt;#include &lt;complex&gt;#include &lt;csetjmp&gt;#include &lt;csignal&gt;#include &lt;cstdarg&gt;#include &lt;cstddef&gt;#include &lt;cstdint&gt;#include &lt;cstdlib&gt;#include &lt;cstring&gt;#include &lt;ctgmath&gt;#include &lt;cwctype&gt;#include &lt;fstream&gt;#include &lt;iomanip&gt;#include &lt;numeric&gt;#include &lt;sstream&gt;#include &lt;ccomplex&gt;#include &lt;cstdbool&gt;#include &lt;iostream&gt;#include &lt;typeinfo&gt;#include &lt;valarray&gt;#include &lt;algorithm&gt;#include &lt;cinttypes&gt;#include &lt;cstdalign&gt;#include &lt;stdexcept&gt;#include &lt;typeindex&gt;#include &lt;functional&gt;#include &lt;forward_list&gt;#include &lt;system_error&gt;#include &lt;unordered_map&gt;#include &lt;unordered_set&gt;#include &lt;scoped_allocator&gt;#include &lt;condition_variable&gt;// #include &lt;conio.h&gt;// #include &lt;windows.h&gt;using namespace std;typedef long long LL;typedef unsigned int ui;typedef unsigned long long ull;typedef float fl;typedef double ld;typedef long double LD;typedef pair&lt;int,int&gt; pii;#if (WIN32) || (WIN64) || (__WIN32) || (__WIN64) || (_WIN32) || (_WIN64) || (WINDOWS)#define lld "%I64d"#define llu "%I64u"#else#define lld "%lld"#define llu "%llu"#endif#define ui(n) ((unsigned int)(n))#define LL(n) ((long long)(n))#define ull(n) ((unsigned long long)(n))#define fl(n) ((float)(n))#define ld(n) ((double)(n))#define LD(n) ((long double)(n))#define char(n) ((char)(n))#define Bool(n) ((bool)(n))#define fixpoint(n) fixed&lt;&lt;setprecision(n)const int INF=1061109567;const int NINF=-1044266559;const LL LINF=4557430888798830399;const ld eps=1e-15;#define MOD (1000000007)#define PI (3.1415926535897932384626433832795028841971)/*#define MB_LEN_MAX 5#define SHRT_MIN (-32768)#define SHRT_MAX 32767#define USHRT_MAX 0xffffU#define INT_MIN (-2147483647 - 1)#define INT_MAX 2147483647#define UINT_MAX 0xffffffffU#define LONG_MIN (-2147483647L - 1)#define LONG_MAX 2147483647L#define ULONG_MAX 0xffffffffUL#define LLONG_MAX 9223372036854775807ll#define LLONG_MIN (-9223372036854775807ll - 1)#define ULLONG_MAX 0xffffffffffffffffull*/#define MP make_pair#define MT make_tuple#define All(a) (a).begin(),(a).end()#define pall(a) (a).rbegin(),(a).rend()#define log2(x) log(x)/log(2)#define Log(x,y) log(x)/log(y)#define SZ(a) ((int)(a).size())#define rep(i,n) for(int i=0;i&lt;((int)(n));i++)#define rep1(i,n) for(int i=1;i&lt;=((int)(n));i++)#define repa(i,a,n) for(int i=((int)(a));i&lt;((int)(n));i++)#define repa1(i,a,n) for(int i=((int)(a));i&lt;=((int)(n));i++)#define repd(i,n) for(int i=((int)(n))-1;i&gt;=0;i--)#define repd1(i,n) for(int i=((int)(n));i&gt;=1;i--)#define repda(i,n,a) for(int i=((int)(n));i&gt;((int)(a));i--)#define repda1(i,n,a) for(int i=((int)(n));i&gt;=((int)(a));i--)#define FOR(i,a,n,step) for(int i=((int)(a));i&lt;((int)(n));i+=((int)(step)))#define repv(itr,v) for(__typeof((v).begin()) itr=(v).begin();itr!=(v).end();itr++)#define repV(i,v) for(auto i:v)#define repE(i,v) for(auto &amp;i:v)#define MS(x,y) memset(x,y,sizeof(x))#define MC(x) MS(x,0)#define MINF(x) MS(x,63)#define MCP(x,y) memcpy(x,y,sizeof(y))#define sqr(x) ((x)*(x))#define UN(v) sort(All(v)),v.erase(unique(All(v)),v.end())#define filein(x) freopen(x,"r",stdin)#define fileout(x) freopen(x,"w",stdout)#define fileio(x)\ freopen(x".in","r",stdin);\ freopen(x".out","w",stdout)#define filein2(filename,name) ifstream name(filename,ios::in)#define fileout2(filename,name) ofstream name(filename,ios::out)#define file(filename,name) fstream name(filename,ios::in|ios::out)#define Pause system("pause")#define Cls system("cls")#define fs first#define sc second#define PC(x) putchar(x)#define GC(x) x=getchar()#define Endl PC('\n')#define SF scanf#define PF printfinline int Read()&#123; int X=0,w=0;char ch=0;while(!isdigit(ch))&#123;w|=ch=='-';ch=getchar();&#125;while(isdigit(ch))X=(X&lt;&lt;3)+(X&lt;&lt;1)+(ch^48),ch=getchar(); return w?-X:X;&#125;inline void Write(int x)&#123;if(x&lt;0)putchar('-'),x=-x;if(x&gt;9)Write(x/10);putchar(x%10+'0');&#125;inline LL powmod(LL a,LL b)&#123;LL RES=1;a%=MOD;assert(b&gt;=0);for(;b;b&gt;&gt;=1)&#123;if(b&amp;1)RES=RES*a%MOD;a=a*a%MOD;&#125;return RES%MOD;&#125;inline LL gcdll(LL a,LL b)&#123;return b?gcdll(b,a%b):a;&#125;const int dx[]=&#123;1,1,2,2,-1,-1,-2,-2&#125;;const int dy[]=&#123;2,-2,1,-1,2,-2,1,-1&#125;;/************************************************************Begin************************************************************/const int maxn=10;int n,cnt[maxn][maxn];bool vis[maxn][maxn];pair&lt;int,int&gt; pre[maxn][maxn];vector&lt;pair&lt;int,int&gt; &gt; v;inline bool ok()&#123; rep(i,n) rep(j,n) if(!vis[i][j]) return 0; return 1;&#125;inline void print(int x,int y)&#123; if(pre[x][y].fs!=-1) print(pre[x][y].fs,pre[x][y].sc); PF("%c%c\n",char(x+'a'),char(y+'1'));&#125;inline bool cmp(pair&lt;int,int&gt; x,pair&lt;int,int&gt; y)&#123; return cnt[x.fs][x.sc]&lt;cnt[y.fs][y.sc];&#125;inline void dfs(int x,int y)&#123; vis[x][y]=1; if(ok()) &#123; print(x,y); exit(0); &#125; vector&lt;pair&lt;int,int&gt; &gt; w;w.clear(); rep(i,8) &#123; int cx=x+dx[i],cy=y+dy[i]; if(cx&gt;=0&amp;&amp;cx&lt;n&amp;&amp;cy&gt;=0&amp;&amp;cy&lt;n&amp;&amp;!vis[cx][cy]) w.push_back(&#123;cx,cy&#125;); &#125; sort(All(w),cmp); repV(i,w) &#123; int cx=i.fs,cy=i.sc; pre[cx][cy]=&#123;x,y&#125;; dfs(cx,cy); &#125; vis[x][y]=0;&#125;int main()&#123; SF("%d",&amp;n); rep(i,n) rep(j,n) &#123; v.push_back(&#123;i,j&#125;); rep(k,8) &#123; int ci=i+dx[k],cj=j+dy[k]; if(ci&gt;=0&amp;&amp;ci&lt;n&amp;&amp;cj&gt;=0&amp;&amp;cj&lt;n) cnt[i][j]++; &#125; &#125; sort(All(v),cmp); repV(it,v) &#123; int i=it.fs,j=it.sc; MC(vis); MC(pre); pre[i][j]=&#123;-1,-1&#125;; dfs(i,j); &#125; PF("IMPOSSIBLE"); return 0;&#125;/*************************************************************End**************************************************************/]]></content>
      <categories>
        <category>算法</category>
        <category>Ural</category>
      </categories>
      <tags>
        <tag>回溯</tag>
        <tag>启发式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Ural 1248 Sequence Sum 题解]]></title>
    <url>%2F2019%2F08%2F18%2FUral-1248-Sequence-Sum-%E9%A2%98%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[Ural 1248 Sequence Sum 题解题意给定$n$个用科学计数法表示的实数$(10^{-100}\sim10^{100})$，输出它们的和。 Tip: 一个实数可以用科学计数法表示为$x\times10^y$，其中$1\le x&lt;10$ $x$为实数，$y$是整数。输入时表示为$xey$。保证输入的实数有$19$位有效数字。输出时用科学计数法，必须包括$19$位正确数字。 题解 读入字符串，把它们换成正常形态放入数组。 小数点对齐。 计算。 换成科学计数法输出。 Tip: 口胡得很简单，写起来可能有点麻烦，要仔细。 程序123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273// #pragma GCC optimize(2)// #pragma G++ optimize(2)// #pragma comment(linker,"/STACK:102400000,102400000")// #include &lt;bits/stdc++.h&gt;#include &lt;map&gt;#include &lt;set&gt;#include &lt;list&gt;#include &lt;array&gt;#include &lt;cfenv&gt;#include &lt;cmath&gt;#include &lt;ctime&gt;#include &lt;deque&gt;#include &lt;mutex&gt;#include &lt;queue&gt;#include &lt;ratio&gt;#include &lt;regex&gt;#include &lt;stack&gt;#include &lt;tuple&gt;#include &lt;atomic&gt;#include &lt;bitset&gt;#include &lt;cctype&gt;#include &lt;cerrno&gt;#include &lt;cfloat&gt;#include &lt;chrono&gt;#include &lt;cstdio&gt;#include &lt;cwchar&gt;#include &lt;future&gt;#include &lt;limits&gt;#include &lt;locale&gt;#include &lt;memory&gt;#include &lt;random&gt;#include &lt;string&gt;#include &lt;thread&gt;#include &lt;vector&gt;#include &lt;cassert&gt;#include &lt;climits&gt;#include &lt;clocale&gt;#include &lt;complex&gt;#include &lt;csetjmp&gt;#include &lt;csignal&gt;#include &lt;cstdarg&gt;#include &lt;cstddef&gt;#include &lt;cstdint&gt;#include &lt;cstdlib&gt;#include &lt;cstring&gt;#include &lt;ctgmath&gt;#include &lt;cwctype&gt;#include &lt;fstream&gt;#include &lt;iomanip&gt;#include &lt;numeric&gt;#include &lt;sstream&gt;#include &lt;ccomplex&gt;#include &lt;cstdbool&gt;#include &lt;iostream&gt;#include &lt;typeinfo&gt;#include &lt;valarray&gt;#include &lt;algorithm&gt;#include &lt;cinttypes&gt;#include &lt;cstdalign&gt;#include &lt;stdexcept&gt;#include &lt;typeindex&gt;#include &lt;functional&gt;#include &lt;forward_list&gt;#include &lt;system_error&gt;#include &lt;unordered_map&gt;#include &lt;unordered_set&gt;#include &lt;scoped_allocator&gt;#include &lt;condition_variable&gt;// #include &lt;conio.h&gt;// #include &lt;windows.h&gt;using namespace std;typedef long long LL;typedef unsigned int ui;typedef unsigned long long ull;typedef float fl;typedef double ld;typedef long double LD;typedef pair&lt;int,int&gt; pii;#if (WIN32) || (WIN64) || (__WIN32) || (__WIN64) || (_WIN32) || (_WIN64) || (WINDOWS)#define lld "%I64d"#define llu "%I64u"#else#define lld "%lld"#define llu "%llu"#endif#define ui(n) ((unsigned int)(n))#define LL(n) ((long long)(n))#define ull(n) ((unsigned long long)(n))#define fl(n) ((float)(n))#define ld(n) ((double)(n))#define LD(n) ((long double)(n))#define char(n) ((char)(n))#define Bool(n) ((bool)(n))#define fixpoint(n) fixed&lt;&lt;setprecision(n)const int INF=1061109567;const int NINF=-1044266559;const LL LINF=4557430888798830399;const ld eps=1e-15;#define MOD (1000000007)#define PI (3.1415926535897932384626433832795028841971)/*#define MB_LEN_MAX 5#define SHRT_MIN (-32768)#define SHRT_MAX 32767#define USHRT_MAX 0xffffU#define INT_MIN (-2147483647 - 1)#define INT_MAX 2147483647#define UINT_MAX 0xffffffffU#define LONG_MIN (-2147483647L - 1)#define LONG_MAX 2147483647L#define ULONG_MAX 0xffffffffUL#define LLONG_MAX 9223372036854775807ll#define LLONG_MIN (-9223372036854775807ll - 1)#define ULLONG_MAX 0xffffffffffffffffull*/#define MP make_pair#define MT make_tuple#define All(a) (a).begin(),(a).end()#define pall(a) (a).rbegin(),(a).rend()#define log2(x) log(x)/log(2)#define Log(x,y) log(x)/log(y)#define SZ(a) ((int)(a).size())#define rep(i,n) for(int i=0;i&lt;((int)(n));i++)#define rep1(i,n) for(int i=1;i&lt;=((int)(n));i++)#define repa(i,a,n) for(int i=((int)(a));i&lt;((int)(n));i++)#define repa1(i,a,n) for(int i=((int)(a));i&lt;=((int)(n));i++)#define repd(i,n) for(int i=((int)(n))-1;i&gt;=0;i--)#define repd1(i,n) for(int i=((int)(n));i&gt;=1;i--)#define repda(i,n,a) for(int i=((int)(n));i&gt;((int)(a));i--)#define repda1(i,n,a) for(int i=((int)(n));i&gt;=((int)(a));i--)#define FOR(i,a,n,step) for(int i=((int)(a));i&lt;((int)(n));i+=((int)(step)))#define repv(itr,v) for(__typeof((v).begin()) itr=(v).begin();itr!=(v).end();itr++)#define repV(i,v) for(auto i:v)#define repE(i,v) for(auto &amp;i:v)#define MS(x,y) memset(x,y,sizeof(x))#define MC(x) MS(x,0)#define MINF(x) MS(x,63)#define MCP(x,y) memcpy(x,y,sizeof(y))#define sqr(x) ((x)*(x))#define UN(v) sort(All(v)),v.erase(unique(All(v)),v.end())#define filein(x) freopen(x,"r",stdin)#define fileout(x) freopen(x,"w",stdout)#define fileio(x)\ freopen(x".in","r",stdin);\ freopen(x".out","w",stdout)#define filein2(filename,name) ifstream name(filename,ios::in)#define fileout2(filename,name) ofstream name(filename,ios::out)#define file(filename,name) fstream name(filename,ios::in|ios::out)#define Pause system("pause")#define Cls system("cls")#define fs first#define sc second#define PC(x) putchar(x)#define GC(x) x=getchar()#define Endl PC('\n')#define SF scanf#define PF printfinline int Read()&#123; int X=0,w=0;char ch=0;while(!isdigit(ch))&#123;w|=ch=='-';ch=getchar();&#125;while(isdigit(ch))X=(X&lt;&lt;3)+(X&lt;&lt;1)+(ch^48),ch=getchar(); return w?-X:X;&#125;inline void Write(int x)&#123;if(x&lt;0)putchar('-'),x=-x;if(x&gt;9)Write(x/10);putchar(x%10+'0');&#125;inline LL powmod(LL a,LL b)&#123;LL RES=1;a%=MOD;assert(b&gt;=0);for(;b;b&gt;&gt;=1)&#123;if(b&amp;1)RES=RES*a%MOD;a=a*a%MOD;&#125;return RES%MOD;&#125;inline LL gcdll(LL a,LL b)&#123;return b?gcdll(b,a%b):a;&#125;const int dx[]=&#123;0,1,0,-1,1,-1,-1,1&#125;;const int dy[]=&#123;1,0,-1,0,-1,-1,1,1&#125;;/************************************************************Begin************************************************************/const int maxn=1010;const int Dot=500;int n,dig[maxn][maxn];inline int Atoi(string x)&#123; int res=0; repV(i,x) if(isdigit(i)) res=(res+i-'0')*10;res/=10; return (x[0]=='-'?-res:res);&#125;inline void func(int k,string x)&#123; int e=x.find("e"); string a=x.substr(0,e),b=x.substr(e+1); if(a.find(".")==string::npos) a+='.'; rep(i,101) a='0'+a; rep(i,101) a+='0'; int dot=a.find(".")+Atoi(b)-(b[0]=='-'?1:0); int hav=0; repd(i,dot+1) &#123; if(a[i]=='.') &#123; hav=1; continue; &#125; dig[k][Dot-(dot-i+1)+hav]=a[i]-'0'; &#125; hav=0; repa(i,dot+1,a.size()) &#123; if(a[i]=='.') &#123; hav=1; continue; &#125; dig[k][Dot+(i-dot)-hav]=a[i]-'0'; &#125;&#125;int main()&#123; cin&gt;&gt;n; rep(i,n) &#123; string x;cin&gt;&gt;x; func(i,x); &#125; rep(i,n) rep(j,1000) dig[n][j]+=dig[i][j]; repd(j,1000) &#123; while(dig[n][j]&gt;=10) &#123; int hav=0; if(j-1==Dot) hav=1; dig[n][j-1-hav]+=dig[n][j]/10; dig[n][j]%=10; &#125; &#125; int w=INF,e=0; rep(i,Dot) if(dig[n][i]) &#123; w=i; e=Dot-w-1; break; &#125; if(w==INF) &#123; repa(i,Dot+1,1000) if(dig[n][i]) &#123; w=i; e=i-Dot; break; &#125; e=-e; &#125; cout&lt;&lt;dig[n][w]&lt;&lt;'.'; repa(i,w+1,w+20) if(i!=Dot) cout&lt;&lt;dig[n][i]; cout&lt;&lt;'e'&lt;&lt;e; return 0;&#125;/*************************************************************End**************************************************************/]]></content>
      <categories>
        <category>算法</category>
        <category>Ural</category>
      </categories>
      <tags>
        <tag>模拟</tag>
        <tag>数论</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Ural 1238 Folding 题解]]></title>
    <url>%2F2019%2F08%2F18%2FUral-1238-Folding-%E9%A2%98%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[Ural 1238 Folding 题解题意定义折叠、展开为： 单个大写英文字母是一个折叠的串，把它展开后是它本身。 如果$S$和$Q$是折叠的串，则$SQ$也是折叠的串。如果$S$展开后为$S’$，$Q$展开后为$Q’$，则$SQ$展开后为$S’Q’$。 如果$S$是个折叠的串，则$X(S)$也是折叠的串，其中$X$是一个十进制大于$1$的整数，如果$S$展开为$S’$，则$X(S)$展开后为$S’$重复$X$次。 给定一个字符串(长度小于等于$100$)，求把它折叠后有最小长度的那个字符串。 题解考虑记忆化搜索(DP也可以)。 定义$f(s)$为$s$字符串折叠后有最小长度的那个字符串。 边界为当$|s|\le4$($|s|$为$s$的长度)时，$f(s)=s$。 给定$s$，求出$f(s)$有以下几种方式 $f(s)=s$。 设$1&lt;x\le|s|,|s|\%x=0$且有字符串$q$，$q$重复$x$次为$s$，$f(s)=x”(“+f(q)+”)”$。 设$0&lt;i&lt;|s|$，$f(s)=f(s[0..i-1])+f(s[i..|s|-1])$。 取长度最小的值即可，不要忘了记忆化。 程序123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230// #pragma GCC optimize(2)// #pragma G++ optimize(2)// #pragma comment(linker,"/STACK:102400000,102400000")// #include &lt;bits/stdc++.h&gt;#include &lt;map&gt;#include &lt;set&gt;#include &lt;list&gt;#include &lt;array&gt;#include &lt;cfenv&gt;#include &lt;cmath&gt;#include &lt;ctime&gt;#include &lt;deque&gt;#include &lt;mutex&gt;#include &lt;queue&gt;#include &lt;ratio&gt;#include &lt;regex&gt;#include &lt;stack&gt;#include &lt;tuple&gt;#include &lt;atomic&gt;#include &lt;bitset&gt;#include &lt;cctype&gt;#include &lt;cerrno&gt;#include &lt;cfloat&gt;#include &lt;chrono&gt;#include &lt;cstdio&gt;#include &lt;cwchar&gt;#include &lt;future&gt;#include &lt;limits&gt;#include &lt;locale&gt;#include &lt;memory&gt;#include &lt;random&gt;#include &lt;string&gt;#include &lt;thread&gt;#include &lt;vector&gt;#include &lt;cassert&gt;#include &lt;climits&gt;#include &lt;clocale&gt;#include &lt;complex&gt;#include &lt;csetjmp&gt;#include &lt;csignal&gt;#include &lt;cstdarg&gt;#include &lt;cstddef&gt;#include &lt;cstdint&gt;#include &lt;cstdlib&gt;#include &lt;cstring&gt;#include &lt;ctgmath&gt;#include &lt;cwctype&gt;#include &lt;fstream&gt;#include &lt;iomanip&gt;#include &lt;numeric&gt;#include &lt;sstream&gt;#include &lt;ccomplex&gt;#include &lt;cstdbool&gt;#include &lt;iostream&gt;#include &lt;typeinfo&gt;#include &lt;valarray&gt;#include &lt;algorithm&gt;#include &lt;cinttypes&gt;#include &lt;cstdalign&gt;#include &lt;stdexcept&gt;#include &lt;typeindex&gt;#include &lt;functional&gt;#include &lt;forward_list&gt;#include &lt;system_error&gt;#include &lt;unordered_map&gt;#include &lt;unordered_set&gt;#include &lt;scoped_allocator&gt;#include &lt;condition_variable&gt;// #include &lt;conio.h&gt;// #include &lt;windows.h&gt;using namespace std;typedef long long LL;typedef unsigned int ui;typedef unsigned long long ull;typedef float fl;typedef double ld;typedef long double LD;typedef pair&lt;int,int&gt; pii;#if (WIN32) || (WIN64) || (__WIN32) || (__WIN64) || (_WIN32) || (_WIN64) || (WINDOWS)#define lld "%I64d"#define llu "%I64u"#else#define lld "%lld"#define llu "%llu"#endif#define ui(n) ((unsigned int)(n))#define LL(n) ((long long)(n))#define ull(n) ((unsigned long long)(n))#define fl(n) ((float)(n))#define ld(n) ((double)(n))#define LD(n) ((long double)(n))#define char(n) ((char)(n))#define Bool(n) ((bool)(n))#define fixpoint(n) fixed&lt;&lt;setprecision(n)const int INF=1061109567;const int NINF=-1044266559;const LL LINF=4557430888798830399;const ld eps=1e-15;#define MOD (1000000007)#define PI (3.1415926535897932384626433832795028841971)/*#define MB_LEN_MAX 5#define SHRT_MIN (-32768)#define SHRT_MAX 32767#define USHRT_MAX 0xffffU#define INT_MIN (-2147483647 - 1)#define INT_MAX 2147483647#define UINT_MAX 0xffffffffU#define LONG_MIN (-2147483647L - 1)#define LONG_MAX 2147483647L#define ULONG_MAX 0xffffffffUL#define LLONG_MAX 9223372036854775807ll#define LLONG_MIN (-9223372036854775807ll - 1)#define ULLONG_MAX 0xffffffffffffffffull*/#define MP make_pair#define MT make_tuple#define All(a) (a).begin(),(a).end()#define pall(a) (a).rbegin(),(a).rend()#define log2(x) log(x)/log(2)#define Log(x,y) log(x)/log(y)#define SZ(a) ((int)(a).size())#define rep(i,n) for(int i=0;i&lt;((int)(n));i++)#define rep1(i,n) for(int i=1;i&lt;=((int)(n));i++)#define repa(i,a,n) for(int i=((int)(a));i&lt;((int)(n));i++)#define repa1(i,a,n) for(int i=((int)(a));i&lt;=((int)(n));i++)#define repd(i,n) for(int i=((int)(n))-1;i&gt;=0;i--)#define repd1(i,n) for(int i=((int)(n));i&gt;=1;i--)#define repda(i,n,a) for(int i=((int)(n));i&gt;((int)(a));i--)#define repda1(i,n,a) for(int i=((int)(n));i&gt;=((int)(a));i--)#define FOR(i,a,n,step) for(int i=((int)(a));i&lt;((int)(n));i+=((int)(step)))#define repv(itr,v) for(__typeof((v).begin()) itr=(v).begin();itr!=(v).end();itr++)#define repV(i,v) for(auto i:v)#define repE(i,v) for(auto &amp;i:v)#define MS(x,y) memset(x,y,sizeof(x))#define MC(x) MS(x,0)#define MINF(x) MS(x,63)#define MCP(x,y) memcpy(x,y,sizeof(y))#define sqr(x) ((x)*(x))#define UN(v) sort(All(v)),v.erase(unique(All(v)),v.end())#define filein(x) freopen(x,"r",stdin)#define fileout(x) freopen(x,"w",stdout)#define fileio(x)\ freopen(x".in","r",stdin);\ freopen(x".out","w",stdout)#define filein2(filename,name) ifstream name(filename,ios::in)#define fileout2(filename,name) ofstream name(filename,ios::out)#define file(filename,name) fstream name(filename,ios::in|ios::out)#define Pause system("pause")#define Cls system("cls")#define fs first#define sc second#define PC(x) putchar(x)#define GC(x) x=getchar()#define Endl PC('\n')#define SF scanf#define PF printfinline int Read()&#123; int X=0,w=0;char ch=0;while(!isdigit(ch))&#123;w|=ch=='-';ch=getchar();&#125;while(isdigit(ch))X=(X&lt;&lt;3)+(X&lt;&lt;1)+(ch^48),ch=getchar(); return w?-X:X;&#125;inline void Write(int x)&#123;if(x&lt;0)putchar('-'),x=-x;if(x&gt;9)Write(x/10);putchar(x%10+'0');&#125;inline LL powmod(LL a,LL b)&#123;LL RES=1;a%=MOD;assert(b&gt;=0);for(;b;b&gt;&gt;=1)&#123;if(b&amp;1)RES=RES*a%MOD;a=a*a%MOD;&#125;return RES%MOD;&#125;inline LL gcdll(LL a,LL b)&#123;return b?gcdll(b,a%b):a;&#125;const int dx[]=&#123;0,1,0,-1,1,-1,-1,1&#125;;const int dy[]=&#123;1,0,-1,0,-1,-1,1,1&#125;;/************************************************************Begin************************************************************/const int maxn=110;inline string Itoa(int x)&#123; string res=""; while(x) &#123; res+=char(x%10+'0'); x/=10; &#125; reverse(All(res)); return res;&#125;map&lt;string,string&gt; vis;inline string sol(string s)&#123; if(vis.count(s)) return vis[s]; if(s.size()&lt;=4) return vis[s]=s; string ans=s; rep1(i,s.size()) if(i&gt;1&amp;&amp;s.size()%i==0) &#123; int len=s.size()/i; string x=s.substr(0,len); bool f=1; for(int j=0;j&lt;s.size();j+=len) if(s.substr(j,len)!=x) f=0; if(f) &#123; string res=Itoa(i)+'('+sol(x)+')'; if(ans.size()&gt;res.size()) ans=res; &#125; &#125; rep1(i,s.size()-1) &#123; string res=sol(s.substr(0,i))+sol(s.substr(i)); if(ans.size()&gt;res.size()) ans=res; &#125; return vis[s]=ans;&#125;int main()&#123; string s; cin&gt;&gt;s; cout&lt;&lt;sol(s); return 0;&#125;/*************************************************************End**************************************************************/]]></content>
      <categories>
        <category>算法</category>
        <category>Ural</category>
      </categories>
      <tags>
        <tag>DP</tag>
        <tag>记忆化搜索</tag>
        <tag>字符串</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Ural 1201 Which Day Is It 题解]]></title>
    <url>%2F2019%2F08%2F18%2FUral-1201-Which-Day-Is-It-%E9%A2%98%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[Ural 1201 Which Day Is It? 题解题意打印一个月历。 输入输入日$(1\sim31)$、月$(1\sim12)$、年$(1600\sim2400)$。 输出123456789输入: 16 3 2002输出:mon........4...11...18...25tue........5...12...19...26wed........6...13...20...27thu........7...14...21...28fri...1....8...15...22...29sat...2....9..[16]..23...30sun...3...10...17...24...31 123456789输入: 1 3 2002输出:mon........4...11...18...25tue........5...12...19...26wed........6...13...20...27thu........7...14...21...28fri.[.1]...8...15...22...29sat...2....9...16...23...30sun...3...10...17...24...31 打印$7$行，mon tue…这些都懂吧。在输入的那天打上[]。 Tips: 样例输出中的.其实是 (空格)。 输出的第一列日期前有三个.，第二列即以后一位数前有$4$个，两位数前有$3$个。 例: 123456789输入: 30 1 2012输出:mon........2....9...16...23..[30]tue........3...10...17...24...31wed........4...11...18...25.....thu........5...12...19...26.....fri........6...13...20...27.....sat........7...14...21...28.....sun...1....8...15...22...29..... 如果输入的那一天是个一位数，则打印$[.x]$。 题解 找出这一个月的第一天是星期几。 知道1.1.1(公元元年1月1日)是星期一。 暴力推一下就可以了。 打印月历。 Tip: 口胡得很简单，写起来可能有点麻烦，要仔细。 程序123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270// #pragma GCC optimize(2)// #pragma G++ optimize(2)// #pragma comment(linker,"/STACK:102400000,102400000")// #include &lt;bits/stdc++.h&gt;#include &lt;map&gt;#include &lt;set&gt;#include &lt;list&gt;#include &lt;array&gt;#include &lt;cfenv&gt;#include &lt;cmath&gt;#include &lt;ctime&gt;#include &lt;deque&gt;#include &lt;mutex&gt;#include &lt;queue&gt;#include &lt;ratio&gt;#include &lt;regex&gt;#include &lt;stack&gt;#include &lt;tuple&gt;#include &lt;atomic&gt;#include &lt;bitset&gt;#include &lt;cctype&gt;#include &lt;cerrno&gt;#include &lt;cfloat&gt;#include &lt;chrono&gt;#include &lt;cstdio&gt;#include &lt;cwchar&gt;#include &lt;future&gt;#include &lt;limits&gt;#include &lt;locale&gt;#include &lt;memory&gt;#include &lt;random&gt;#include &lt;string&gt;#include &lt;thread&gt;#include &lt;vector&gt;#include &lt;cassert&gt;#include &lt;climits&gt;#include &lt;clocale&gt;#include &lt;complex&gt;#include &lt;csetjmp&gt;#include &lt;csignal&gt;#include &lt;cstdarg&gt;#include &lt;cstddef&gt;#include &lt;cstdint&gt;#include &lt;cstdlib&gt;#include &lt;cstring&gt;#include &lt;ctgmath&gt;#include &lt;cwctype&gt;#include &lt;fstream&gt;#include &lt;iomanip&gt;#include &lt;numeric&gt;#include &lt;sstream&gt;#include &lt;ccomplex&gt;#include &lt;cstdbool&gt;#include &lt;iostream&gt;#include &lt;typeinfo&gt;#include &lt;valarray&gt;#include &lt;algorithm&gt;#include &lt;cinttypes&gt;#include &lt;cstdalign&gt;#include &lt;stdexcept&gt;#include &lt;typeindex&gt;#include &lt;functional&gt;#include &lt;forward_list&gt;#include &lt;system_error&gt;#include &lt;unordered_map&gt;#include &lt;unordered_set&gt;#include &lt;scoped_allocator&gt;#include &lt;condition_variable&gt;// #include &lt;conio.h&gt;// #include &lt;windows.h&gt;using namespace std;typedef long long LL;typedef unsigned int ui;typedef unsigned long long ull;typedef float fl;typedef double ld;typedef long double LD;typedef pair&lt;int,int&gt; pii;#if (WIN32) || (WIN64) || (__WIN32) || (__WIN64) || (_WIN32) || (_WIN64) || (WINDOWS)#define lld "%I64d"#define llu "%I64u"#else#define lld "%lld"#define llu "%llu"#endif#define ui(n) ((unsigned int)(n))#define LL(n) ((long long)(n))#define ull(n) ((unsigned long long)(n))#define fl(n) ((float)(n))#define ld(n) ((double)(n))#define LD(n) ((long double)(n))#define char(n) ((char)(n))#define Bool(n) ((bool)(n))#define fixpoint(n) fixed&lt;&lt;setprecision(n)const int INF=1061109567;const int NINF=-1044266559;const LL LINF=4557430888798830399;const ld eps=1e-15;#define MOD (1000000007)#define PI (3.1415926535897932384626433832795028841971)/*#define MB_LEN_MAX 5#define SHRT_MIN (-32768)#define SHRT_MAX 32767#define USHRT_MAX 0xffffU#define INT_MIN (-2147483647 - 1)#define INT_MAX 2147483647#define UINT_MAX 0xffffffffU#define LONG_MIN (-2147483647L - 1)#define LONG_MAX 2147483647L#define ULONG_MAX 0xffffffffUL#define LLONG_MAX 9223372036854775807ll#define LLONG_MIN (-9223372036854775807ll - 1)#define ULLONG_MAX 0xffffffffffffffffull*/#define MP make_pair#define MT make_tuple#define All(a) (a).begin(),(a).end()#define pall(a) (a).rbegin(),(a).rend()#define log2(x) log(x)/log(2)#define Log(x,y) log(x)/log(y)#define SZ(a) ((int)(a).size())#define rep(i,n) for(int i=0;i&lt;((int)(n));i++)#define rep1(i,n) for(int i=1;i&lt;=((int)(n));i++)#define repa(i,a,n) for(int i=((int)(a));i&lt;((int)(n));i++)#define repa1(i,a,n) for(int i=((int)(a));i&lt;=((int)(n));i++)#define repd(i,n) for(int i=((int)(n))-1;i&gt;=0;i--)#define repd1(i,n) for(int i=((int)(n));i&gt;=1;i--)#define repda(i,n,a) for(int i=((int)(n));i&gt;((int)(a));i--)#define repda1(i,n,a) for(int i=((int)(n));i&gt;=((int)(a));i--)#define FOR(i,a,n,step) for(int i=((int)(a));i&lt;((int)(n));i+=((int)(step)))#define repv(itr,v) for(__typeof((v).begin()) itr=(v).begin();itr!=(v).end();itr++)#define repV(i,v) for(auto i:v)#define repE(i,v) for(auto &amp;i:v)#define MS(x,y) memset(x,y,sizeof(x))#define MC(x) MS(x,0)#define MINF(x) MS(x,63)#define MCP(x,y) memcpy(x,y,sizeof(y))#define sqr(x) ((x)*(x))#define UN(v) sort(All(v)),v.erase(unique(All(v)),v.end())#define filein(x) freopen(x,"r",stdin)#define fileout(x) freopen(x,"w",stdout)#define fileio(x)\ freopen(x".in","r",stdin);\ freopen(x".out","w",stdout)#define filein2(filename,name) ifstream name(filename,ios::in)#define fileout2(filename,name) ofstream name(filename,ios::out)#define file(filename,name) fstream name(filename,ios::in|ios::out)#define Pause system("pause")#define Cls system("cls")#define fs first#define sc second#define PC(x) putchar(x)#define GC(x) x=getchar()#define Endl PC('\n')#define SF scanf#define PF printfinline int Read()&#123; int X=0,w=0;char ch=0;while(!isdigit(ch))&#123;w|=ch=='-';ch=getchar();&#125;while(isdigit(ch))X=(X&lt;&lt;3)+(X&lt;&lt;1)+(ch^48),ch=getchar(); return w?-X:X;&#125;inline void Write(int x)&#123;if(x&lt;0)putchar('-'),x=-x;if(x&gt;9)Write(x/10);putchar(x%10+'0');&#125;inline LL powmod(LL a,LL b)&#123;LL RES=1;a%=MOD;assert(b&gt;=0);for(;b;b&gt;&gt;=1)&#123;if(b&amp;1)RES=RES*a%MOD;a=a*a%MOD;&#125;return RES%MOD;&#125;inline LL gcdll(LL a,LL b)&#123;return b?gcdll(b,a%b):a;&#125;const int dx[]=&#123;0,1,0,-1,1,-1,-1,1&#125;;const int dy[]=&#123;1,0,-1,0,-1,-1,1,1&#125;;/************************************************************Begin************************************************************/const int maxn=INF;const int days[]=&#123;0,31,0,31,30,31,30,31,31,30,31,30,31&#125;;const string weeks[]=&#123;"","mon","tue","wed","thu","fri","sat","sun"&#125;;// 1.1.1 =&gt; moninline int getday(int year,int month)&#123; if(month==2) &#123; if(year%400==0) return 29; if(year%100==0) return 28; return year%4==0?29:28; &#125; else return days[month];&#125;inline bool cmp(int y1,int m1,int y2,int m2)&#123; if(y1==y2) return m1&lt;m2; else return y1&lt;y2;&#125;inline int getweek(int year,int month)&#123; int y=1,m=1,w=0; while(y!=year||m!=month) &#123; if(cmp(y,m,year,month)) &#123; w=(w+getday(y,m)%7)%7; m++; if(m==13) &#123; y++; m=1; &#125; &#125; &#125; return w+1;&#125;inline void print(int year,int month,int day)&#123; vector&lt;int&gt; w[8]; int lst=getweek(year,month); w[lst].push_back(1); rep1(i,lst-1) w[i].push_back(0); int pos[15]; pos[0]=6; rep1(i,5) pos[i]=pos[i-1]+5; repa1(i,2,getday(year,month)) &#123; lst++; if(lst==8) lst=1; w[lst].push_back(i); &#125; string str[8]; rep1(i,7) &#123; str[i]=weeks[i]; rep(j,100) str[i]+=" "; rep(j,w[i].size()) &#123; int x=w[i][j]; if(x) str[i][pos[j]]=(x%10+'0'); if(x/10) str[i][pos[j]-1]=(x/10+'0'); if(x==day) &#123; str[i][pos[j]-2]='['; str[i][pos[j]+1]=']'; &#125; &#125; &#125; rep1(i,7) cout&lt;&lt;str[i]&lt;&lt;endl;&#125;int main()&#123; int year,month,day; cin&gt;&gt;day&gt;&gt;month&gt;&gt;year; print(year,month,day); return 0;&#125;/*************************************************************End**************************************************************/]]></content>
      <categories>
        <category>算法</category>
        <category>Ural</category>
      </categories>
      <tags>
        <tag>暴力</tag>
        <tag>模拟</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Codeforces 718A Efim and Strange Grade 程序分析]]></title>
    <url>%2F2019%2F08%2F18%2FCodeforces-718A-Efim-and-Strange-Grade-%E7%A8%8B%E5%BA%8F%E5%88%86%E6%9E%90%2F</url>
    <content type="text"><![CDATA[Codeforces 718A Efim and Strange Grade 程序分析 jerry的程序123456789101112131415161718192021222324252627282930313233343536373839404142434445using namespace std;typedef long long ll; string buf;int i; void up(int at)&#123; at--; if (at &lt; 0) &#123; buf = '1' + buf; i++; return; &#125; if (buf[at] == '.') at--; buf[at]++; if (buf[at] == '9'+1) &#123; buf[at] = '0'; up(at); &#125;&#125; int main()&#123; cin.sync_with_stdio(false); cin.tie(0); int n, k; cin &gt;&gt; n &gt;&gt; k &gt;&gt; buf; while (buf[i] != '.') i++; i++; while (i &lt; buf.length() &amp;&amp; buf[i] &lt;= '4') i++; if (i == buf.length()) &#123; cout &lt;&lt; buf &lt;&lt; endl; return 0; &#125; for (;buf[i] != '.' &amp;&amp; k;i--) if (buf[i] &gt;= '5') &#123; buf.resize(i); up(i); k--; &#125; if (buf.back() == '.') buf.pop_back(); cout &lt;&lt; buf &lt;&lt; endl; return 0;&#125; 首先，先找到小数点第一个后大于等于$5$的数位，如果没有的话直接输出原数。 从那个数位起，从后往前循环到小数点处，如果还当前数位大于等于$5$且有进位的机会，则先把这个数的结尾改成这个位置，因为之后的所有数都会被清零，然后调用up函数进位，如果有$9$的数继续递归，否则退出，如果整数部分首位还要进位，需要在最前面加上$1$。 最后注意最后一个字符如果是小数点要删去。 总结：用一个函数来执行进位，如果还有进位机会只需继续调用函数就行了，这样处理起来十分方便。 izrak的程序1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include &lt;bits/stdc++.h&gt; #define FO(i,a,b) for (int i = (a); i &lt; (b); i++)#define sz(v) int(v.size()) using namespace std; char s[200005]; int main() &#123; int l, t; scanf("%d %d", &amp;l, &amp;t); scanf("%s", s+1); s[0] = '0'; for (int i = 0; i &lt;= l; i++) &#123; if (s[i] == '.') &#123; for (int j = i+1; j &lt;= l; j++) if (s[j] &gt;= '5') &#123; s[j] = 0; bool roundup = true; t--; for (int k = j-1; k &gt; i; k--) &#123; // s[k]++ if (roundup) &#123; s[k]++; if (s[k] &gt;= '5' &amp;&amp; t) &#123; s[k] = 0; t--; roundup = true; &#125; else roundup = false; &#125; &#125; if (roundup) &#123; s[i] = 0; for (int k = i-1; k &gt;= 0; k--) &#123; s[k]++; if (s[k] &lt;= '9') break; else s[k] = '0'; &#125; &#125; break; &#125; &#125; &#125; if (s[0] != '0') &#123; printf("%s\n", s); &#125; else &#123; printf("%s\n", s+1); &#125;&#125; 这个程序读入时在数字前加上一个前导零，以便处理整数部分首位进位情况。 第一层循环找到小数点的位置，第二层循环找到小数点后第一位大于等于$5$的数字，第三层循环(最多进位到小数点)，roundup记录是否继续进位，如果进位后还有大于等于$5$的数字且还有进位机会，则继续进位。如果第三层循环结束后，仍需继续进位，则在整数部分进位。进位时每进位一次，就把这一位设置为\0，这样输出时只会输出到第一个\0的位置便结束。 注意最后需判断如果开始时加上的前导零仍是零，就不能输出。 总结：用bool变量roundup维护需不需要继续进位，进了位的位置就标为\0，如果在小数点前面进位直接循环处理即可，这样处理起来不容易错。]]></content>
      <categories>
        <category>算法</category>
        <category>Codeforces</category>
      </categories>
      <tags>
        <tag>数学</tag>
        <tag>模拟</tag>
        <tag>DP</tag>
        <tag>贪心</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2019 Multi-University Training Contest 2 1010 Just Skip The Problem 自闭记]]></title>
    <url>%2F2019%2F08%2F18%2F2019-Multi-University-Training-Contest-2-1010-Just-Skip-The-Problem-%E8%87%AA%E9%97%AD%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[2019 Multi-University Training Contest 2: 1010 Just Skip The Problem 自闭记题意多测。每次给你一个数$n$，你可以同时问无数次，每次问的是一个数$y_i$，你会得到的回答是$x\&amp;y_i$是否为$y_i$，问你问的最少的次数的种数$\%1e6+3$，可以调换顺序。 10min 得出数学方法求$n!\%1e6+3$。 50min 自闭 5min 写出裸暴力，优化10min，交一发TLE 30min 网上找各种快速阶乘题解、优化，发现板子全是错的：$3!$打出$60$、不会清空$\dots\dots$，写到自闭 5min 发现一旦$n\ge1e6+3$时取了模后就为$0$了$\dots\dots$，自闭 2min AC直接码，2min AC$\dots\dots$ 总结：以后多多总结性质。]]></content>
      <categories>
        <category>算法</category>
        <category>hdu</category>
        <category>多校</category>
      </categories>
      <tags>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Ural 1029 Ministry 题解]]></title>
    <url>%2F2019%2F08%2F12%2FUral-1029-Ministry-%E9%A2%98%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[Ural 1029 Ministry 题解题意给定一个$n\times m(1\le n \le10,1\le m \le500)$的矩阵，矩阵中的每个值都是一个小于等于$10^9$的正整数。 现在从第$1$行的任意位置开始，在第$n$行的任意位置结束。每次有$3$种移动选择(不能移动到矩阵外)。 设当前位置为$(i,j)$ 移动到$(i+1,j)$ 移动到$(i,j-1)$ 移动到$(i,j+1)$ 每条路径的价值是路径走过所有的位置上的值的和(小于等于$10^9$)。 问在所有路径中，路径价值最小的，输出这条路径所有位置的列号。 题解考虑记忆化搜索(DP也可以)。 对于每个点，记忆化搜索可以移动到它的$3$种位置，取最小值即可，顺便记录一下路径。 也可以无脑最短路。 Tips: WA$1$的同学不要着急，Test$1$并不是样例，仔细找找有没有错误。 设$(i,j)$的答案为$dp(i,j)$，矩阵中的值为$a(i,j)$，状态转移方程如果是$dp(i,j)=\min\{dp(i-1,j),dp(i,j-1),dp(i,j+1) \}+a(i,j)$可能会WA$1$，改为$dp(i,j)=\min\{dp(i-1,j)+a(i,j),dp(i,j-1)+a(i,j),dp(i,j+1)+a(i,j) \}$即可AC。目前并不知道原因(我太弱了)，如果有知道的可以在评论区留言，谢谢！ 程序AC程序123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228// #pragma GCC optimize(2)// #pragma G++ optimize(2)// #pragma comment(linker,"/STACK:102400000,102400000")// #include &lt;bits/stdc++.h&gt;#include &lt;map&gt;#include &lt;set&gt;#include &lt;list&gt;#include &lt;array&gt;#include &lt;cfenv&gt;#include &lt;cmath&gt;#include &lt;ctime&gt;#include &lt;deque&gt;#include &lt;mutex&gt;#include &lt;queue&gt;#include &lt;ratio&gt;#include &lt;regex&gt;#include &lt;stack&gt;#include &lt;tuple&gt;#include &lt;atomic&gt;#include &lt;bitset&gt;#include &lt;cctype&gt;#include &lt;cerrno&gt;#include &lt;cfloat&gt;#include &lt;chrono&gt;#include &lt;cstdio&gt;#include &lt;cwchar&gt;#include &lt;future&gt;#include &lt;limits&gt;#include &lt;locale&gt;#include &lt;memory&gt;#include &lt;random&gt;#include &lt;string&gt;#include &lt;thread&gt;#include &lt;vector&gt;#include &lt;cassert&gt;#include &lt;climits&gt;#include &lt;clocale&gt;#include &lt;complex&gt;#include &lt;csetjmp&gt;#include &lt;csignal&gt;#include &lt;cstdarg&gt;#include &lt;cstddef&gt;#include &lt;cstdint&gt;#include &lt;cstdlib&gt;#include &lt;cstring&gt;#include &lt;ctgmath&gt;#include &lt;cwctype&gt;#include &lt;fstream&gt;#include &lt;iomanip&gt;#include &lt;numeric&gt;#include &lt;sstream&gt;#include &lt;ccomplex&gt;#include &lt;cstdbool&gt;#include &lt;iostream&gt;#include &lt;typeinfo&gt;#include &lt;valarray&gt;#include &lt;algorithm&gt;#include &lt;cinttypes&gt;#include &lt;cstdalign&gt;#include &lt;stdexcept&gt;#include &lt;typeindex&gt;#include &lt;functional&gt;#include &lt;forward_list&gt;#include &lt;system_error&gt;#include &lt;unordered_map&gt;#include &lt;unordered_set&gt;#include &lt;scoped_allocator&gt;#include &lt;condition_variable&gt;// #include &lt;conio.h&gt;// #include &lt;windows.h&gt;using namespace std;typedef long long LL;typedef unsigned int ui;typedef unsigned long long ull;typedef float fl;typedef double ld;typedef long double LD;typedef pair&lt;int,int&gt; pii;#if (WIN32) || (WIN64) || (__WIN32) || (__WIN64) || (_WIN32) || (_WIN64) || (WINDOWS)#define lld "%I64d"#define llu "%I64u"#else#define lld "%lld"#define llu "%llu"#endif#define ui(n) ((unsigned int)(n))#define LL(n) ((long long)(n))#define ull(n) ((unsigned long long)(n))#define fl(n) ((float)(n))#define ld(n) ((double)(n))#define LD(n) ((long double)(n))#define char(n) ((char)(n))#define Bool(n) ((bool)(n))#define fixpoint(n) fixed&lt;&lt;setprecision(n)const int INF=1061109567;const int NINF=-1044266559;const LL LINF=4557430888798830399;const ld eps=1e-15;#define MOD (1000000007)#define PI (3.1415926535897932384626433832795028841971)/*#define MB_LEN_MAX 5#define SHRT_MIN (-32768)#define SHRT_MAX 32767#define USHRT_MAX 0xffffU#define INT_MIN (-2147483647 - 1)#define INT_MAX 2147483647#define UINT_MAX 0xffffffffU#define LONG_MIN (-2147483647L - 1)#define LONG_MAX 2147483647L#define ULONG_MAX 0xffffffffUL#define LLONG_MAX 9223372036854775807ll#define LLONG_MIN (-9223372036854775807ll - 1)#define ULLONG_MAX 0xffffffffffffffffull*/#define MP make_pair#define MT make_tuple#define All(a) (a).begin(),(a).end()#define pall(a) (a).rbegin(),(a).rend()#define log2(x) log(x)/log(2)#define Log(x,y) log(x)/log(y)#define SZ(a) ((int)(a).size())#define rep(i,n) for(int i=0;i&lt;((int)(n));i++)#define rep1(i,n) for(int i=1;i&lt;=((int)(n));i++)#define repa(i,a,n) for(int i=((int)(a));i&lt;((int)(n));i++)#define repa1(i,a,n) for(int i=((int)(a));i&lt;=((int)(n));i++)#define repd(i,n) for(int i=((int)(n))-1;i&gt;=0;i--)#define repd1(i,n) for(int i=((int)(n));i&gt;=1;i--)#define repda(i,n,a) for(int i=((int)(n));i&gt;((int)(a));i--)#define repda1(i,n,a) for(int i=((int)(n));i&gt;=((int)(a));i--)#define FOR(i,a,n,step) for(int i=((int)(a));i&lt;((int)(n));i+=((int)(step)))#define repv(itr,v) for(__typeof((v).begin()) itr=(v).begin();itr!=(v).end();itr++)#define repV(i,v) for(auto i:v)#define repE(i,v) for(auto &amp;i:v)#define MS(x,y) memset(x,y,sizeof(x))#define MC(x) MS(x,0)#define MINF(x) MS(x,63)#define MCP(x,y) memcpy(x,y,sizeof(y))#define sqr(x) ((x)*(x))#define UN(v) sort(All(v)),v.erase(unique(All(v)),v.end())#define filein(x) freopen(x,"r",stdin)#define fileout(x) freopen(x,"w",stdout)#define fileio(x)\ freopen(x".in","r",stdin);\ freopen(x".out","w",stdout)#define filein2(filename,name) ifstream name(filename,ios::in)#define fileout2(filename,name) ofstream name(filename,ios::out)#define file(filename,name) fstream name(filename,ios::in|ios::out)#define Pause system("pause")#define Cls system("cls")#define fs first#define sc second#define PC(x) putchar(x)#define GC(x) x=getchar()#define Endl PC('\n')#define SF scanf#define PF printfinline int Read()&#123; int X=0,w=0;char ch=0;while(!isdigit(ch))&#123;w|=ch=='-';ch=getchar();&#125;while(isdigit(ch))X=(X&lt;&lt;3)+(X&lt;&lt;1)+(ch^48),ch=getchar(); return w?-X:X;&#125;inline void Write(int x)&#123;if(x&lt;0)putchar('-'),x=-x;if(x&gt;9)Write(x/10);putchar(x%10+'0');&#125;inline LL powmod(LL a,LL b)&#123;LL RES=1;a%=MOD;assert(b&gt;=0);for(;b;b&gt;&gt;=1)&#123;if(b&amp;1)RES=RES*a%MOD;a=a*a%MOD;&#125;return RES%MOD;&#125;inline LL gcdll(LL a,LL b)&#123;return b?gcdll(b,a%b):a;&#125;const int dx[]=&#123;0,1,0,-1,1,-1,-1,1&#125;;const int dy[]=&#123;1,0,-1,0,-1,-1,1,1&#125;;/************************************************************Begin************************************************************/const int maxn=110,maxm=510;int n,m,a[maxn][maxm],dp[maxn][maxm];pair&lt;int,int&gt; pre[maxn][maxm];inline int sol(int x,int y)&#123; if(y&lt;1||y&gt;m) return dp[x][y]=INF; if(dp[x][y]!=-1) return dp[x][y]; else dp[x][y]=0; int res=sol(x-1,y)+a[x][y]; dp[x][y]=res; pre[x][y]=&#123;x-1,y&#125;; res=sol(x,y-1)+a[x][y]; if(res&lt;dp[x][y]) &#123; dp[x][y]=res; pre[x][y]=&#123;x,y-1&#125;; &#125; res=sol(x,y+1)+a[x][y]; if(res&lt;dp[x][y]) &#123; dp[x][y]=res; pre[x][y]=&#123;x,y+1&#125;; &#125; return dp[x][y];&#125;inline void print(int x,int y)&#123; if(x&gt;1) print(pre[x][y].fs,pre[x][y].sc); cout&lt;&lt;y&lt;&lt;' ';&#125;int main()&#123; cin&gt;&gt;n&gt;&gt;m; rep1(i,n) rep1(j,m) cin&gt;&gt;a[i][j]; MS(dp,-1); rep1(j,m) dp[1][j]=a[1][j]; int ans=1; rep1(j,m) if(sol(n,j)&lt;sol(n,ans)) ans=j; print(n,ans); return 0;&#125;/*************************************************************End**************************************************************/ WA$1$程序123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229// #pragma GCC optimize(2)// #pragma G++ optimize(2)// #pragma comment(linker,"/STACK:102400000,102400000")// #include &lt;bits/stdc++.h&gt;#include &lt;map&gt;#include &lt;set&gt;#include &lt;list&gt;#include &lt;array&gt;#include &lt;cfenv&gt;#include &lt;cmath&gt;#include &lt;ctime&gt;#include &lt;deque&gt;#include &lt;mutex&gt;#include &lt;queue&gt;#include &lt;ratio&gt;#include &lt;regex&gt;#include &lt;stack&gt;#include &lt;tuple&gt;#include &lt;atomic&gt;#include &lt;bitset&gt;#include &lt;cctype&gt;#include &lt;cerrno&gt;#include &lt;cfloat&gt;#include &lt;chrono&gt;#include &lt;cstdio&gt;#include &lt;cwchar&gt;#include &lt;future&gt;#include &lt;limits&gt;#include &lt;locale&gt;#include &lt;memory&gt;#include &lt;random&gt;#include &lt;string&gt;#include &lt;thread&gt;#include &lt;vector&gt;#include &lt;cassert&gt;#include &lt;climits&gt;#include &lt;clocale&gt;#include &lt;complex&gt;#include &lt;csetjmp&gt;#include &lt;csignal&gt;#include &lt;cstdarg&gt;#include &lt;cstddef&gt;#include &lt;cstdint&gt;#include &lt;cstdlib&gt;#include &lt;cstring&gt;#include &lt;ctgmath&gt;#include &lt;cwctype&gt;#include &lt;fstream&gt;#include &lt;iomanip&gt;#include &lt;numeric&gt;#include &lt;sstream&gt;#include &lt;ccomplex&gt;#include &lt;cstdbool&gt;#include &lt;iostream&gt;#include &lt;typeinfo&gt;#include &lt;valarray&gt;#include &lt;algorithm&gt;#include &lt;cinttypes&gt;#include &lt;cstdalign&gt;#include &lt;stdexcept&gt;#include &lt;typeindex&gt;#include &lt;functional&gt;#include &lt;forward_list&gt;#include &lt;system_error&gt;#include &lt;unordered_map&gt;#include &lt;unordered_set&gt;#include &lt;scoped_allocator&gt;#include &lt;condition_variable&gt;// #include &lt;conio.h&gt;// #include &lt;windows.h&gt;using namespace std;typedef long long LL;typedef unsigned int ui;typedef unsigned long long ull;typedef float fl;typedef double ld;typedef long double LD;typedef pair&lt;int,int&gt; pii;#if (WIN32) || (WIN64) || (__WIN32) || (__WIN64) || (_WIN32) || (_WIN64) || (WINDOWS)#define lld "%I64d"#define llu "%I64u"#else#define lld "%lld"#define llu "%llu"#endif#define ui(n) ((unsigned int)(n))#define LL(n) ((long long)(n))#define ull(n) ((unsigned long long)(n))#define fl(n) ((float)(n))#define ld(n) ((double)(n))#define LD(n) ((long double)(n))#define char(n) ((char)(n))#define Bool(n) ((bool)(n))#define fixpoint(n) fixed&lt;&lt;setprecision(n)const int INF=1061109567;const int NINF=-1044266559;const LL LINF=4557430888798830399;const ld eps=1e-15;#define MOD (1000000007)#define PI (3.1415926535897932384626433832795028841971)/*#define MB_LEN_MAX 5#define SHRT_MIN (-32768)#define SHRT_MAX 32767#define USHRT_MAX 0xffffU#define INT_MIN (-2147483647 - 1)#define INT_MAX 2147483647#define UINT_MAX 0xffffffffU#define LONG_MIN (-2147483647L - 1)#define LONG_MAX 2147483647L#define ULONG_MAX 0xffffffffUL#define LLONG_MAX 9223372036854775807ll#define LLONG_MIN (-9223372036854775807ll - 1)#define ULLONG_MAX 0xffffffffffffffffull*/#define MP make_pair#define MT make_tuple#define All(a) (a).begin(),(a).end()#define pall(a) (a).rbegin(),(a).rend()#define log2(x) log(x)/log(2)#define Log(x,y) log(x)/log(y)#define SZ(a) ((int)(a).size())#define rep(i,n) for(int i=0;i&lt;((int)(n));i++)#define rep1(i,n) for(int i=1;i&lt;=((int)(n));i++)#define repa(i,a,n) for(int i=((int)(a));i&lt;((int)(n));i++)#define repa1(i,a,n) for(int i=((int)(a));i&lt;=((int)(n));i++)#define repd(i,n) for(int i=((int)(n))-1;i&gt;=0;i--)#define repd1(i,n) for(int i=((int)(n));i&gt;=1;i--)#define repda(i,n,a) for(int i=((int)(n));i&gt;((int)(a));i--)#define repda1(i,n,a) for(int i=((int)(n));i&gt;=((int)(a));i--)#define FOR(i,a,n,step) for(int i=((int)(a));i&lt;((int)(n));i+=((int)(step)))#define repv(itr,v) for(__typeof((v).begin()) itr=(v).begin();itr!=(v).end();itr++)#define repV(i,v) for(auto i:v)#define repE(i,v) for(auto &amp;i:v)#define MS(x,y) memset(x,y,sizeof(x))#define MC(x) MS(x,0)#define MINF(x) MS(x,63)#define MCP(x,y) memcpy(x,y,sizeof(y))#define sqr(x) ((x)*(x))#define UN(v) sort(All(v)),v.erase(unique(All(v)),v.end())#define filein(x) freopen(x,"r",stdin)#define fileout(x) freopen(x,"w",stdout)#define fileio(x)\ freopen(x".in","r",stdin);\ freopen(x".out","w",stdout)#define filein2(filename,name) ifstream name(filename,ios::in)#define fileout2(filename,name) ofstream name(filename,ios::out)#define file(filename,name) fstream name(filename,ios::in|ios::out)#define Pause system("pause")#define Cls system("cls")#define fs first#define sc second#define PC(x) putchar(x)#define GC(x) x=getchar()#define Endl PC('\n')#define SF scanf#define PF printfinline int Read()&#123; int X=0,w=0;char ch=0;while(!isdigit(ch))&#123;w|=ch=='-';ch=getchar();&#125;while(isdigit(ch))X=(X&lt;&lt;3)+(X&lt;&lt;1)+(ch^48),ch=getchar(); return w?-X:X;&#125;inline void Write(int x)&#123;if(x&lt;0)putchar('-'),x=-x;if(x&gt;9)Write(x/10);putchar(x%10+'0');&#125;inline LL powmod(LL a,LL b)&#123;LL RES=1;a%=MOD;assert(b&gt;=0);for(;b;b&gt;&gt;=1)&#123;if(b&amp;1)RES=RES*a%MOD;a=a*a%MOD;&#125;return RES%MOD;&#125;inline LL gcdll(LL a,LL b)&#123;return b?gcdll(b,a%b):a;&#125;const int dx[]=&#123;0,1,0,-1,1,-1,-1,1&#125;;const int dy[]=&#123;1,0,-1,0,-1,-1,1,1&#125;;/************************************************************Begin************************************************************/const int maxn=110,maxm=510;int n,m,a[maxn][maxm],dp[maxn][maxm];pair&lt;int,int&gt; pre[maxn][maxm];inline int sol(int x,int y)&#123; if(y&lt;1||y&gt;m) return dp[x][y]=INF; if(dp[x][y]!=-1) return dp[x][y]; else dp[x][y]=0; int res=sol(x-1,y); dp[x][y]=res; pre[x][y]=&#123;x-1,y&#125;; res=sol(x,y-1); if(res&lt;dp[x][y]) &#123; dp[x][y]=res; pre[x][y]=&#123;x,y-1&#125;; &#125; res=sol(x,y+1); if(res&lt;dp[x][y]) &#123; dp[x][y]=res; pre[x][y]=&#123;x,y+1&#125;; &#125; dp[x][y]+=a[x][y]; return dp[x][y];&#125;inline void print(int x,int y)&#123; if(x&gt;1) print(pre[x][y].fs,pre[x][y].sc); cout&lt;&lt;y&lt;&lt;' ';&#125;int main()&#123; cin&gt;&gt;n&gt;&gt;m; rep1(i,n) rep1(j,m) cin&gt;&gt;a[i][j]; MS(dp,-1); rep1(j,m) dp[1][j]=a[1][j]; int ans=1; rep1(j,m) if(sol(n,j)&lt;sol(n,ans)) ans=j; print(n,ans); return 0;&#125;/*************************************************************End**************************************************************/]]></content>
      <categories>
        <category>算法</category>
        <category>Ural</category>
      </categories>
      <tags>
        <tag>DP</tag>
        <tag>记忆化搜索</tag>
        <tag>算法</tag>
        <tag>Ural</tag>
        <tag>最短路</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Ural 1250 Sea Burial 题解]]></title>
    <url>%2F2019%2F08%2F12%2FUral-1250-Sea-Burial-%E9%A2%98%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[Ural 1250 Sea Burial 题解题意给定一个$n\times m$的地图，.为水，#为陆，地图的外部是水(地图被水包围)。水为八连通，陆为四联通。联通的水称为海，联通的陆称为岛。海内可能有岛，岛内可能有海。给定$x,y$求在包含$(x,y)$(保证$(x,y)$为水)的海里面有多少岛。 输入第一行包含$m,n,y,x(1\le n,m\le 500,1\le x \le n,1\le y \le m)$ 以下若干行为一个$n\times m$的地图 题解考虑BFS或DFS(以下简称BFS) 从$(x,y)$BFS，找出包含$(x,y)$的海。 从地图外部(水)BFS，找出在包含$(x,y)$的海的外面部分。 执行完前两步，就可以知道包含$(x,y)$的海里面的部分，数出包含$(x,y)$的海里面的部分有多少岛即可。 Tip: 运用二进制可以使程序简便。记陆为$1$，岛为$2$。设我们需要的值为$x$，当前的值为$y$，只需判断$(x\&amp;y)$是否大于$0$即可。第1步时$x=2$，第2步时$x=3$(想一想，为什么，答案最后揭晓)，第3步时$x=1$。 程序 BFS 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239// #pragma GCC optimize(2)// #pragma G++ optimize(2)// #pragma comment(linker,"/STACK:102400000,102400000")// #include &lt;bits/stdc++.h&gt;#include &lt;map&gt;#include &lt;set&gt;#include &lt;list&gt;#include &lt;array&gt;#include &lt;cfenv&gt;#include &lt;cmath&gt;#include &lt;ctime&gt;#include &lt;deque&gt;#include &lt;mutex&gt;#include &lt;queue&gt;#include &lt;ratio&gt;#include &lt;regex&gt;#include &lt;stack&gt;#include &lt;tuple&gt;#include &lt;atomic&gt;#include &lt;bitset&gt;#include &lt;cctype&gt;#include &lt;cerrno&gt;#include &lt;cfloat&gt;#include &lt;chrono&gt;#include &lt;cstdio&gt;#include &lt;cwchar&gt;#include &lt;future&gt;#include &lt;limits&gt;#include &lt;locale&gt;#include &lt;memory&gt;#include &lt;random&gt;#include &lt;string&gt;#include &lt;thread&gt;#include &lt;vector&gt;#include &lt;cassert&gt;#include &lt;climits&gt;#include &lt;clocale&gt;#include &lt;complex&gt;#include &lt;csetjmp&gt;#include &lt;csignal&gt;#include &lt;cstdarg&gt;#include &lt;cstddef&gt;#include &lt;cstdint&gt;#include &lt;cstdlib&gt;#include &lt;cstring&gt;#include &lt;ctgmath&gt;#include &lt;cwctype&gt;#include &lt;fstream&gt;#include &lt;iomanip&gt;#include &lt;numeric&gt;#include &lt;sstream&gt;#include &lt;ccomplex&gt;#include &lt;cstdbool&gt;#include &lt;iostream&gt;#include &lt;typeinfo&gt;#include &lt;valarray&gt;#include &lt;algorithm&gt;#include &lt;cinttypes&gt;#include &lt;cstdalign&gt;#include &lt;stdexcept&gt;#include &lt;typeindex&gt;#include &lt;functional&gt;#include &lt;forward_list&gt;#include &lt;system_error&gt;#include &lt;unordered_map&gt;#include &lt;unordered_set&gt;#include &lt;scoped_allocator&gt;#include &lt;condition_variable&gt;// #include &lt;conio.h&gt;// #include &lt;windows.h&gt;using namespace std;typedef long long LL;typedef unsigned int ui;typedef unsigned long long ull;typedef float fl;typedef double ld;typedef long double LD;typedef pair&lt;int,int&gt; pii;#if (WIN32) || (WIN64) || (__WIN32) || (__WIN64) || (_WIN32) || (_WIN64) || (WINDOWS)#define lld "%I64d"#define llu "%I64u"#else#define lld "%lld"#define llu "%llu"#endif#define ui(n) ((unsigned int)(n))#define LL(n) ((long long)(n))#define ull(n) ((unsigned long long)(n))#define fl(n) ((float)(n))#define ld(n) ((double)(n))#define LD(n) ((long double)(n))#define char(n) ((char)(n))#define Bool(n) ((bool)(n))#define fixpoint(n) fixed&lt;&lt;setprecision(n)const int INF=1061109567;const int NINF=-1044266559;const LL LINF=4557430888798830399;const ld eps=1e-15;#define MOD (1000000007)#define PI (3.1415926535897932384626433832795028841971)/*#define MB_LEN_MAX 5#define SHRT_MIN (-32768)#define SHRT_MAX 32767#define USHRT_MAX 0xffffU#define INT_MIN (-2147483647 - 1)#define INT_MAX 2147483647#define UINT_MAX 0xffffffffU#define LONG_MIN (-2147483647L - 1)#define LONG_MAX 2147483647L#define ULONG_MAX 0xffffffffUL#define LLONG_MAX 9223372036854775807ll#define LLONG_MIN (-9223372036854775807ll - 1)#define ULLONG_MAX 0xffffffffffffffffull*/#define MP make_pair#define MT make_tuple#define All(a) (a).begin(),(a).end()#define pall(a) (a).rbegin(),(a).rend()#define log2(x) log(x)/log(2)#define Log(x,y) log(x)/log(y)#define SZ(a) ((int)(a).size())#define rep(i,n) for(int i=0;i&lt;((int)(n));i++)#define rep1(i,n) for(int i=1;i&lt;=((int)(n));i++)#define repa(i,a,n) for(int i=((int)(a));i&lt;((int)(n));i++)#define repa1(i,a,n) for(int i=((int)(a));i&lt;=((int)(n));i++)#define repd(i,n) for(int i=((int)(n))-1;i&gt;=0;i--)#define repd1(i,n) for(int i=((int)(n));i&gt;=1;i--)#define repda(i,n,a) for(int i=((int)(n));i&gt;((int)(a));i--)#define repda1(i,n,a) for(int i=((int)(n));i&gt;=((int)(a));i--)#define FOR(i,a,n,step) for(int i=((int)(a));i&lt;((int)(n));i+=((int)(step)))#define repv(itr,v) for(__typeof((v).begin()) itr=(v).begin();itr!=(v).end();itr++)#define repV(i,v) for(auto i:v)#define repE(i,v) for(auto &amp;i:v)#define MS(x,y) memset(x,y,sizeof(x))#define MC(x) MS(x,0)#define MINF(x) MS(x,63)#define MCP(x,y) memcpy(x,y,sizeof(y))#define sqr(x) ((x)*(x))#define UN(v) sort(All(v)),v.erase(unique(All(v)),v.end())#define filein(x) freopen(x,"r",stdin)#define fileout(x) freopen(x,"w",stdout)#define fileio(x)\ freopen(x".in","r",stdin);\ freopen(x".out","w",stdout)#define filein2(filename,name) ifstream name(filename,ios::in)#define fileout2(filename,name) ofstream name(filename,ios::out)#define file(filename,name) fstream name(filename,ios::in|ios::out)#define Pause system("pause")#define Cls system("cls")#define fs first#define sc second#define PC(x) putchar(x)#define GC(x) x=getchar()#define Endl PC('\n')#define SF scanf#define PF printfinline int Read()&#123; int X=0,w=0;char ch=0;while(!isdigit(ch))&#123;w|=ch=='-';ch=getchar();&#125;while(isdigit(ch))X=(X&lt;&lt;3)+(X&lt;&lt;1)+(ch^48),ch=getchar(); return w?-X:X;&#125;inline void Write(int x)&#123;if(x&lt;0)putchar('-'),x=-x;if(x&gt;9)Write(x/10);putchar(x%10+'0');&#125;inline LL powmod(LL a,LL b)&#123;LL RES=1;a%=MOD;assert(b&gt;=0);for(;b;b&gt;&gt;=1)&#123;if(b&amp;1)RES=RES*a%MOD;a=a*a%MOD;&#125;return RES%MOD;&#125;inline LL gcdll(LL a,LL b)&#123;return b?gcdll(b,a%b):a;&#125;const int dx[]=&#123;0,1,0,-1,1,-1,-1,1&#125;;const int dy[]=&#123;1,0,-1,0,-1,-1,1,1&#125;;/************************************************************Begin************************************************************/const int maxn=510;int n,m,X,Y,s[maxn][maxn],ans; // '#'=&gt;1(01) '.'=&gt;2(10)bool vis[maxn][maxn];inline void bfs(int sx,int sy,int status)&#123; vis[sx][sy]=1; queue&lt;pair&lt;int,int&gt; &gt; q;q.push(&#123;sx,sy&#125;); while(!q.empty()) &#123; int x=q.front().fs,y=q.front().sc;q.pop(); rep(i,8) &#123; if(s[x][y]==1&amp;&amp;i&gt;3) break; int cx=x+dx[i],cy=y+dy[i]; if(cx&gt;0&amp;&amp;cx&lt;=n&amp;&amp;cy&gt;0&amp;&amp;cy&lt;=m&amp;&amp;!vis[cx][cy]&amp;&amp;(s[cx][cy]&amp;status)) &#123; vis[cx][cy]=1; q.push(&#123;cx,cy&#125;); &#125; &#125; &#125;&#125;int main()&#123; cin&gt;&gt;m&gt;&gt;n&gt;&gt;Y&gt;&gt;X; rep1(i,n) rep1(j,m) &#123; char c;cin&gt;&gt;c; s[i][j]=(c=='#'?1:2); &#125; // step 1 bfs(X,Y,2); // step 2 rep1(i,n) &#123; bfs(i,0,3); bfs(i,m+1,3); &#125; rep1(j,m) &#123; bfs(0,j,3); bfs(n+1,j,3); &#125; //step 3 rep1(i,n) rep1(j,m) if(!vis[i][j]&amp;&amp;s[i][j]==1) &#123; ans++; bfs(i,j,1); &#125; cout&lt;&lt;ans; return 0;&#125;/*************************************************************End**************************************************************/ DFS(与BFS十分类似) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229// #pragma GCC optimize(2)// #pragma G++ optimize(2)// #pragma comment(linker,"/STACK:102400000,102400000")// #include &lt;bits/stdc++.h&gt;#include &lt;map&gt;#include &lt;set&gt;#include &lt;list&gt;#include &lt;array&gt;#include &lt;cfenv&gt;#include &lt;cmath&gt;#include &lt;ctime&gt;#include &lt;deque&gt;#include &lt;mutex&gt;#include &lt;queue&gt;#include &lt;ratio&gt;#include &lt;regex&gt;#include &lt;stack&gt;#include &lt;tuple&gt;#include &lt;atomic&gt;#include &lt;bitset&gt;#include &lt;cctype&gt;#include &lt;cerrno&gt;#include &lt;cfloat&gt;#include &lt;chrono&gt;#include &lt;cstdio&gt;#include &lt;cwchar&gt;#include &lt;future&gt;#include &lt;limits&gt;#include &lt;locale&gt;#include &lt;memory&gt;#include &lt;random&gt;#include &lt;string&gt;#include &lt;thread&gt;#include &lt;vector&gt;#include &lt;cassert&gt;#include &lt;climits&gt;#include &lt;clocale&gt;#include &lt;complex&gt;#include &lt;csetjmp&gt;#include &lt;csignal&gt;#include &lt;cstdarg&gt;#include &lt;cstddef&gt;#include &lt;cstdint&gt;#include &lt;cstdlib&gt;#include &lt;cstring&gt;#include &lt;ctgmath&gt;#include &lt;cwctype&gt;#include &lt;fstream&gt;#include &lt;iomanip&gt;#include &lt;numeric&gt;#include &lt;sstream&gt;#include &lt;ccomplex&gt;#include &lt;cstdbool&gt;#include &lt;iostream&gt;#include &lt;typeinfo&gt;#include &lt;valarray&gt;#include &lt;algorithm&gt;#include &lt;cinttypes&gt;#include &lt;cstdalign&gt;#include &lt;stdexcept&gt;#include &lt;typeindex&gt;#include &lt;functional&gt;#include &lt;forward_list&gt;#include &lt;system_error&gt;#include &lt;unordered_map&gt;#include &lt;unordered_set&gt;#include &lt;scoped_allocator&gt;#include &lt;condition_variable&gt;// #include &lt;conio.h&gt;// #include &lt;windows.h&gt;using namespace std;typedef long long LL;typedef unsigned int ui;typedef unsigned long long ull;typedef float fl;typedef double ld;typedef long double LD;typedef pair&lt;int,int&gt; pii;#if (WIN32) || (WIN64) || (__WIN32) || (__WIN64) || (_WIN32) || (_WIN64) || (WINDOWS)#define lld "%I64d"#define llu "%I64u"#else#define lld "%lld"#define llu "%llu"#endif#define ui(n) ((unsigned int)(n))#define LL(n) ((long long)(n))#define ull(n) ((unsigned long long)(n))#define fl(n) ((float)(n))#define ld(n) ((double)(n))#define LD(n) ((long double)(n))#define char(n) ((char)(n))#define Bool(n) ((bool)(n))#define fixpoint(n) fixed&lt;&lt;setprecision(n)const int INF=1061109567;const int NINF=-1044266559;const LL LINF=4557430888798830399;const ld eps=1e-15;#define MOD (1000000007)#define PI (3.1415926535897932384626433832795028841971)/*#define MB_LEN_MAX 5#define SHRT_MIN (-32768)#define SHRT_MAX 32767#define USHRT_MAX 0xffffU#define INT_MIN (-2147483647 - 1)#define INT_MAX 2147483647#define UINT_MAX 0xffffffffU#define LONG_MIN (-2147483647L - 1)#define LONG_MAX 2147483647L#define ULONG_MAX 0xffffffffUL#define LLONG_MAX 9223372036854775807ll#define LLONG_MIN (-9223372036854775807ll - 1)#define ULLONG_MAX 0xffffffffffffffffull*/#define MP make_pair#define MT make_tuple#define All(a) (a).begin(),(a).end()#define pall(a) (a).rbegin(),(a).rend()#define log2(x) log(x)/log(2)#define Log(x,y) log(x)/log(y)#define SZ(a) ((int)(a).size())#define rep(i,n) for(int i=0;i&lt;((int)(n));i++)#define rep1(i,n) for(int i=1;i&lt;=((int)(n));i++)#define repa(i,a,n) for(int i=((int)(a));i&lt;((int)(n));i++)#define repa1(i,a,n) for(int i=((int)(a));i&lt;=((int)(n));i++)#define repd(i,n) for(int i=((int)(n))-1;i&gt;=0;i--)#define repd1(i,n) for(int i=((int)(n));i&gt;=1;i--)#define repda(i,n,a) for(int i=((int)(n));i&gt;((int)(a));i--)#define repda1(i,n,a) for(int i=((int)(n));i&gt;=((int)(a));i--)#define FOR(i,a,n,step) for(int i=((int)(a));i&lt;((int)(n));i+=((int)(step)))#define repv(itr,v) for(__typeof((v).begin()) itr=(v).begin();itr!=(v).end();itr++)#define repV(i,v) for(auto i:v)#define repE(i,v) for(auto &amp;i:v)#define MS(x,y) memset(x,y,sizeof(x))#define MC(x) MS(x,0)#define MINF(x) MS(x,63)#define MCP(x,y) memcpy(x,y,sizeof(y))#define sqr(x) ((x)*(x))#define UN(v) sort(All(v)),v.erase(unique(All(v)),v.end())#define filein(x) freopen(x,"r",stdin)#define fileout(x) freopen(x,"w",stdout)#define fileio(x)\ freopen(x".in","r",stdin);\ freopen(x".out","w",stdout)#define filein2(filename,name) ifstream name(filename,ios::in)#define fileout2(filename,name) ofstream name(filename,ios::out)#define file(filename,name) fstream name(filename,ios::in|ios::out)#define Pause system("pause")#define Cls system("cls")#define fs first#define sc second#define PC(x) putchar(x)#define GC(x) x=getchar()#define Endl PC('\n')#define SF scanf#define PF printfinline int Read()&#123; int X=0,w=0;char ch=0;while(!isdigit(ch))&#123;w|=ch=='-';ch=getchar();&#125;while(isdigit(ch))X=(X&lt;&lt;3)+(X&lt;&lt;1)+(ch^48),ch=getchar(); return w?-X:X;&#125;inline void Write(int x)&#123;if(x&lt;0)putchar('-'),x=-x;if(x&gt;9)Write(x/10);putchar(x%10+'0');&#125;inline LL powmod(LL a,LL b)&#123;LL RES=1;a%=MOD;assert(b&gt;=0);for(;b;b&gt;&gt;=1)&#123;if(b&amp;1)RES=RES*a%MOD;a=a*a%MOD;&#125;return RES%MOD;&#125;inline LL gcdll(LL a,LL b)&#123;return b?gcdll(b,a%b):a;&#125;const int dx[]=&#123;0,1,0,-1,1,-1,-1,1&#125;;const int dy[]=&#123;1,0,-1,0,-1,-1,1,1&#125;;/************************************************************Begin************************************************************/const int maxn=510;int n,m,X,Y,s[maxn][maxn],ans; // '#'=&gt;1(01) '.'=&gt;2(10)bool vis[maxn][maxn];inline void dfs(int x,int y,int status)&#123; vis[x][y]=1; rep(i,8) &#123; if(s[x][y]==1&amp;&amp;i&gt;3) break; int cx=x+dx[i],cy=y+dy[i]; if(cx&gt;0&amp;&amp;cx&lt;=n&amp;&amp;cy&gt;0&amp;&amp;cy&lt;=m&amp;&amp;!vis[cx][cy]&amp;&amp;(s[cx][cy]&amp;status)) dfs(cx,cy,status); &#125;&#125;int main()&#123; cin&gt;&gt;m&gt;&gt;n&gt;&gt;Y&gt;&gt;X; rep1(i,n) rep1(j,m) &#123; char c;cin&gt;&gt;c; s[i][j]=(c=='#'?1:2); &#125; // step 1 dfs(X,Y,2); // step 2 rep1(i,n) &#123; dfs(i,0,3); dfs(i,m+1,3); &#125; rep1(j,m) &#123; dfs(0,j,3); dfs(n+1,j,3); &#125; //step 3 rep1(i,n) rep1(j,m) if(!vis[i][j]&amp;&amp;s[i][j]==1) &#123; ans++; dfs(i,j,1); &#125; cout&lt;&lt;ans; return 0;&#125;/*************************************************************End**************************************************************/ Tip’s answer: 第2步是需要找出在包含$(x,y)$的海的外面部分，而外面部分不分海陆，$x=3$即$x=(11)_2$，这样$1\&amp;3$与$2\&amp;3$都大于$0$了。]]></content>
      <categories>
        <category>算法</category>
        <category>Ural</category>
      </categories>
      <tags>
        <tag>BFS</tag>
        <tag>DFS</tag>
        <tag>图论</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2019%2F08%2F12%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Let’s CodeHappy Coding, Happy OI 12345678#include &lt;bits/stdc++.h&gt;using namespace std;int main()&#123; cout&lt;&lt;"Happy Coding, Happy OI!"; return 0;&#125; \LaTeX]]></content>
  </entry>
</search>
