<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Codeforces 903D Almost Difference 题解]]></title>
    <url>%2F2019%2F11%2F08%2FCodeforces-903D-Almost-Difference-%E9%A2%98%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[Codeforces 903D Almost Difference 题解题意定义一个方程 d(x,y)= \begin{cases} y-x,\quad &\text{if}\ |x-y|>1 \\ 0,&\text{if}\ |x-y|\le1 \end{cases}给定一个有$n$个数的数组$a (1\le n\le2\times10^5,1\le a_i\le10^9)$，求出$\sum\limits_{1\le i\le j\le n}d(a_i,a_j)$。 题解设$s_i$表示$\sum\limits_{j=1}^{i}a_j$，可以用前缀和求出。 令$ans=\sum\limits_{i=1}^n(i\times a_i-s_i)$，这样就求出了不考虑$d(x,y)=0$的部分。 在考虑$d(x,y)=0$的时候，用map维护每个值出现的次数，加上或减去差为$1$的数的个数即可。 最坑的地方：会爆long long，可以用double，不输出小数部分即可。 然后发现会WA 13，用long double后AC。 程序123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206// #pragma GCC optimize(2)// #pragma G++ optimize(2)// #pragma comment(linker,"/STACK:102400000,102400000")// #include &lt;bits/stdc++.h&gt;#include &lt;map&gt;#include &lt;set&gt;#include &lt;list&gt;#include &lt;array&gt;#include &lt;cfenv&gt;#include &lt;cmath&gt;#include &lt;ctime&gt;#include &lt;deque&gt;#include &lt;mutex&gt;#include &lt;queue&gt;#include &lt;ratio&gt;#include &lt;regex&gt;#include &lt;stack&gt;#include &lt;tuple&gt;#include &lt;atomic&gt;#include &lt;bitset&gt;#include &lt;cctype&gt;#include &lt;cerrno&gt;#include &lt;cfloat&gt;#include &lt;chrono&gt;#include &lt;cstdio&gt;#include &lt;cwchar&gt;#include &lt;future&gt;#include &lt;limits&gt;#include &lt;locale&gt;#include &lt;memory&gt;#include &lt;random&gt;#include &lt;string&gt;#include &lt;thread&gt;#include &lt;vector&gt;#include &lt;cassert&gt;#include &lt;climits&gt;#include &lt;clocale&gt;#include &lt;complex&gt;#include &lt;csetjmp&gt;#include &lt;csignal&gt;#include &lt;cstdarg&gt;#include &lt;cstddef&gt;#include &lt;cstdint&gt;#include &lt;cstdlib&gt;#include &lt;cstring&gt;#include &lt;ctgmath&gt;#include &lt;cwctype&gt;#include &lt;fstream&gt;#include &lt;iomanip&gt;#include &lt;numeric&gt;#include &lt;sstream&gt;#include &lt;ccomplex&gt;#include &lt;cstdbool&gt;#include &lt;iostream&gt;#include &lt;typeinfo&gt;#include &lt;valarray&gt;#include &lt;algorithm&gt;#include &lt;cinttypes&gt;#include &lt;cstdalign&gt;#include &lt;stdexcept&gt;#include &lt;typeindex&gt;#include &lt;functional&gt;#include &lt;forward_list&gt;#include &lt;system_error&gt;#include &lt;unordered_map&gt;#include &lt;unordered_set&gt;#include &lt;scoped_allocator&gt;#include &lt;condition_variable&gt;// #include &lt;conio.h&gt;// #include &lt;windows.h&gt;using namespace std;typedef long long LL;typedef unsigned int ui;typedef unsigned long long ull;typedef float fl;typedef double ld;typedef long double LD;typedef pair&lt;int,int&gt; pii;#if (WIN32) || (WIN64) || (__WIN32) || (__WIN64) || (_WIN32) || (_WIN64) || (WINDOWS)#define lld "%I64d"#define llu "%I64u"#else#define lld "%lld"#define llu "%llu"#endif#define ui(n) ((unsigned int)(n))#define LL(n) ((long long)(n))#define ull(n) ((unsigned long long)(n))#define fl(n) ((float)(n))#define ld(n) ((double)(n))#define LD(n) ((long double)(n))#define char(n) ((char)(n))#define Bool(n) ((bool)(n))#define fixpoint(n) fixed&lt;&lt;setprecision(n)const int INF=1061109567;const int NINF=-1044266559;const LL LINF=4557430888798830399;const ld eps=1e-15;#define MOD (1000000007)#define PI (3.1415926535897932384626433832795028841971)/*#define MB_LEN_MAX 5#define SHRT_MIN (-32768)#define SHRT_MAX 32767#define USHRT_MAX 0xffffU#define INT_MIN (-2147483647 - 1)#define INT_MAX 2147483647#define UINT_MAX 0xffffffffU#define LONG_MIN (-2147483647L - 1)#define LONG_MAX 2147483647L#define ULONG_MAX 0xffffffffUL#define LLONG_MAX 9223372036854775807ll#define LLONG_MIN (-9223372036854775807ll - 1)#define ULLONG_MAX 0xffffffffffffffffull*/#define MP make_pair#define MT make_tuple#define All(a) (a).begin(),(a).end()#define pall(a) (a).rbegin(),(a).rend()#define Log(x,y) log(x)/log(y)#define SZ(a) ((int)(a).size())#define rep(i,n) for(int i=0;i&lt;((int)(n));i++)#define rep1(i,n) for(int i=1;i&lt;=((int)(n));i++)#define repa(i,a,n) for(int i=((int)(a));i&lt;((int)(n));i++)#define repa1(i,a,n) for(int i=((int)(a));i&lt;=((int)(n));i++)#define repd(i,n) for(int i=((int)(n))-1;i&gt;=0;i--)#define repd1(i,n) for(int i=((int)(n));i&gt;=1;i--)#define repda(i,n,a) for(int i=((int)(n));i&gt;((int)(a));i--)#define repda1(i,n,a) for(int i=((int)(n));i&gt;=((int)(a));i--)#define FOR(i,a,n,step) for(int i=((int)(a));i&lt;((int)(n));i+=((int)(step)))#define repv(itr,v) for(__typeof((v).begin()) itr=(v).begin();itr!=(v).end();itr++)#define repV(i,v) for(auto i:v)#define repE(i,v) for(auto &amp;i:v)#define MS(x,y) memset(x,y,sizeof(x))#define MC(x) MS(x,0)#define MINF(x) MS(x,63)#define MCP(x,y) memcpy(x,y,sizeof(y))#define sqr(x) ((x)*(x))#define UN(v) sort(All(v)),v.erase(unique(All(v)),v.end())#define filein(x) freopen(x,"r",stdin)#define fileout(x) freopen(x,"w",stdout)#define fileio(x)\ freopen(x".in","r",stdin);\ freopen(x".out","w",stdout)#define filein2(filename,name) ifstream name(filename,ios::in)#define fileout2(filename,name) ofstream name(filename,ios::out)#define file(filename,name) fstream name(filename,ios::in|ios::out)#define Pause system("pause")#define Cls system("cls")#define fs first#define sc second#define PC(x) putchar(x)#define GC(x) x=getchar()#define Endl PC('\n')#define SF scanf#define PF printf#define j0 J0#define j1 J1#define jn Jn#define y0 Y0#define y1 Y1#define yn Yninline int Read()&#123; int x=0,w=0;char ch=0;while(!isdigit(ch))&#123;w|=ch=='-';ch=getchar();&#125;while(isdigit(ch))x=(x&lt;&lt;3)+(x&lt;&lt;1)+(ch^48),ch=getchar(); return w?-x:x;&#125;inline void Write(int x)&#123;if(x&lt;0)putchar('-'),x=-x;if(x&gt;9)Write(x/10);putchar(x%10+'0');&#125;inline LL powmod(LL a,LL b)&#123;LL res=1;a%=MOD;assert(b&gt;=0);for(;b;b&gt;&gt;=1)&#123;if(b&amp;1)res=res*a%MOD;a=a*a%MOD;&#125;return res%MOD;&#125;inline LL gcdll(LL a,LL b)&#123;return b?gcdll(b,a%b):a;&#125;const int dx[]=&#123;0,1,0,-1,1,-1,-1,1&#125;;const int dy[]=&#123;1,0,-1,0,-1,-1,1,1&#125;;/************************************************************BEGIN************************************************************/const int maxn=200010;int n;LL sum;LD ans;map&lt;int,int&gt; cnt;int main()&#123; SF("%d",&amp;n); rep1(i,n) &#123; int x;SF("%d",&amp;x); sum+=x; ans+=1ll*x*i-sum-cnt[x-1]+cnt[x+1]; cnt[x]++; &#125; PF("%.0Lf",ans); return 0;&#125;/*************************************************************END**************************************************************/]]></content>
      <categories>
        <category>算法</category>
        <category>Codeforces</category>
      </categories>
      <tags>
        <tag>数学</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Codeforces 337D Book of Evil 题解]]></title>
    <url>%2F2019%2F11%2F02%2FCodeforces-337D-Book-of-Evil-%E9%A2%98%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[Codeforces 337D Book of Evil 题解题意给定一个有$n$个结点的树，树上有$m (1\le m\le n\le10^5)$个结点被感染，分别是$p_1,p_2,\dots,p_m (1\le p_i\le n)$。 有一本“邪恶之书”在树上的某一个结点上，它可以感染 所有到它的距离小于等于$d (0\le d\le n-1)$的结点。 求“邪恶之书”可以在哪些结点上，使得它可以感染$p_1,p_2,\dots,p_m$这些结点。输出可能的个数。 题解与树的直径类似。 从$1$号结点dfs，找到距离它最远的感染结点$v_1$。 从$v_1$dfs，找到距离它最远的感染结点$v_2$。 从$v_2$dfs。 找到所有点$x$，使得到$v_1$和$v_2$的距离都小于等于$d$，输出个数即可。时间复杂度$O(n)$。 证明： 定义$D(x,y)$为结点$x$到结点$y$的距离。 设$x$为满足$D(v_1,x)\le d$且$D(v_2,x)\le d$的任意结点。 需要证明 不存在感染结点$v_3$，使得$D(v_3,x)&gt;d$。 由求$v_1,v_2$的过程得：$v_1,v_2$是这棵树中，距离最大的两个感染结点(证明过程同树的直径的证明过程)。 若$D(v_1,x)\le d,D(v_2,x)\le d,D(v_3,x)&gt;d$，则$D(v_1,v_3)&gt;D(v_1,v_2)$，矛盾。 证毕。 程序123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224// #pragma GCC optimize(2)// #pragma G++ optimize(2)// #pragma comment(linker,"/STACK:102400000,102400000")// #include &lt;bits/stdc++.h&gt;#include &lt;map&gt;#include &lt;set&gt;#include &lt;list&gt;#include &lt;array&gt;#include &lt;cfenv&gt;#include &lt;cmath&gt;#include &lt;ctime&gt;#include &lt;deque&gt;#include &lt;mutex&gt;#include &lt;queue&gt;#include &lt;ratio&gt;#include &lt;regex&gt;#include &lt;stack&gt;#include &lt;tuple&gt;#include &lt;atomic&gt;#include &lt;bitset&gt;#include &lt;cctype&gt;#include &lt;cerrno&gt;#include &lt;cfloat&gt;#include &lt;chrono&gt;#include &lt;cstdio&gt;#include &lt;cwchar&gt;#include &lt;future&gt;#include &lt;limits&gt;#include &lt;locale&gt;#include &lt;memory&gt;#include &lt;random&gt;#include &lt;string&gt;#include &lt;thread&gt;#include &lt;vector&gt;#include &lt;cassert&gt;#include &lt;climits&gt;#include &lt;clocale&gt;#include &lt;complex&gt;#include &lt;csetjmp&gt;#include &lt;csignal&gt;#include &lt;cstdarg&gt;#include &lt;cstddef&gt;#include &lt;cstdint&gt;#include &lt;cstdlib&gt;#include &lt;cstring&gt;#include &lt;ctgmath&gt;#include &lt;cwctype&gt;#include &lt;fstream&gt;#include &lt;iomanip&gt;#include &lt;numeric&gt;#include &lt;sstream&gt;#include &lt;ccomplex&gt;#include &lt;cstdbool&gt;#include &lt;iostream&gt;#include &lt;typeinfo&gt;#include &lt;valarray&gt;#include &lt;algorithm&gt;#include &lt;cinttypes&gt;#include &lt;cstdalign&gt;#include &lt;stdexcept&gt;#include &lt;typeindex&gt;#include &lt;functional&gt;#include &lt;forward_list&gt;#include &lt;system_error&gt;#include &lt;unordered_map&gt;#include &lt;unordered_set&gt;#include &lt;scoped_allocator&gt;#include &lt;condition_variable&gt;// #include &lt;conio.h&gt;// #include &lt;windows.h&gt;using namespace std;typedef long long LL;typedef unsigned int ui;typedef unsigned long long ull;typedef float fl;typedef double ld;typedef long double LD;typedef pair&lt;int,int&gt; pii;#if (WIN32) || (WIN64) || (__WIN32) || (__WIN64) || (_WIN32) || (_WIN64) || (WINDOWS)#define lld "%I64d"#define llu "%I64u"#else#define lld "%lld"#define llu "%llu"#endif#define ui(n) ((unsigned int)(n))#define LL(n) ((long long)(n))#define ull(n) ((unsigned long long)(n))#define fl(n) ((float)(n))#define ld(n) ((double)(n))#define LD(n) ((long double)(n))#define char(n) ((char)(n))#define Bool(n) ((bool)(n))#define fixpoint(n) fixed&lt;&lt;setprecision(n)const int INF=1061109567;const int NINF=-1044266559;const LL LINF=4557430888798830399;const ld eps=1e-15;#define MOD (1000000007)#define PI (3.1415926535897932384626433832795028841971)/*#define MB_LEN_MAX 5#define SHRT_MIN (-32768)#define SHRT_MAX 32767#define USHRT_MAX 0xffffU#define INT_MIN (-2147483647 - 1)#define INT_MAX 2147483647#define UINT_MAX 0xffffffffU#define LONG_MIN (-2147483647L - 1)#define LONG_MAX 2147483647L#define ULONG_MAX 0xffffffffUL#define LLONG_MAX 9223372036854775807ll#define LLONG_MIN (-9223372036854775807ll - 1)#define ULLONG_MAX 0xffffffffffffffffull*/#define MP make_pair#define MT make_tuple#define All(a) (a).begin(),(a).end()#define pall(a) (a).rbegin(),(a).rend()#define Log(x,y) log(x)/log(y)#define SZ(a) ((int)(a).size())#define rep(i,n) for(int i=0;i&lt;((int)(n));i++)#define rep1(i,n) for(int i=1;i&lt;=((int)(n));i++)#define repa(i,a,n) for(int i=((int)(a));i&lt;((int)(n));i++)#define repa1(i,a,n) for(int i=((int)(a));i&lt;=((int)(n));i++)#define repd(i,n) for(int i=((int)(n))-1;i&gt;=0;i--)#define repd1(i,n) for(int i=((int)(n));i&gt;=1;i--)#define repda(i,n,a) for(int i=((int)(n));i&gt;((int)(a));i--)#define repda1(i,n,a) for(int i=((int)(n));i&gt;=((int)(a));i--)#define FOR(i,a,n,step) for(int i=((int)(a));i&lt;((int)(n));i+=((int)(step)))#define repv(itr,v) for(__typeof((v).begin()) itr=(v).begin();itr!=(v).end();itr++)#define repV(i,v) for(auto i:v)#define repE(i,v) for(auto &amp;i:v)#define MS(x,y) memset(x,y,sizeof(x))#define MC(x) MS(x,0)#define MINF(x) MS(x,63)#define MCP(x,y) memcpy(x,y,sizeof(y))#define sqr(x) ((x)*(x))#define UN(v) sort(All(v)),v.erase(unique(All(v)),v.end())#define filein(x) freopen(x,"r",stdin)#define fileout(x) freopen(x,"w",stdout)#define fileio(x)\ freopen(x".in","r",stdin);\ freopen(x".out","w",stdout)#define filein2(filename,name) ifstream name(filename,ios::in)#define fileout2(filename,name) ofstream name(filename,ios::out)#define file(filename,name) fstream name(filename,ios::in|ios::out)#define Pause system("pause")#define Cls system("cls")#define fs first#define sc second#define PC(x) putchar(x)#define GC(x) x=getchar()#define Endl PC('\n')#define SF scanf#define PF printf#define j0 J0#define j1 J1#define jn Jn#define y0 Y0#define y1 Y1#define yn Yninline int Read()&#123; int x=0,w=0;char ch=0;while(!isdigit(ch))&#123;w|=ch=='-';ch=getchar();&#125;while(isdigit(ch))x=(x&lt;&lt;3)+(x&lt;&lt;1)+(ch^48),ch=getchar(); return w?-x:x;&#125;inline void Write(int x)&#123;if(x&lt;0)putchar('-'),x=-x;if(x&gt;9)Write(x/10);putchar(x%10+'0');&#125;inline LL powmod(LL a,LL b)&#123;LL res=1;a%=MOD;assert(b&gt;=0);for(;b;b&gt;&gt;=1)&#123;if(b&amp;1)res=res*a%MOD;a=a*a%MOD;&#125;return res%MOD;&#125;inline LL gcdll(LL a,LL b)&#123;return b?gcdll(b,a%b):a;&#125;const int dx[]=&#123;0,1,0,-1,1,-1,-1,1&#125;;const int dy[]=&#123;1,0,-1,0,-1,-1,1,1&#125;;/************************************************************BEGIN************************************************************/const int maxn=100010;int n,m,d,p[maxn],dist[3][maxn],v1,v2,ans;vector&lt;int&gt; e[maxn];inline void dfs(int x,int fa,int root)&#123; repV(y,e[x]) if(y!=fa) &#123; dist[root][y]=dist[root][x]+1; dfs(y,x,root); &#125;&#125;int main()&#123; SF("%d%d%d",&amp;n,&amp;m,&amp;d); rep(i,m) &#123; int u;SF("%d",&amp;u); p[u]=1; &#125; rep(i,n-1) &#123; int u,v;SF("%d%d",&amp;u,&amp;v); e[u].push_back(v); e[v].push_back(u); &#125; dfs(1,0,0); rep1(i,n) if(p[i]&amp;&amp;(!v1||dist[0][i]&gt;dist[0][v1])) v1=i; dfs(v1,0,1); rep1(i,n) if(p[i]&amp;&amp;(!v2||dist[1][i]&gt;dist[1][v2])) v2=i; dfs(v2,0,2); rep1(i,n) if(dist[1][i]&lt;=d&amp;&amp;dist[2][i]&lt;=d) ans++; PF("%d",ans); return 0;&#125;/*************************************************************END**************************************************************/]]></content>
      <categories>
        <category>算法</category>
        <category>Codeforces</category>
      </categories>
      <tags>
        <tag>DFS</tag>
        <tag>分治</tag>
        <tag>树形DP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Codeforces 587B Duff in Beach 题解]]></title>
    <url>%2F2019%2F10%2F25%2FCodeforces-587B-Duff-in-Beach-%E9%A2%98%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[Codeforces 587B Duff in Beach 题解题意有一个长度为$n$的数组$a_0,a_1,\dots,a_{n-1}$和一个长度为$l$的数组$b_0,b_1,\dots,b_{l-1}$，其中$b$是由$a$得出的，满足$b_i=a_{i\bmod n}$。 给定$n,l,k (1\le n,k,n\times k\le10^6,1\le l\le10^{18})$，求子序列$b_{i_1},b_{i_2},\dots,b_{i_x}$满足以下条件的数量： $1\le x\le k$ $\forall 1\le j\le x-1,\left\lfloor\frac{i_j}{n}\right\rfloor+1=\left\lfloor\frac{i_{j+1}}{n}\right\rfloor$ $\forall 1\le j\le x-1,b_{i_j}\le b_{i_{j-1}}$，即这个子序列是非下降子序列。 输出这个数量模$10^9+7$。 题解总结题意，可以知道$b$是由$a$重复$\left\lfloor\frac{l}{n}\right\rfloor$次加上$a$的前$l\%n$项得出的。 求的是一个长度小于$k$的非下降子序列，满足序列中的数在一些连续的“块”($a$重复一次算一块)中 的个数。 考虑DP： $dp(i,j)$表示考虑到第$i$块，选择了这一块的第$j$个数 的合法子序列个数。 dp(i,j)=\sum_{0\le k]]></content>
      <categories>
        <category>算法</category>
        <category>Codeforces</category>
      </categories>
      <tags>
        <tag>DP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Codeforces 587C Duff in the Army 题解]]></title>
    <url>%2F2019%2F10%2F25%2FCodeforces-587C-Duff-in-the-Army-%E9%A2%98%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[Codeforces 587C Duff in the Army 题解题意给定一棵有$n$个结点的树，某些结点上有一些数，总共有$m$个数，有$q (1\le n,m,k\le 10^5)$次询问。 每次询问给定$u,v,a (1\le u,v\le n,1\le a\le10)$，求出 在$u$到$v$的路径上所有的结点上的数中，前$a$小的数(如果总数小于$a$，则输出所有的数)。 题解在树中，从$u$到$v$的路径上，$a\le10$，从这三个条件可以想到用树链剖分，线段树中每个结点维护的是一个长度小于等于$10$的vector，表示的是这些点中前$10$小的数，可以$O(1)$合并。 因为没有修改，所以省去了很多。程序也不是太难写。 时间复杂度$O(q\log n)$。 Tip: 可以用LCA，也是维护前$10$小的数，时间复杂度同样。 程序123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319// #pragma GCC optimize(2)// #pragma G++ optimize(2)// #pragma comment(linker,"/STACK:102400000,102400000")// #include &lt;bits/stdc++.h&gt;#include &lt;map&gt;#include &lt;set&gt;#include &lt;list&gt;#include &lt;array&gt;#include &lt;cfenv&gt;#include &lt;cmath&gt;#include &lt;ctime&gt;#include &lt;deque&gt;#include &lt;mutex&gt;#include &lt;queue&gt;#include &lt;ratio&gt;#include &lt;regex&gt;#include &lt;stack&gt;#include &lt;tuple&gt;#include &lt;atomic&gt;#include &lt;bitset&gt;#include &lt;cctype&gt;#include &lt;cerrno&gt;#include &lt;cfloat&gt;#include &lt;chrono&gt;#include &lt;cstdio&gt;#include &lt;cwchar&gt;#include &lt;future&gt;#include &lt;limits&gt;#include &lt;locale&gt;#include &lt;memory&gt;#include &lt;random&gt;#include &lt;string&gt;#include &lt;thread&gt;#include &lt;vector&gt;#include &lt;cassert&gt;#include &lt;climits&gt;#include &lt;clocale&gt;#include &lt;complex&gt;#include &lt;csetjmp&gt;#include &lt;csignal&gt;#include &lt;cstdarg&gt;#include &lt;cstddef&gt;#include &lt;cstdint&gt;#include &lt;cstdlib&gt;#include &lt;cstring&gt;#include &lt;ctgmath&gt;#include &lt;cwctype&gt;#include &lt;fstream&gt;#include &lt;iomanip&gt;#include &lt;numeric&gt;#include &lt;sstream&gt;#include &lt;ccomplex&gt;#include &lt;cstdbool&gt;#include &lt;iostream&gt;#include &lt;typeinfo&gt;#include &lt;valarray&gt;#include &lt;algorithm&gt;#include &lt;cinttypes&gt;#include &lt;cstdalign&gt;#include &lt;stdexcept&gt;#include &lt;typeindex&gt;#include &lt;functional&gt;#include &lt;forward_list&gt;#include &lt;system_error&gt;#include &lt;unordered_map&gt;#include &lt;unordered_set&gt;#include &lt;scoped_allocator&gt;#include &lt;condition_variable&gt;// #include &lt;conio.h&gt;// #include &lt;windows.h&gt;using namespace std;typedef long long LL;typedef unsigned int ui;typedef unsigned long long ull;typedef float fl;typedef double ld;typedef long double LD;typedef pair&lt;int,int&gt; pii;#if (WIN32) || (WIN64) || (__WIN32) || (__WIN64) || (_WIN32) || (_WIN64) || (WINDOWS)#define lld "%I64d"#define llu "%I64u"#else#define lld "%lld"#define llu "%llu"#endif#define ui(n) ((unsigned int)(n))#define LL(n) ((long long)(n))#define ull(n) ((unsigned long long)(n))#define fl(n) ((float)(n))#define ld(n) ((double)(n))#define LD(n) ((long double)(n))#define char(n) ((char)(n))#define Bool(n) ((bool)(n))#define fixpoint(n) fixed&lt;&lt;setprecision(n)const int INF=1061109567;const int NINF=-1044266559;const LL LINF=4557430888798830399;const ld eps=1e-15;#define MOD (1000000007)#define PI (3.1415926535897932384626433832795028841971)/*#define MB_LEN_MAX 5#define SHRT_MIN (-32768)#define SHRT_MAX 32767#define USHRT_MAX 0xffffU#define INT_MIN (-2147483647 - 1)#define INT_MAX 2147483647#define UINT_MAX 0xffffffffU#define LONG_MIN (-2147483647L - 1)#define LONG_MAX 2147483647L#define ULONG_MAX 0xffffffffUL#define LLONG_MAX 9223372036854775807ll#define LLONG_MIN (-9223372036854775807ll - 1)#define ULLONG_MAX 0xffffffffffffffffull*/#define MP make_pair#define MT make_tuple#define All(a) (a).begin(),(a).end()#define pall(a) (a).rbegin(),(a).rend()#define Log(x,y) log(x)/log(y)#define SZ(a) ((int)(a).size())#define rep(i,n) for(int i=0;i&lt;((int)(n));i++)#define rep1(i,n) for(int i=1;i&lt;=((int)(n));i++)#define repa(i,a,n) for(int i=((int)(a));i&lt;((int)(n));i++)#define repa1(i,a,n) for(int i=((int)(a));i&lt;=((int)(n));i++)#define repd(i,n) for(int i=((int)(n))-1;i&gt;=0;i--)#define repd1(i,n) for(int i=((int)(n));i&gt;=1;i--)#define repda(i,n,a) for(int i=((int)(n));i&gt;((int)(a));i--)#define repda1(i,n,a) for(int i=((int)(n));i&gt;=((int)(a));i--)#define FOR(i,a,n,step) for(int i=((int)(a));i&lt;((int)(n));i+=((int)(step)))#define repv(itr,v) for(__typeof((v).begin()) itr=(v).begin();itr!=(v).end();itr++)#define repV(i,v) for(auto i:v)#define repE(i,v) for(auto &amp;i:v)#define MS(x,y) memset(x,y,sizeof(x))#define MC(x) MS(x,0)#define MINF(x) MS(x,63)#define MCP(x,y) memcpy(x,y,sizeof(y))#define sqr(x) ((x)*(x))#define UN(v) sort(All(v)),v.erase(unique(All(v)),v.end())#define filein(x) freopen(x,"r",stdin)#define fileout(x) freopen(x,"w",stdout)#define fileio(x)\ freopen(x".in","r",stdin);\ freopen(x".out","w",stdout)#define filein2(filename,name) ifstream name(filename,ios::in)#define fileout2(filename,name) ofstream name(filename,ios::out)#define file(filename,name) fstream name(filename,ios::in|ios::out)#define Pause system("pause")#define Cls system("cls")#define fs first#define sc second#define PC(x) putchar(x)#define GC(x) x=getchar()#define Endl PC('\n')#define SF scanf#define PF printf#define j0 J0#define j1 J1#define jn Jn#define y0 Y0#define y1 Y1#define yn Yninline int Read()&#123; int X=0,w=0;char ch=0;while(!isdigit(ch))&#123;w|=ch=='-';ch=getchar();&#125;while(isdigit(ch))X=(X&lt;&lt;3)+(X&lt;&lt;1)+(ch^48),ch=getchar(); return w?-X:X;&#125;inline void Write(int x)&#123;if(x&lt;0)putchar('-'),x=-x;if(x&gt;9)Write(x/10);putchar(x%10+'0');&#125;inline LL powmod(LL a,LL b)&#123;LL RES=1;a%=MOD;assert(b&gt;=0);for(;b;b&gt;&gt;=1)&#123;if(b&amp;1)RES=RES*a%MOD;a=a*a%MOD;&#125;return RES%MOD;&#125;inline LL gcdll(LL a,LL b)&#123;return b?gcdll(b,a%b):a;&#125;const int dx[]=&#123;0,1,0,-1,1,-1,-1,1&#125;;const int dy[]=&#123;1,0,-1,0,-1,-1,1,1&#125;;/************************************************************BEGIN************************************************************/const int maxn=100010;struct node&#123; int l,r; vector&lt;int&gt; w;&#125; tree[maxn*4];int n,m,q,son[maxn],id[maxn],fa[maxn],cnt,dep[maxn],siz[maxn],top[maxn];vector&lt;int&gt; e[maxn],w[maxn],wt[maxn],ans;inline void update(vector&lt;int&gt; &amp;a,vector&lt;int&gt; b)&#123; int l=0,r=0; vector&lt;int&gt; c; while(c.size()&lt;10&amp;&amp;(l!=a.size()||r!=b.size())) &#123; if(l==a.size()) c.push_back(b[r++]); else if(r==b.size()) c.push_back(a[l++]); else &#123; if(a[l]&lt;b[r]) c.push_back(a[l++]); else c.push_back(b[r++]); &#125; &#125; a=c;&#125;inline void seg_build(int l,int r,int k)&#123; tree[k].l=l;tree[k].r=r; if(l==r) &#123; tree[k].w=wt[l]; return; &#125; int mid=(l+r)/2; seg_build(l,mid,k*2); seg_build(mid+1,r,k*2+1); update(tree[k].w,tree[k*2].w); update(tree[k].w,tree[k*2+1].w);&#125;inline void seg_range_sum(int l,int r,int k) &#123; if(tree[k].l&gt;=l&amp;&amp;tree[k].r&lt;=r) return update(ans,tree[k].w); int mid=(tree[k].l+tree[k].r)/2; if(l&lt;=mid) seg_range_sum(l,r,k*2); if(r&gt;mid) seg_range_sum(l,r,k*2+1);&#125;inline void dfs1(int x,int f,int deep)&#123; dep[x]=deep; fa[x]=f; siz[x]=1; for(int i=0;i&lt;e[x].size();i++) &#123; int y=e[x][i]; if(y!=f) &#123; dfs1(y,x,deep+1); siz[x]+=siz[y]; if(son[x]==0||siz[y]&gt;siz[son[x]]) son[x]=y; &#125; &#125;&#125;inline void dfs2(int x,int tp)&#123; id[x]=++cnt; wt[cnt]=w[x]; top[x]=tp; if(!son[x]) return; dfs2(son[x],tp); for(int i=0;i&lt;e[x].size();i++) &#123; int y=e[x][i]; if(y!=fa[x]&amp;&amp;y!=son[x]) dfs2(y,y); &#125;&#125;inline void hld_sum(int x,int y,int a)&#123; ans.clear(); while(top[x]!=top[y]) &#123; if(dep[top[x]]&lt;dep[top[y]]) swap(x,y); seg_range_sum(id[top[x]],id[x],1); x=fa[top[x]]; &#125; if(dep[x]&gt;dep[y]) swap(x,y); seg_range_sum(id[x],id[y],1); PF("%d ",min(SZ(ans),a)); rep(i,min(SZ(ans),a)) PF("%d ",ans[i]); PF("\n");&#125;int main()&#123; SF("%d%d%d",&amp;n,&amp;m,&amp;q); for(int i=1;i&lt;n;i++) &#123; int x,y;SF("%d%d",&amp;x,&amp;y); e[x].push_back(y); e[y].push_back(x); &#125; rep1(i,m) &#123; int x;SF("%d",&amp;x); if(w[x].size()&lt;10) w[x].push_back(i); &#125; dfs1(1,0,1); dfs2(1,1); seg_build(1,n,1); while(q--) &#123; int u,v,a;SF("%d%d%d",&amp;u,&amp;v,&amp;a); hld_sum(u,v,a); &#125; return 0;&#125;/*************************************************************END**************************************************************/]]></content>
      <categories>
        <category>算法</category>
        <category>Codeforces</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>树链剖分</tag>
        <tag>LCA</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Codeforces 1238C Standard Free2play 题解]]></title>
    <url>%2F2019%2F10%2F21%2FCodeforces-1238C-Standard-Free2play-%E9%A2%98%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[Codeforces 1238C Standard Free2play 题解题意有一个高为$h (1\le h\le10^9)$的悬崖，在高度为$x(1\le x\le h)$的位置上，有一个可移动的平台。 每个平台有两种状态：隐藏在悬崖里 或 在悬崖外。一开始，有$n (1\le n\le\min(h,2\cdot10^5))$个在悬崖外的平台，分别为$p_1,p_2,\dots,p_n$，其中$p_1=h$。 你一开始站在$p_1$上，即在悬崖最高点$h$。若你站在高度为$x$的地方(高度为$x$的平台必须在悬崖外)，你可以按下一个按钮。如果你按下了按钮，那么高度为$x$和$x-1$的平台的状态会改变，即高度为$x$的平台隐藏到悬崖里，若高度为$x-1$的平台在悬崖里，则它移动到悬崖外；若它在悬崖外，则隐藏到悬崖里。如果按下按钮后，高度为$x-1$的平台在悬崖外，那么你安全地落在高度为$x-1$的平台上(否则你会掉落在下一个在悬崖外的平台上)。这是唯一一种方式从一个平台移动到另外一个平台。 你可以安全地从$x$掉落到$x-2$，但是如果从$x$掉落在$x-3$或更低处，你就死了。 你可以使用魔法。一次魔法只能使在任何高度的平台改变状态(除了高度为$h$的平台)。 求你使用魔法的最小次数，使得你安全地落在地上(即高度为$0$的地方)。 题解首先，若你在高度为$x$的平台上，下一个在悬崖外平台的高度为$y$且$x&gt;y+1$，那么你可以安全地、不使用任何魔法，从$x$到达$y+1$。 现在要考虑的是，你在高度为$x$的平台上，有多个连续的、在悬崖外的平台，设它们的高度为$q_1,q_2,\dots,q_n$且$q_1=x,\forall 1\le i&lt;n,q_i=q_{i+1}+1$。 若$n$为奇数，则可以安全地、不使用任何魔法，从$q_1$到达$q_n$(因为每次按下按钮，都只会掉下$2$格)。 若$n$为偶数，则需要一次魔法(如果不使用魔法，在$q_{n-1}$按下按钮时，会掉下$2$格以上)，把高度为$q_n+1$的平台移动到悬崖外。 注意，当$q_n=1$时，可以不需要魔法，直接掉落$2$格到地面。 程序123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214// #pragma GCC optimize(2)// #pragma G++ optimize(2)// #pragma comment(linker,"/STACK:102400000,102400000")// #include &lt;bits/stdc++.h&gt;#include &lt;map&gt;#include &lt;set&gt;#include &lt;list&gt;#include &lt;array&gt;#include &lt;cfenv&gt;#include &lt;cmath&gt;#include &lt;ctime&gt;#include &lt;deque&gt;#include &lt;mutex&gt;#include &lt;queue&gt;#include &lt;ratio&gt;#include &lt;regex&gt;#include &lt;stack&gt;#include &lt;tuple&gt;#include &lt;atomic&gt;#include &lt;bitset&gt;#include &lt;cctype&gt;#include &lt;cerrno&gt;#include &lt;cfloat&gt;#include &lt;chrono&gt;#include &lt;cstdio&gt;#include &lt;cwchar&gt;#include &lt;future&gt;#include &lt;limits&gt;#include &lt;locale&gt;#include &lt;memory&gt;#include &lt;random&gt;#include &lt;string&gt;#include &lt;thread&gt;#include &lt;vector&gt;#include &lt;cassert&gt;#include &lt;climits&gt;#include &lt;clocale&gt;#include &lt;complex&gt;#include &lt;csetjmp&gt;#include &lt;csignal&gt;#include &lt;cstdarg&gt;#include &lt;cstddef&gt;#include &lt;cstdint&gt;#include &lt;cstdlib&gt;#include &lt;cstring&gt;#include &lt;ctgmath&gt;#include &lt;cwctype&gt;#include &lt;fstream&gt;#include &lt;iomanip&gt;#include &lt;numeric&gt;#include &lt;sstream&gt;#include &lt;ccomplex&gt;#include &lt;cstdbool&gt;#include &lt;iostream&gt;#include &lt;typeinfo&gt;#include &lt;valarray&gt;#include &lt;algorithm&gt;#include &lt;cinttypes&gt;#include &lt;cstdalign&gt;#include &lt;stdexcept&gt;#include &lt;typeindex&gt;#include &lt;functional&gt;#include &lt;forward_list&gt;#include &lt;system_error&gt;#include &lt;unordered_map&gt;#include &lt;unordered_set&gt;#include &lt;scoped_allocator&gt;#include &lt;condition_variable&gt;// #include &lt;conio.h&gt;// #include &lt;windows.h&gt;using namespace std;typedef long long LL;typedef unsigned int ui;typedef unsigned long long ull;typedef float fl;typedef double ld;typedef long double LD;typedef pair&lt;int,int&gt; pii;#if (WIN32) || (WIN64) || (__WIN32) || (__WIN64) || (_WIN32) || (_WIN64) || (WINDOWS)#define lld "%I64d"#define llu "%I64u"#else#define lld "%lld"#define llu "%llu"#endif#define ui(n) ((unsigned int)(n))#define LL(n) ((long long)(n))#define ull(n) ((unsigned long long)(n))#define fl(n) ((float)(n))#define ld(n) ((double)(n))#define LD(n) ((long double)(n))#define char(n) ((char)(n))#define Bool(n) ((bool)(n))#define fixpoint(n) fixed&lt;&lt;setprecision(n)const int INF=1061109567;const int NINF=-1044266559;const LL LINF=4557430888798830399;const ld eps=1e-15;#define MOD (1000000007)#define PI (3.1415926535897932384626433832795028841971)/*#define MB_LEN_MAX 5#define SHRT_MIN (-32768)#define SHRT_MAX 32767#define USHRT_MAX 0xffffU#define INT_MIN (-2147483647 - 1)#define INT_MAX 2147483647#define UINT_MAX 0xffffffffU#define LONG_MIN (-2147483647L - 1)#define LONG_MAX 2147483647L#define ULONG_MAX 0xffffffffUL#define LLONG_MAX 9223372036854775807ll#define LLONG_MIN (-9223372036854775807ll - 1)#define ULLONG_MAX 0xffffffffffffffffull*/#define MP make_pair#define MT make_tuple#define All(a) (a).begin(),(a).end()#define pall(a) (a).rbegin(),(a).rend()#define Log(x,y) log(x)/log(y)#define SZ(a) ((int)(a).size())#define rep(i,n) for(int i=0;i&lt;((int)(n));i++)#define rep1(i,n) for(int i=1;i&lt;=((int)(n));i++)#define repa(i,a,n) for(int i=((int)(a));i&lt;((int)(n));i++)#define repa1(i,a,n) for(int i=((int)(a));i&lt;=((int)(n));i++)#define repd(i,n) for(int i=((int)(n))-1;i&gt;=0;i--)#define repd1(i,n) for(int i=((int)(n));i&gt;=1;i--)#define repda(i,n,a) for(int i=((int)(n));i&gt;((int)(a));i--)#define repda1(i,n,a) for(int i=((int)(n));i&gt;=((int)(a));i--)#define FOR(i,a,n,step) for(int i=((int)(a));i&lt;((int)(n));i+=((int)(step)))#define repv(itr,v) for(__typeof((v).begin()) itr=(v).begin();itr!=(v).end();itr++)#define repV(i,v) for(auto i:v)#define repE(i,v) for(auto &amp;i:v)#define MS(x,y) memset(x,y,sizeof(x))#define MC(x) MS(x,0)#define MINF(x) MS(x,63)#define MCP(x,y) memcpy(x,y,sizeof(y))#define sqr(x) ((x)*(x))#define UN(v) sort(All(v)),v.erase(unique(All(v)),v.end())#define filein(x) freopen(x,"r",stdin)#define fileout(x) freopen(x,"w",stdout)#define fileio(x)\ freopen(x".in","r",stdin);\ freopen(x".out","w",stdout)#define filein2(filename,name) ifstream name(filename,ios::in)#define fileout2(filename,name) ofstream name(filename,ios::out)#define file(filename,name) fstream name(filename,ios::in|ios::out)#define Pause system("pause")#define Cls system("cls")#define fs first#define sc second#define PC(x) putchar(x)#define GC(x) x=getchar()#define Endl PC('\n')#define SF scanf#define PF printf#define j0 J0#define j1 J1#define jn Jn#define y0 Y0#define y1 Y1#define yn Yninline int Read()&#123; int X=0,w=0;char ch=0;while(!isdigit(ch))&#123;w|=ch=='-';ch=getchar();&#125;while(isdigit(ch))X=(X&lt;&lt;3)+(X&lt;&lt;1)+(ch^48),ch=getchar(); return w?-X:X;&#125;inline void Write(int x)&#123;if(x&lt;0)putchar('-'),x=-x;if(x&gt;9)Write(x/10);putchar(x%10+'0');&#125;inline LL powmod(LL a,LL b)&#123;LL RES=1;a%=MOD;assert(b&gt;=0);for(;b;b&gt;&gt;=1)&#123;if(b&amp;1)RES=RES*a%MOD;a=a*a%MOD;&#125;return RES%MOD;&#125;inline LL gcdll(LL a,LL b)&#123;return b?gcdll(b,a%b):a;&#125;const int dx[]=&#123;0,1,0,-1,1,-1,-1,1&#125;;const int dy[]=&#123;1,0,-1,0,-1,-1,1,1&#125;;/************************************************************BEGIN************************************************************/const int maxn=200010;int q,h,n,p[maxn],ans;int main()&#123; SF("%d",&amp;q); while(q--) &#123; ans=0; SF("%d%d",&amp;h,&amp;n); rep(i,n) SF("%d",&amp;p[i]); rep(i,n) &#123; int cur=p[i],cnt=1; while(p[i]==p[i+1]+1&amp;&amp;i+1&lt;n) &#123; cnt++; i++; &#125; if((cur==h&amp;&amp;(cnt%2==0)||cur!=h&amp;&amp;(cnt%2==1))&amp;&amp;p[i]!=1) ans++; &#125; PF("%d\n",ans); &#125; return 0;&#125;/*************************************************************END**************************************************************/]]></content>
      <categories>
        <category>算法</category>
        <category>Codeforces</category>
      </categories>
      <tags>
        <tag>数学</tag>
        <tag>DP</tag>
        <tag>贪心</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Codeforces 1238D AB-string 题解]]></title>
    <url>%2F2019%2F10%2F21%2FCodeforces-1238D-AB-string-%E9%A2%98%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[Codeforces 1238D AB-string 题解题意一个字符串$s$如果 它的每一个字符都属于至少一个长度大于$1$的回文子串，那么称$s$是“好的”。如AABBB,ABAA,AAAAA是好的。 给定一个长度为$n (1\le n\le 3\cdot10^5)$的字符串$s$，求出$s$中好的子串的个数。 题解设一个字符串$t$由$t_1\dots t_n$组成，则$\forall 1&lt;i&lt;n$，$t_i$属于一个回文子串(默认长度大于$1$，以下同理)。 证明：设$i$满足$1&lt;i&lt;n$， 若$t_i=t_{i-1}$，则它属于回文串$t_{i-1}t_i$。 若$t_i=t_{i+1}$，则它属于回文串$t_it_{i+1}$。 若$t_i\neq t_{i-1},t_i\neq t_{i+1}$，那么$t_{i-1}=t_{i+1}$，则它属于回文串$t_{i-1}t_it_{i+1}$。 那么，只有当$i=1$或$i=n$时，$t_i$才有可能不属于一个回文子串。 下面考虑$t_1$不属于一个回文子串的情况。 $t_2\neq t_1$，否则$t_1$属于回文串$t_1t_2$。 $\forall i&gt;2$，$t_i\neq t_{i-1}$，否则$t_1$属于回文串$t_1\dots t_i$ $t_n$同理。 所以，$t$只有形如以下四种字符串时，$t$不是好的。 AB...B BA...A A...AB B...BA 给定$s$，求$s$中好的子串的个数，那么就可以转化为 所有子串-不是好的子串，即$\frac{n\times(n-1)}{2}-cnt$，$cnt$为不是好的子串。 显然，$cnt$可以$O(n)$求出。 程序123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206// #pragma GCC optimize(2)// #pragma G++ optimize(2)// #pragma comment(linker,"/STACK:102400000,102400000")// #include &lt;bits/stdc++.h&gt;#include &lt;map&gt;#include &lt;set&gt;#include &lt;list&gt;#include &lt;array&gt;#include &lt;cfenv&gt;#include &lt;cmath&gt;#include &lt;ctime&gt;#include &lt;deque&gt;#include &lt;mutex&gt;#include &lt;queue&gt;#include &lt;ratio&gt;#include &lt;regex&gt;#include &lt;stack&gt;#include &lt;tuple&gt;#include &lt;atomic&gt;#include &lt;bitset&gt;#include &lt;cctype&gt;#include &lt;cerrno&gt;#include &lt;cfloat&gt;#include &lt;chrono&gt;#include &lt;cstdio&gt;#include &lt;cwchar&gt;#include &lt;future&gt;#include &lt;limits&gt;#include &lt;locale&gt;#include &lt;memory&gt;#include &lt;random&gt;#include &lt;string&gt;#include &lt;thread&gt;#include &lt;vector&gt;#include &lt;cassert&gt;#include &lt;climits&gt;#include &lt;clocale&gt;#include &lt;complex&gt;#include &lt;csetjmp&gt;#include &lt;csignal&gt;#include &lt;cstdarg&gt;#include &lt;cstddef&gt;#include &lt;cstdint&gt;#include &lt;cstdlib&gt;#include &lt;cstring&gt;#include &lt;ctgmath&gt;#include &lt;cwctype&gt;#include &lt;fstream&gt;#include &lt;iomanip&gt;#include &lt;numeric&gt;#include &lt;sstream&gt;#include &lt;ccomplex&gt;#include &lt;cstdbool&gt;#include &lt;iostream&gt;#include &lt;typeinfo&gt;#include &lt;valarray&gt;#include &lt;algorithm&gt;#include &lt;cinttypes&gt;#include &lt;cstdalign&gt;#include &lt;stdexcept&gt;#include &lt;typeindex&gt;#include &lt;functional&gt;#include &lt;forward_list&gt;#include &lt;system_error&gt;#include &lt;unordered_map&gt;#include &lt;unordered_set&gt;#include &lt;scoped_allocator&gt;#include &lt;condition_variable&gt;// #include &lt;conio.h&gt;// #include &lt;windows.h&gt;using namespace std;typedef long long LL;typedef unsigned int ui;typedef unsigned long long ull;typedef float fl;typedef double ld;typedef long double LD;typedef pair&lt;int,int&gt; pii;#if (WIN32) || (WIN64) || (__WIN32) || (__WIN64) || (_WIN32) || (_WIN64) || (WINDOWS)#define lld "%I64d"#define llu "%I64u"#else#define lld "%lld"#define llu "%llu"#endif#define ui(n) ((unsigned int)(n))#define LL(n) ((long long)(n))#define ull(n) ((unsigned long long)(n))#define fl(n) ((float)(n))#define ld(n) ((double)(n))#define LD(n) ((long double)(n))#define char(n) ((char)(n))#define Bool(n) ((bool)(n))#define fixpoint(n) fixed&lt;&lt;setprecision(n)const int INF=1061109567;const int NINF=-1044266559;const LL LINF=4557430888798830399;const ld eps=1e-15;#define MOD (1000000007)#define PI (3.1415926535897932384626433832795028841971)/*#define MB_LEN_MAX 5#define SHRT_MIN (-32768)#define SHRT_MAX 32767#define USHRT_MAX 0xffffU#define INT_MIN (-2147483647 - 1)#define INT_MAX 2147483647#define UINT_MAX 0xffffffffU#define LONG_MIN (-2147483647L - 1)#define LONG_MAX 2147483647L#define ULONG_MAX 0xffffffffUL#define LLONG_MAX 9223372036854775807ll#define LLONG_MIN (-9223372036854775807ll - 1)#define ULLONG_MAX 0xffffffffffffffffull*/#define MP make_pair#define MT make_tuple#define All(a) (a).begin(),(a).end()#define pall(a) (a).rbegin(),(a).rend()#define Log(x,y) log(x)/log(y)#define SZ(a) ((int)(a).size())#define rep(i,n) for(int i=0;i&lt;((int)(n));i++)#define rep1(i,n) for(int i=1;i&lt;=((int)(n));i++)#define repa(i,a,n) for(int i=((int)(a));i&lt;((int)(n));i++)#define repa1(i,a,n) for(int i=((int)(a));i&lt;=((int)(n));i++)#define repd(i,n) for(int i=((int)(n))-1;i&gt;=0;i--)#define repd1(i,n) for(int i=((int)(n));i&gt;=1;i--)#define repda(i,n,a) for(int i=((int)(n));i&gt;((int)(a));i--)#define repda1(i,n,a) for(int i=((int)(n));i&gt;=((int)(a));i--)#define FOR(i,a,n,step) for(int i=((int)(a));i&lt;((int)(n));i+=((int)(step)))#define repv(itr,v) for(__typeof((v).begin()) itr=(v).begin();itr!=(v).end();itr++)#define repV(i,v) for(auto i:v)#define repE(i,v) for(auto &amp;i:v)#define MS(x,y) memset(x,y,sizeof(x))#define MC(x) MS(x,0)#define MINF(x) MS(x,63)#define MCP(x,y) memcpy(x,y,sizeof(y))#define sqr(x) ((x)*(x))#define UN(v) sort(All(v)),v.erase(unique(All(v)),v.end())#define filein(x) freopen(x,"r",stdin)#define fileout(x) freopen(x,"w",stdout)#define fileio(x)\ freopen(x".in","r",stdin);\ freopen(x".out","w",stdout)#define filein2(filename,name) ifstream name(filename,ios::in)#define fileout2(filename,name) ofstream name(filename,ios::out)#define file(filename,name) fstream name(filename,ios::in|ios::out)#define Pause system("pause")#define Cls system("cls")#define fs first#define sc second#define PC(x) putchar(x)#define GC(x) x=getchar()#define Endl PC('\n')#define SF scanf#define PF printf#define j0 J0#define j1 J1#define jn Jn#define y0 Y0#define y1 Y1#define yn Yninline int Read()&#123; int X=0,w=0;char ch=0;while(!isdigit(ch))&#123;w|=ch=='-';ch=getchar();&#125;while(isdigit(ch))X=(X&lt;&lt;3)+(X&lt;&lt;1)+(ch^48),ch=getchar(); return w?-X:X;&#125;inline void Write(int x)&#123;if(x&lt;0)putchar('-'),x=-x;if(x&gt;9)Write(x/10);putchar(x%10+'0');&#125;inline LL powmod(LL a,LL b)&#123;LL RES=1;a%=MOD;assert(b&gt;=0);for(;b;b&gt;&gt;=1)&#123;if(b&amp;1)RES=RES*a%MOD;a=a*a%MOD;&#125;return RES%MOD;&#125;inline LL gcdll(LL a,LL b)&#123;return b?gcdll(b,a%b):a;&#125;const int dx[]=&#123;0,1,0,-1,1,-1,-1,1&#125;;const int dy[]=&#123;1,0,-1,0,-1,-1,1,1&#125;;/************************************************************BEGIN************************************************************/const int maxn=300010;int n;string s;LL ans;int main()&#123; cin&gt;&gt;n&gt;&gt;s; ans=1ll*n*(n-1)/2; rep(i,n) &#123; for(int j=i+1;j&lt;n;j++) if(s[j]!=s[i]) ans-=(j==i+1?0:1); else break; &#125; repd(i,n) &#123; for(int j=i-1;j&gt;=0;j--) if(s[j]!=s[i]) ans--; else break; &#125; PF("%lld",ans); return 0;&#125;/*************************************************************END**************************************************************/ Tip: 这个程序看似是$O(n^2)$的，实际上是$O(n)$的。这里不再赘述。]]></content>
      <categories>
        <category>算法</category>
        <category>Codeforces</category>
      </categories>
      <tags>
        <tag>二分</tag>
        <tag>构造</tag>
        <tag>DP</tag>
        <tag>字符串</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Codeforces 343C Read Time 题解]]></title>
    <url>%2F2019%2F10%2F15%2FCodeforces-343C-Read-Time-%E9%A2%98%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[Codeforces 343C Read Time 题解题意在一个无限长的线性磁盘上，有$n$个独立的磁头和$m$个需读取的位置$(1\le n,m\le 10^5)$，第$i$个磁头的初始位置为$h_i (1\le h_i\le 10^{10},h_i&lt;h_{i+1})$，第$j$个需读取位置为$p_j (1\le p_j\le 10^{10},p_j&lt;p_{j+1})$，需读取的位置互不相同的。 每一个磁头可以花一个单位时间移动到左边或右边的位置，也可以不动。可以有多个磁头在同一位置。每个磁头可以读取无限多个位置。一个位置被至少一个磁头走过后，它就被读取了。特别，一开始时，$h_i (1\le i\le n)$的位置就被读取过了。 求读取所有需读取位置需要的最少时间。 题解考虑二分需要的时间。 对于check(time)函数，每个磁头都有time单位个时间。 设当前考虑的磁头为第$i$个磁头，设$pos$为 第$i-1$个磁头没有完成的最左边的需读取位置，那么它要在读取$pos$后，尽可能地多读取位置。 确定尽可能向后读取的位置有两种，设走到$pos$后，还剩$r$个单位时间。 先走到$pos$，再用$r$个时间尽可能地多读取位置。 先用$\frac{r}{2}$个时间尽可能地多读取位置(用$\frac{r}{2}$个时间走回来)，再走到$pos$。 在$p$中upper_bound(MAX)后，就可以找到第$i$个磁头没有完成的最左边的需读取位置了。 所以check函数的时间复杂度是$O(n\log n)$。 Tip: 还有一种方法可以使check函数的时间复杂度是$O(n)$，具体不再赘述。 程序123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222// #pragma GCC optimize(2)// #pragma G++ optimize(2)// #pragma comment(linker,"/STACK:102400000,102400000")// #include &lt;bits/stdc++.h&gt;#include &lt;map&gt;#include &lt;set&gt;#include &lt;list&gt;#include &lt;array&gt;#include &lt;cfenv&gt;#include &lt;cmath&gt;#include &lt;ctime&gt;#include &lt;deque&gt;#include &lt;mutex&gt;#include &lt;queue&gt;#include &lt;ratio&gt;#include &lt;regex&gt;#include &lt;stack&gt;#include &lt;tuple&gt;#include &lt;atomic&gt;#include &lt;bitset&gt;#include &lt;cctype&gt;#include &lt;cerrno&gt;#include &lt;cfloat&gt;#include &lt;chrono&gt;#include &lt;cstdio&gt;#include &lt;cwchar&gt;#include &lt;future&gt;#include &lt;limits&gt;#include &lt;locale&gt;#include &lt;memory&gt;#include &lt;random&gt;#include &lt;string&gt;#include &lt;thread&gt;#include &lt;vector&gt;#include &lt;cassert&gt;#include &lt;climits&gt;#include &lt;clocale&gt;#include &lt;complex&gt;#include &lt;csetjmp&gt;#include &lt;csignal&gt;#include &lt;cstdarg&gt;#include &lt;cstddef&gt;#include &lt;cstdint&gt;#include &lt;cstdlib&gt;#include &lt;cstring&gt;#include &lt;ctgmath&gt;#include &lt;cwctype&gt;#include &lt;fstream&gt;#include &lt;iomanip&gt;#include &lt;numeric&gt;#include &lt;sstream&gt;#include &lt;ccomplex&gt;#include &lt;cstdbool&gt;#include &lt;iostream&gt;#include &lt;typeinfo&gt;#include &lt;valarray&gt;#include &lt;algorithm&gt;#include &lt;cinttypes&gt;#include &lt;cstdalign&gt;#include &lt;stdexcept&gt;#include &lt;typeindex&gt;#include &lt;functional&gt;#include &lt;forward_list&gt;#include &lt;system_error&gt;#include &lt;unordered_map&gt;#include &lt;unordered_set&gt;#include &lt;scoped_allocator&gt;#include &lt;condition_variable&gt;// #include &lt;conio.h&gt;// #include &lt;windows.h&gt;using namespace std;typedef long long LL;typedef unsigned int ui;typedef unsigned long long ull;typedef float fl;typedef double ld;typedef long double LD;typedef pair&lt;int,int&gt; pii;#if (WIN32) || (WIN64) || (__WIN32) || (__WIN64) || (_WIN32) || (_WIN64) || (WINDOWS)#define lld "%I64d"#define llu "%I64u"#else#define lld "%lld"#define llu "%llu"#endif#define ui(n) ((unsigned int)(n))#define LL(n) ((long long)(n))#define ull(n) ((unsigned long long)(n))#define fl(n) ((float)(n))#define ld(n) ((double)(n))#define LD(n) ((long double)(n))#define char(n) ((char)(n))#define Bool(n) ((bool)(n))#define fixpoint(n) fixed&lt;&lt;setprecision(n)const int INF=1061109567;const int NINF=-1044266559;const LL LINF=4557430888798830399;const ld eps=1e-15;#define MOD (1000000007)#define PI (3.1415926535897932384626433832795028841971)/*#define MB_LEN_MAX 5#define SHRT_MIN (-32768)#define SHRT_MAX 32767#define USHRT_MAX 0xffffU#define INT_MIN (-2147483647 - 1)#define INT_MAX 2147483647#define UINT_MAX 0xffffffffU#define LONG_MIN (-2147483647L - 1)#define LONG_MAX 2147483647L#define ULONG_MAX 0xffffffffUL#define LLONG_MAX 9223372036854775807ll#define LLONG_MIN (-9223372036854775807ll - 1)#define ULLONG_MAX 0xffffffffffffffffull*/#define MP make_pair#define MT make_tuple#define All(a) (a).begin(),(a).end()#define pall(a) (a).rbegin(),(a).rend()#define Log(x,y) log(x)/log(y)#define SZ(a) ((int)(a).size())#define rep(i,n) for(int i=0;i&lt;((int)(n));i++)#define rep1(i,n) for(int i=1;i&lt;=((int)(n));i++)#define repa(i,a,n) for(int i=((int)(a));i&lt;((int)(n));i++)#define repa1(i,a,n) for(int i=((int)(a));i&lt;=((int)(n));i++)#define repd(i,n) for(int i=((int)(n))-1;i&gt;=0;i--)#define repd1(i,n) for(int i=((int)(n));i&gt;=1;i--)#define repda(i,n,a) for(int i=((int)(n));i&gt;((int)(a));i--)#define repda1(i,n,a) for(int i=((int)(n));i&gt;=((int)(a));i--)#define FOR(i,a,n,step) for(int i=((int)(a));i&lt;((int)(n));i+=((int)(step)))#define repv(itr,v) for(__typeof((v).begin()) itr=(v).begin();itr!=(v).end();itr++)#define repV(i,v) for(auto i:v)#define repE(i,v) for(auto &amp;i:v)#define MS(x,y) memset(x,y,sizeof(x))#define MC(x) MS(x,0)#define MINF(x) MS(x,63)#define MCP(x,y) memcpy(x,y,sizeof(y))#define sqr(x) ((x)*(x))#define UN(v) sort(All(v)),v.erase(unique(All(v)),v.end())#define filein(x) freopen(x,"r",stdin)#define fileout(x) freopen(x,"w",stdout)#define fileio(x)\ freopen(x".in","r",stdin);\ freopen(x".out","w",stdout)#define filein2(filename,name) ifstream name(filename,ios::in)#define fileout2(filename,name) ofstream name(filename,ios::out)#define file(filename,name) fstream name(filename,ios::in|ios::out)#define Pause system("pause")#define Cls system("cls")#define fs first#define sc second#define PC(x) putchar(x)#define GC(x) x=getchar()#define Endl PC('\n')#define SF scanf#define PF printf#define j0 J0#define j1 J1#define jn Jn#define y0 Y0#define y1 Y1#define yn Yninline int Read()&#123; int X=0,w=0;char ch=0;while(!isdigit(ch))&#123;w|=ch=='-';ch=getchar();&#125;while(isdigit(ch))X=(X&lt;&lt;3)+(X&lt;&lt;1)+(ch^48),ch=getchar(); return w?-X:X;&#125;inline void Write(int x)&#123;if(x&lt;0)putchar('-'),x=-x;if(x&gt;9)Write(x/10);putchar(x%10+'0');&#125;inline LL powmod(LL a,LL b)&#123;LL RES=1;a%=MOD;assert(b&gt;=0);for(;b;b&gt;&gt;=1)&#123;if(b&amp;1)RES=RES*a%MOD;a=a*a%MOD;&#125;return RES%MOD;&#125;inline LL gcdll(LL a,LL b)&#123;return b?gcdll(b,a%b):a;&#125;const int dx[]=&#123;0,1,0,-1,1,-1,-1,1&#125;;const int dy[]=&#123;1,0,-1,0,-1,-1,1,1&#125;;/************************************************************BEGIN************************************************************/const int maxn=100010;int n,m;LL h[maxn],p[maxn];inline int check(LL x)&#123; int pos=1; rep1(i,n) &#123; LL rem=x-abs(h[i]-p[pos]); if(rem&lt;0) continue; pos=upper_bound(p+1,p+m+1,max(p[pos]+rem,h[i]+rem/2))-p; // max(go to read `pos`-&gt;go to read as more as possible tracks , \ go to read as more as possible tracks-&gt;go to read `pos`) if(pos==m+1) return 1; &#125; return 0;&#125;int main()&#123; SF("%d%d",&amp;n,&amp;m); rep1(i,n) SF("%lld",&amp;h[i]); rep1(i,m) SF("%lld",&amp;p[i]); LL l=0,r=1e18; // [l,r) while(l&lt;r) &#123; LL mid=(l+r)/2; if(check(mid)) r=mid; else l=mid+1; &#125; PF("%lld",r); return 0;&#125;/*************************************************************END**************************************************************/]]></content>
      <categories>
        <category>算法</category>
        <category>Codeforces</category>
      </categories>
      <tags>
        <tag>二分</tag>
        <tag>双指针</tag>
        <tag>贪心</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Codeforces 343B Alternating Current 题解]]></title>
    <url>%2F2019%2F10%2F15%2FCodeforces-343B-Alternating-Current-%E9%A2%98%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[Codeforces 343B Alternating Current 题解题意有两根长度为$n (1\le n\le 10^5)$个单位，两头固定的电线，它们缠绕在一起，给定一个长为$n$，由+和-组成的字符串$s$，其中 若$s_i$为+，则在第$i$个单位长度时，第一根电线在第二根电线上。 若$s_i$为-，则在第$i$个单位长度时，第二根电线在第一根电线上。 求不拔出电线且不移动装置时，是否能解开它们。若可以，输出Yes；否则输出No。 题解根据题意知道：若两个+或两个-连在一起时，则那两个单位长度可以解开。 那么如果删去了所有的++和--后，字符串为空，则可以解开；否则不可以。 因为$1\le n\le 10^5$，所以程序的时间复杂度不能是$O(n^2)$，在字符串中暴力删除肯定不行。 考虑$O(n)$的做法。若当前长度为$i$，字符$s_i (0&lt;i\le n)$等于$s_{i-1}$，则使$i=i-2$。这样删去后 后面的字符也可以和前面的字符配成++或--，符合题目要求。判断有没有删完即可。 使用stack可以使程序更简洁。 程序123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195// #pragma GCC optimize(2)// #pragma G++ optimize(2)// #pragma comment(linker,"/STACK:102400000,102400000")// #include &lt;bits/stdc++.h&gt;#include &lt;map&gt;#include &lt;set&gt;#include &lt;list&gt;#include &lt;array&gt;#include &lt;cfenv&gt;#include &lt;cmath&gt;#include &lt;ctime&gt;#include &lt;deque&gt;#include &lt;mutex&gt;#include &lt;queue&gt;#include &lt;ratio&gt;#include &lt;regex&gt;#include &lt;stack&gt;#include &lt;tuple&gt;#include &lt;atomic&gt;#include &lt;bitset&gt;#include &lt;cctype&gt;#include &lt;cerrno&gt;#include &lt;cfloat&gt;#include &lt;chrono&gt;#include &lt;cstdio&gt;#include &lt;cwchar&gt;#include &lt;future&gt;#include &lt;limits&gt;#include &lt;locale&gt;#include &lt;memory&gt;#include &lt;random&gt;#include &lt;string&gt;#include &lt;thread&gt;#include &lt;vector&gt;#include &lt;cassert&gt;#include &lt;climits&gt;#include &lt;clocale&gt;#include &lt;complex&gt;#include &lt;csetjmp&gt;#include &lt;csignal&gt;#include &lt;cstdarg&gt;#include &lt;cstddef&gt;#include &lt;cstdint&gt;#include &lt;cstdlib&gt;#include &lt;cstring&gt;#include &lt;ctgmath&gt;#include &lt;cwctype&gt;#include &lt;fstream&gt;#include &lt;iomanip&gt;#include &lt;numeric&gt;#include &lt;sstream&gt;#include &lt;ccomplex&gt;#include &lt;cstdbool&gt;#include &lt;iostream&gt;#include &lt;typeinfo&gt;#include &lt;valarray&gt;#include &lt;algorithm&gt;#include &lt;cinttypes&gt;#include &lt;cstdalign&gt;#include &lt;stdexcept&gt;#include &lt;typeindex&gt;#include &lt;functional&gt;#include &lt;forward_list&gt;#include &lt;system_error&gt;#include &lt;unordered_map&gt;#include &lt;unordered_set&gt;#include &lt;scoped_allocator&gt;#include &lt;condition_variable&gt;// #include &lt;conio.h&gt;// #include &lt;windows.h&gt;using namespace std;typedef long long LL;typedef unsigned int ui;typedef unsigned long long ull;typedef float fl;typedef double ld;typedef long double LD;typedef pair&lt;int,int&gt; pii;#if (WIN32) || (WIN64) || (__WIN32) || (__WIN64) || (_WIN32) || (_WIN64) || (WINDOWS)#define lld "%I64d"#define llu "%I64u"#else#define lld "%lld"#define llu "%llu"#endif#define ui(n) ((unsigned int)(n))#define LL(n) ((long long)(n))#define ull(n) ((unsigned long long)(n))#define fl(n) ((float)(n))#define ld(n) ((double)(n))#define LD(n) ((long double)(n))#define char(n) ((char)(n))#define Bool(n) ((bool)(n))#define fixpoint(n) fixed&lt;&lt;setprecision(n)const int INF=1061109567;const int NINF=-1044266559;const LL LINF=4557430888798830399;const ld eps=1e-15;#define MOD (1000000007)#define PI (3.1415926535897932384626433832795028841971)/*#define MB_LEN_MAX 5#define SHRT_MIN (-32768)#define SHRT_MAX 32767#define USHRT_MAX 0xffffU#define INT_MIN (-2147483647 - 1)#define INT_MAX 2147483647#define UINT_MAX 0xffffffffU#define LONG_MIN (-2147483647L - 1)#define LONG_MAX 2147483647L#define ULONG_MAX 0xffffffffUL#define LLONG_MAX 9223372036854775807ll#define LLONG_MIN (-9223372036854775807ll - 1)#define ULLONG_MAX 0xffffffffffffffffull*/#define MP make_pair#define MT make_tuple#define All(a) (a).begin(),(a).end()#define pall(a) (a).rbegin(),(a).rend()#define Log(x,y) log(x)/log(y)#define SZ(a) ((int)(a).size())#define rep(i,n) for(int i=0;i&lt;((int)(n));i++)#define rep1(i,n) for(int i=1;i&lt;=((int)(n));i++)#define repa(i,a,n) for(int i=((int)(a));i&lt;((int)(n));i++)#define repa1(i,a,n) for(int i=((int)(a));i&lt;=((int)(n));i++)#define repd(i,n) for(int i=((int)(n))-1;i&gt;=0;i--)#define repd1(i,n) for(int i=((int)(n));i&gt;=1;i--)#define repda(i,n,a) for(int i=((int)(n));i&gt;((int)(a));i--)#define repda1(i,n,a) for(int i=((int)(n));i&gt;=((int)(a));i--)#define FOR(i,a,n,step) for(int i=((int)(a));i&lt;((int)(n));i+=((int)(step)))#define repv(itr,v) for(__typeof((v).begin()) itr=(v).begin();itr!=(v).end();itr++)#define repV(i,v) for(auto i:v)#define repE(i,v) for(auto &amp;i:v)#define MS(x,y) memset(x,y,sizeof(x))#define MC(x) MS(x,0)#define MINF(x) MS(x,63)#define MCP(x,y) memcpy(x,y,sizeof(y))#define sqr(x) ((x)*(x))#define UN(v) sort(All(v)),v.erase(unique(All(v)),v.end())#define filein(x) freopen(x,"r",stdin)#define fileout(x) freopen(x,"w",stdout)#define fileio(x)\ freopen(x".in","r",stdin);\ freopen(x".out","w",stdout)#define filein2(filename,name) ifstream name(filename,ios::in)#define fileout2(filename,name) ofstream name(filename,ios::out)#define file(filename,name) fstream name(filename,ios::in|ios::out)#define Pause system("pause")#define Cls system("cls")#define fs first#define sc second#define PC(x) putchar(x)#define GC(x) x=getchar()#define Endl PC('\n')#define SF scanf#define PF printf#define j0 J0#define j1 J1#define jn Jn#define y0 Y0#define y1 Y1#define yn Yninline int Read()&#123; int X=0,w=0;char ch=0;while(!isdigit(ch))&#123;w|=ch=='-';ch=getchar();&#125;while(isdigit(ch))X=(X&lt;&lt;3)+(X&lt;&lt;1)+(ch^48),ch=getchar(); return w?-X:X;&#125;inline void Write(int x)&#123;if(x&lt;0)putchar('-'),x=-x;if(x&gt;9)Write(x/10);putchar(x%10+'0');&#125;inline LL powmod(LL a,LL b)&#123;LL RES=1;a%=MOD;assert(b&gt;=0);for(;b;b&gt;&gt;=1)&#123;if(b&amp;1)RES=RES*a%MOD;a=a*a%MOD;&#125;return RES%MOD;&#125;inline LL gcdll(LL a,LL b)&#123;return b?gcdll(b,a%b):a;&#125;const int dx[]=&#123;0,1,0,-1,1,-1,-1,1&#125;;const int dy[]=&#123;1,0,-1,0,-1,-1,1,1&#125;;/************************************************************BEGIN************************************************************/const int maxn=100010;string s;stack&lt;char&gt; sta;int main()&#123; cin&gt;&gt;s; repV(i,s) if(!sta.empty()&amp;&amp;sta.top()==i) sta.pop(); else sta.push(i); cout&lt;&lt;(sta.empty()?"Yes":"No"); return 0;&#125;/*************************************************************END**************************************************************/]]></content>
      <categories>
        <category>算法</category>
        <category>Codeforces</category>
      </categories>
      <tags>
        <tag>贪心</tag>
        <tag>数据结构</tag>
        <tag>模拟</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Codeforces 343A Rational Resistance 题解]]></title>
    <url>%2F2019%2F10%2F15%2FCodeforces-343A-Rational-Resistance-%E9%A2%98%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[Codeforces 343A Rational Resistance 题解题意你有很多个电阻器，一个电阻器$R_0$的电阻是$1$。 设一个电阻元件的电阻为$R$，可以由以下三种方式得到一个电阻元件 一个电阻器，则$R=R_0$。 一个电阻元件(电阻为$R_e$)串联一个电阻器，则$R=R_e+R_0$。 一个电阻元件(电阻为$R_e$)并联一个电阻器，则$R=\frac{1}{\frac{1}{R_e}+\frac{1}{R_0}}$。 给定一个最简分数$\frac{a}{b} (1\le a,b\le 10^{18})$，求至少要多少个电阻器 使得 得到的电阻元件的电阻为$\frac{a}{b}$。 题解设有一个电阻元件的电阻为$\frac{x}{y}$。 串联后电阻为$\frac{x}{y}+1=\frac{x+y}{y}$。 并联后电阻为$\frac{1}{\frac{1}{\frac{x}{y}}+1}=\frac{x}{x+y}$。 那么 若$x&gt;y$，则$\frac{x}{y}$是由$\frac{x-y}{y}$ 串联得出的。 若$x&lt;y$，则$\frac{x}{y}$是由$\frac{x}{y-x}$ 并联得出的。 这样用大的数减小的数，就是辗转相减法，每减一次，答案加$1$。 但是数据范围太大，可以把辗转相减法转换成辗转相除法，每除一次，答案加 大数整除小数的结果。 程序123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204// #pragma GCC optimize(2)// #pragma G++ optimize(2)// #pragma comment(linker,"/STACK:102400000,102400000")// #include &lt;bits/stdc++.h&gt;#include &lt;map&gt;#include &lt;set&gt;#include &lt;list&gt;#include &lt;array&gt;#include &lt;cfenv&gt;#include &lt;cmath&gt;#include &lt;ctime&gt;#include &lt;deque&gt;#include &lt;mutex&gt;#include &lt;queue&gt;#include &lt;ratio&gt;#include &lt;regex&gt;#include &lt;stack&gt;#include &lt;tuple&gt;#include &lt;atomic&gt;#include &lt;bitset&gt;#include &lt;cctype&gt;#include &lt;cerrno&gt;#include &lt;cfloat&gt;#include &lt;chrono&gt;#include &lt;cstdio&gt;#include &lt;cwchar&gt;#include &lt;future&gt;#include &lt;limits&gt;#include &lt;locale&gt;#include &lt;memory&gt;#include &lt;random&gt;#include &lt;string&gt;#include &lt;thread&gt;#include &lt;vector&gt;#include &lt;cassert&gt;#include &lt;climits&gt;#include &lt;clocale&gt;#include &lt;complex&gt;#include &lt;csetjmp&gt;#include &lt;csignal&gt;#include &lt;cstdarg&gt;#include &lt;cstddef&gt;#include &lt;cstdint&gt;#include &lt;cstdlib&gt;#include &lt;cstring&gt;#include &lt;ctgmath&gt;#include &lt;cwctype&gt;#include &lt;fstream&gt;#include &lt;iomanip&gt;#include &lt;numeric&gt;#include &lt;sstream&gt;#include &lt;ccomplex&gt;#include &lt;cstdbool&gt;#include &lt;iostream&gt;#include &lt;typeinfo&gt;#include &lt;valarray&gt;#include &lt;algorithm&gt;#include &lt;cinttypes&gt;#include &lt;cstdalign&gt;#include &lt;stdexcept&gt;#include &lt;typeindex&gt;#include &lt;functional&gt;#include &lt;forward_list&gt;#include &lt;system_error&gt;#include &lt;unordered_map&gt;#include &lt;unordered_set&gt;#include &lt;scoped_allocator&gt;#include &lt;condition_variable&gt;// #include &lt;conio.h&gt;// #include &lt;windows.h&gt;using namespace std;typedef long long LL;typedef unsigned int ui;typedef unsigned long long ull;typedef float fl;typedef double ld;typedef long double LD;typedef pair&lt;int,int&gt; pii;#if (WIN32) || (WIN64) || (__WIN32) || (__WIN64) || (_WIN32) || (_WIN64) || (WINDOWS)#define lld "%I64d"#define llu "%I64u"#else#define lld "%lld"#define llu "%llu"#endif#define ui(n) ((unsigned int)(n))#define LL(n) ((long long)(n))#define ull(n) ((unsigned long long)(n))#define fl(n) ((float)(n))#define ld(n) ((double)(n))#define LD(n) ((long double)(n))#define char(n) ((char)(n))#define Bool(n) ((bool)(n))#define fixpoint(n) fixed&lt;&lt;setprecision(n)const int INF=1061109567;const int NINF=-1044266559;const LL LINF=4557430888798830399;const ld eps=1e-15;#define MOD (1000000007)#define PI (3.1415926535897932384626433832795028841971)/*#define MB_LEN_MAX 5#define SHRT_MIN (-32768)#define SHRT_MAX 32767#define USHRT_MAX 0xffffU#define INT_MIN (-2147483647 - 1)#define INT_MAX 2147483647#define UINT_MAX 0xffffffffU#define LONG_MIN (-2147483647L - 1)#define LONG_MAX 2147483647L#define ULONG_MAX 0xffffffffUL#define LLONG_MAX 9223372036854775807ll#define LLONG_MIN (-9223372036854775807ll - 1)#define ULLONG_MAX 0xffffffffffffffffull*/#define MP make_pair#define MT make_tuple#define All(a) (a).begin(),(a).end()#define pall(a) (a).rbegin(),(a).rend()#define Log(x,y) log(x)/log(y)#define SZ(a) ((int)(a).size())#define rep(i,n) for(int i=0;i&lt;((int)(n));i++)#define rep1(i,n) for(int i=1;i&lt;=((int)(n));i++)#define repa(i,a,n) for(int i=((int)(a));i&lt;((int)(n));i++)#define repa1(i,a,n) for(int i=((int)(a));i&lt;=((int)(n));i++)#define repd(i,n) for(int i=((int)(n))-1;i&gt;=0;i--)#define repd1(i,n) for(int i=((int)(n));i&gt;=1;i--)#define repda(i,n,a) for(int i=((int)(n));i&gt;((int)(a));i--)#define repda1(i,n,a) for(int i=((int)(n));i&gt;=((int)(a));i--)#define FOR(i,a,n,step) for(int i=((int)(a));i&lt;((int)(n));i+=((int)(step)))#define repv(itr,v) for(__typeof((v).begin()) itr=(v).begin();itr!=(v).end();itr++)#define repV(i,v) for(auto i:v)#define repE(i,v) for(auto &amp;i:v)#define MS(x,y) memset(x,y,sizeof(x))#define MC(x) MS(x,0)#define MINF(x) MS(x,63)#define MCP(x,y) memcpy(x,y,sizeof(y))#define sqr(x) ((x)*(x))#define UN(v) sort(All(v)),v.erase(unique(All(v)),v.end())#define filein(x) freopen(x,"r",stdin)#define fileout(x) freopen(x,"w",stdout)#define fileio(x)\ freopen(x".in","r",stdin);\ freopen(x".out","w",stdout)#define filein2(filename,name) ifstream name(filename,ios::in)#define fileout2(filename,name) ofstream name(filename,ios::out)#define file(filename,name) fstream name(filename,ios::in|ios::out)#define Pause system("pause")#define Cls system("cls")#define fs first#define sc second#define PC(x) putchar(x)#define GC(x) x=getchar()#define Endl PC('\n')#define SF scanf#define PF printf#define j0 J0#define j1 J1#define jn Jn#define y0 Y0#define y1 Y1#define yn Yninline int Read()&#123; int X=0,w=0;char ch=0;while(!isdigit(ch))&#123;w|=ch=='-';ch=getchar();&#125;while(isdigit(ch))X=(X&lt;&lt;3)+(X&lt;&lt;1)+(ch^48),ch=getchar(); return w?-X:X;&#125;inline void Write(int x)&#123;if(x&lt;0)putchar('-'),x=-x;if(x&gt;9)Write(x/10);putchar(x%10+'0');&#125;inline LL powmod(LL a,LL b)&#123;LL RES=1;a%=MOD;assert(b&gt;=0);for(;b;b&gt;&gt;=1)&#123;if(b&amp;1)RES=RES*a%MOD;a=a*a%MOD;&#125;return RES%MOD;&#125;inline LL gcdll(LL a,LL b)&#123;return b?gcdll(b,a%b):a;&#125;const int dx[]=&#123;0,1,0,-1,1,-1,-1,1&#125;;const int dy[]=&#123;1,0,-1,0,-1,-1,1,1&#125;;/************************************************************BEGIN************************************************************/const int maxn=INF;LL ans;inline void sol(LL a,LL b)&#123; if(!b) return; ans+=a/b; sol(b,a%b);&#125;int main()&#123; LL a,b; SF("%lld%lld",&amp;a,&amp;b); sol(a,b); PF("%lld",ans); return 0;&#125;/*************************************************************END**************************************************************/]]></content>
      <categories>
        <category>算法</category>
        <category>Codeforces</category>
      </categories>
      <tags>
        <tag>数论</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Codeforces 1228F One Node is Gone 题解]]></title>
    <url>%2F2019%2F10%2F02%2FCodeforces-1228F-One-Node-is-Gone-%E9%A2%98%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[Codeforces 1228F One Node is Gone 题解题意给定$n (1\le n\le17)$，定义McDic’s generation为 建一个有$2^n-1$个结点的满二叉树 从这个二叉树中选择一个非根结点$v$ 把$v$从树中删除，从$v$的父亲到$v$的儿子连边，如果$v$没有儿子，那么就不连边。 现在给定一棵树，判断这棵树是否可以经过McDic’s generation一次得到。如果可以，输出被删除的结点的父亲。 题解首先，要找到这棵树的根。我们知道，一棵满二叉树的根结点在它的直径的中间，而删除一个结点后，根在直径的位置可能会偏移$1$个，为了保险，可以假设它偏移了$2$个位置。把这$5$个结点当作根，进行DFS。 设当前点为$x$，$cnt$为$x$的儿子个数，DFS(x)的返回值为一个pair&lt;int,int&gt;，其中： 如果以$x$为根的子树非法，返回{0,-1} 如果以$x$为根的子树为一个满二叉树，返回{1,x离叶子结点的距离} 如果被删除的结点在以$x$为根的子树内，返回{2,x离叶子结点的距离} 很容易知道，如果cnt&gt;3，则返回{0,-1}；如果cnt=0，则它是叶子结点，返回{1,0}。 如果$x$不为以上两种情况，DFS它的儿子$y$，设DFS(y)的返回值为$got$ 如果got.first=0，则以$x$为根的子树也非法，返回{0,-1} 如果got.first=1，则把got.second存入vector&lt;int&gt; valid 如果got.first=2，则把got.second存入vector&lt;int&gt; spec 如果spec.size()&gt;=2，显然非法，返回{0,-1} 对valid排序。 如果cnt=1，说明被删除的结点是它的叶子结点， 如果valid.size()=1且valid[0]=0，合法，存储答案并返回2,1 否则返回{0,-1} 如果cnt=2， 如果valid.size()=2且valid[0]=valid[1]，说明它是一个正常的满二叉树，返回{1,valid[0]+1} 如果valid.size()=1且valid[0]=spec[0]，说明被删除的结点在它的其中一个子树中，返回{2,valid[0]+1} 否则返回{0,-1} 如果cnt=3， 如果valid.size()=3且valid[0]=valid[1]且valid[1]+1=valid[2]，说明它的其中一个儿子被删除了，返回{2,valid[2]+1} 否则返回{0,-1} 程序123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268// #pragma GCC optimize(2)// #pragma G++ optimize(2)// #pragma comment(linker,"/STACK:102400000,102400000")// #include &lt;bits/stdc++.h&gt;#include &lt;map&gt;#include &lt;set&gt;#include &lt;list&gt;#include &lt;array&gt;#include &lt;cfenv&gt;#include &lt;cmath&gt;#include &lt;ctime&gt;#include &lt;deque&gt;#include &lt;mutex&gt;#include &lt;queue&gt;#include &lt;ratio&gt;#include &lt;regex&gt;#include &lt;stack&gt;#include &lt;tuple&gt;#include &lt;atomic&gt;#include &lt;bitset&gt;#include &lt;cctype&gt;#include &lt;cerrno&gt;#include &lt;cfloat&gt;#include &lt;chrono&gt;#include &lt;cstdio&gt;#include &lt;cwchar&gt;#include &lt;future&gt;#include &lt;limits&gt;#include &lt;locale&gt;#include &lt;memory&gt;#include &lt;random&gt;#include &lt;string&gt;#include &lt;thread&gt;#include &lt;vector&gt;#include &lt;cassert&gt;#include &lt;climits&gt;#include &lt;clocale&gt;#include &lt;complex&gt;#include &lt;csetjmp&gt;#include &lt;csignal&gt;#include &lt;cstdarg&gt;#include &lt;cstddef&gt;#include &lt;cstdint&gt;#include &lt;cstdlib&gt;#include &lt;cstring&gt;#include &lt;ctgmath&gt;#include &lt;cwctype&gt;#include &lt;fstream&gt;#include &lt;iomanip&gt;#include &lt;numeric&gt;#include &lt;sstream&gt;#include &lt;ccomplex&gt;#include &lt;cstdbool&gt;#include &lt;iostream&gt;#include &lt;typeinfo&gt;#include &lt;valarray&gt;#include &lt;algorithm&gt;#include &lt;cinttypes&gt;#include &lt;cstdalign&gt;#include &lt;stdexcept&gt;#include &lt;typeindex&gt;#include &lt;functional&gt;#include &lt;forward_list&gt;#include &lt;system_error&gt;#include &lt;unordered_map&gt;#include &lt;unordered_set&gt;#include &lt;scoped_allocator&gt;#include &lt;condition_variable&gt;// #include &lt;conio.h&gt;// #include &lt;windows.h&gt;using namespace std;typedef long long LL;typedef unsigned int ui;typedef unsigned long long ull;typedef float fl;typedef double ld;typedef long double LD;typedef pair&lt;int,int&gt; pii;#if (WIN32) || (WIN64) || (__WIN32) || (__WIN64) || (_WIN32) || (_WIN64) || (WINDOWS)#define lld "%I64d"#define llu "%I64u"#else#define lld "%lld"#define llu "%llu"#endif#define ui(n) ((unsigned int)(n))#define LL(n) ((long long)(n))#define ull(n) ((unsigned long long)(n))#define fl(n) ((float)(n))#define ld(n) ((double)(n))#define LD(n) ((long double)(n))#define char(n) ((char)(n))#define Bool(n) ((bool)(n))#define fixpoint(n) fixed&lt;&lt;setprecision(n)const int INF=1061109567;const int NINF=-1044266559;const LL LINF=4557430888798830399;const ld eps=1e-15;#define MOD (1000000007)#define PI (3.1415926535897932384626433832795028841971)/*#define MB_LEN_MAX 5#define SHRT_MIN (-32768)#define SHRT_MAX 32767#define USHRT_MAX 0xffffU#define INT_MIN (-2147483647 - 1)#define INT_MAX 2147483647#define UINT_MAX 0xffffffffU#define LONG_MIN (-2147483647L - 1)#define LONG_MAX 2147483647L#define ULONG_MAX 0xffffffffUL#define LLONG_MAX 9223372036854775807ll#define LLONG_MIN (-9223372036854775807ll - 1)#define ULLONG_MAX 0xffffffffffffffffull*/#define MP make_pair#define MT make_tuple#define All(a) (a).begin(),(a).end()#define pall(a) (a).rbegin(),(a).rend()#define Log(x,y) log(x)/log(y)#define SZ(a) ((int)(a).size())#define rep(i,n) for(int i=0;i&lt;((int)(n));i++)#define rep1(i,n) for(int i=1;i&lt;=((int)(n));i++)#define repa(i,a,n) for(int i=((int)(a));i&lt;((int)(n));i++)#define repa1(i,a,n) for(int i=((int)(a));i&lt;=((int)(n));i++)#define repd(i,n) for(int i=((int)(n))-1;i&gt;=0;i--)#define repd1(i,n) for(int i=((int)(n));i&gt;=1;i--)#define repda(i,n,a) for(int i=((int)(n));i&gt;((int)(a));i--)#define repda1(i,n,a) for(int i=((int)(n));i&gt;=((int)(a));i--)#define FOR(i,a,n,step) for(int i=((int)(a));i&lt;((int)(n));i+=((int)(step)))#define repv(itr,v) for(__typeof((v).begin()) itr=(v).begin();itr!=(v).end();itr++)#define repV(i,v) for(auto i:v)#define repE(i,v) for(auto &amp;i:v)#define MS(x,y) memset(x,y,sizeof(x))#define MC(x) MS(x,0)#define MINF(x) MS(x,63)#define MCP(x,y) memcpy(x,y,sizeof(y))#define sqr(x) ((x)*(x))#define UN(v) sort(All(v)),v.erase(unique(All(v)),v.end())#define filein(x) freopen(x,"r",stdin)#define fileout(x) freopen(x,"w",stdout)#define fileio(x)\ freopen(x".in","r",stdin);\ freopen(x".out","w",stdout)#define filein2(filename,name) ifstream name(filename,ios::in)#define fileout2(filename,name) ofstream name(filename,ios::out)#define file(filename,name) fstream name(filename,ios::in|ios::out)#define Pause system("pause")#define Cls system("cls")#define fs first#define sc second#define PC(x) putchar(x)#define GC(x) x=getchar()#define Endl PC('\n')#define SF scanf#define PF printfinline int Read()&#123; int X=0,w=0;char ch=0;while(!isdigit(ch))&#123;w|=ch=='-';ch=getchar();&#125;while(isdigit(ch))X=(X&lt;&lt;3)+(X&lt;&lt;1)+(ch^48),ch=getchar(); return w?-X:X;&#125;inline void Write(int x)&#123;if(x&lt;0)putchar('-'),x=-x;if(x&gt;9)Write(x/10);putchar(x%10+'0');&#125;inline LL powmod(LL a,LL b)&#123;LL RES=1;a%=MOD;assert(b&gt;=0);for(;b;b&gt;&gt;=1)&#123;if(b&amp;1)RES=RES*a%MOD;a=a*a%MOD;&#125;return RES%MOD;&#125;inline LL gcdll(LL a,LL b)&#123;return b?gcdll(b,a%b):a;&#125;const int dx[]=&#123;0,1,0,-1,1,-1,-1,1&#125;;const int dy[]=&#123;1,0,-1,0,-1,-1,1,1&#125;;/************************************************************BEGIN************************************************************/const int maxn=(1&lt;&lt;17)+10;int n,par[maxn],ansv;vector&lt;int&gt; e[maxn],seq,ans;pii getpar(int x,int fa=0)&#123; par[x]=fa; pii res=&#123;0,x&#125;; repV(y,e[x]) if(y!=fa) &#123; pii got=getpar(y,x);got.fs++; res=max(res,got); &#125; return res;&#125;pii sol(int x,int fa=0)&#123; int cnt=e[x].size()-(fa!=0); if(cnt&gt;3) return &#123;0,-1&#125;; if(cnt==0) return &#123;1,0&#125;; vector&lt;int&gt; valid,spec;valid.clear();spec.clear(); repV(y,e[x]) if(y!=fa) &#123; pii got=sol(y,x); if(got.fs==0) return &#123;0,-1&#125;; else if(got.fs==1) valid.push_back(got.sc); else spec.push_back(got.sc); &#125; if(spec.size()&gt;=2) return &#123;0,-1&#125;; sort(All(valid)); if(cnt==1) &#123; ansv=x; if(valid.size()==1&amp;&amp;valid[0]==0) return &#123;2,1&#125;; else return &#123;0,-1&#125;; &#125; if(cnt==2) &#123; if(valid.size()==2&amp;&amp;valid[0]==valid[1]) return &#123;1,valid[0]+1&#125;; else if(valid.size()==1&amp;&amp;valid[0]==spec[0]) return &#123;2,valid[0]+1&#125;; else return &#123;0,-1&#125;; &#125; if(cnt==3) &#123; ansv=x; if(valid.size()==3&amp;&amp;valid[0]==valid[1]&amp;&amp;valid[1]+1==valid[2]) return &#123;2,valid[2]+1&#125;; else return &#123;0,-1&#125;; &#125; return &#123;0,-1&#125;;&#125;int main()&#123; SF("%d",&amp;n); n=(1&lt;&lt;n)-2; rep(i,n-1) &#123; int x,y;SF("%d%d",&amp;x,&amp;y); e[x].push_back(y); e[y].push_back(x); &#125; pii a=getpar(1),b=getpar(a.sc),c=getpar(b.sc); int x=c.sc; while(x) &#123; seq.push_back(x); x=par[x]; &#125; int mid=seq.size()/2; for(int i=mid-2;i&lt;=mid+2;i++) if(0&lt;=i&amp;&amp;i&lt;seq.size()) &#123; pii got=sol(seq[i]); if(got.fs==2) ans.push_back(ansv); &#125; sort(All(ans));ans.erase(unique(All(ans)),ans.end()); PF("%d\n",ans.size()); repV(i,ans) PF("%d ",i); return 0;&#125;/*************************************************************END**************************************************************/]]></content>
      <categories>
        <category>算法</category>
        <category>Codeforces</category>
      </categories>
      <tags>
        <tag>构造</tag>
        <tag>DFS</tag>
        <tag>模拟</tag>
        <tag>图论</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Codeforces 609F Frogs and mosquitoes 题解]]></title>
    <url>%2F2019%2F09%2F21%2FCodeforces-609F-Frogs-and-mosquitoes-%E9%A2%98%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[Codeforces 609F Frogs and mosquitoes 题解题意有$n (1\le n\le 2\cdot10^5)$个青蛙固定在平面直角坐标系中$Ox$的非负半轴上，对于第$i (1\le i\le n)$个青蛙有两个值，分别是$x_i$和$t_i (0\le x_i,t_i\le 10^9)$($x_i$两两不同)，$x_i$代表它的位置，$t_i$代表它的舌头的长度。 有$m (1\le m\le 2\cdot10^5)$只蚊子也固定在$Ox$的非负半轴上，对于第$i (1\le i\le m)$只蚊子有两个值，分别是$p_i$和$b_i (0\le p_i,b_i\le 10^9)$，$p_i$代表它的位置，$b_i$代表它的大小。 如果一个青蛙$i$和一只蚊子$j$，满足 $p_j$在区间$[x_i,x_i+t_i]$内，那么青蛙$i$就可以吃掉蚊子$j$，并且舌头会增长$b_j$。如果有多个青蛙可以吃掉同一个蚊子，那么这个蚊子会被$x_i$最小的那个青蛙吃掉。 蚊子是按照输入的顺序降临的，如果第$i$个蚊子要降临，必须满足 青蛙吃光了可能吃掉的所有蚊子$j (1\le j&lt;i)$。 问第$i$只青蛙吃掉了多少蚊子和最后它的舌头有多长。 题解对于青蛙$i$和$j$，如果$[x_i,x_i+t_i]$包含在$[x_j,x_j+t_j]$中，那么青蛙$i$就永远没有用了。 因为处于区间$[x_i,x_i+t_i]$内的蚊子总会被青蛙$j$吃掉($x_j&lt;x_i$)。 那么大体思路就出来了： 读入青蛙，删除无用的青蛙 依次读入蚊子，每次读入蚊子$i$做出以下操作： 如果蚊子$i$不能被如何青蛙吃掉，那么就丢入一个数据结构中，continue；否则： 选用处于最左边的青蛙$j$吃掉蚊子$i$。因为此是青蛙$j$的舌头变长了，所以再删除一遍无用的青蛙 并且 查找青蛙$j$可不可以再吃掉蚊子了。最后更新青蛙$j$的数据。 输出答案 完成这个过程可以用三个set完成，分别维护青蛙的$x_i$，$(x_i+t_i)$和目前没有被吃掉的蚊子，有关查找的操作可以用二分完成，具体见程序。时间复杂度$O(n\log{n}+m\log{m})$。 也可以用线段树完成。 程序123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255// #pragma GCC optimize(2)// #pragma G++ optimize(2)// #pragma comment(linker,"/STACK:102400000,102400000")// #include &lt;bits/stdc++.h&gt;#include &lt;map&gt;#include &lt;set&gt;#include &lt;list&gt;#include &lt;array&gt;#include &lt;cfenv&gt;#include &lt;cmath&gt;#include &lt;ctime&gt;#include &lt;deque&gt;#include &lt;mutex&gt;#include &lt;queue&gt;#include &lt;ratio&gt;#include &lt;regex&gt;#include &lt;stack&gt;#include &lt;tuple&gt;#include &lt;atomic&gt;#include &lt;bitset&gt;#include &lt;cctype&gt;#include &lt;cerrno&gt;#include &lt;cfloat&gt;#include &lt;chrono&gt;#include &lt;cstdio&gt;#include &lt;cwchar&gt;#include &lt;future&gt;#include &lt;limits&gt;#include &lt;locale&gt;#include &lt;memory&gt;#include &lt;random&gt;#include &lt;string&gt;#include &lt;thread&gt;#include &lt;vector&gt;#include &lt;cassert&gt;#include &lt;climits&gt;#include &lt;clocale&gt;#include &lt;complex&gt;#include &lt;csetjmp&gt;#include &lt;csignal&gt;#include &lt;cstdarg&gt;#include &lt;cstddef&gt;#include &lt;cstdint&gt;#include &lt;cstdlib&gt;#include &lt;cstring&gt;#include &lt;ctgmath&gt;#include &lt;cwctype&gt;#include &lt;fstream&gt;#include &lt;iomanip&gt;#include &lt;numeric&gt;#include &lt;sstream&gt;#include &lt;ccomplex&gt;#include &lt;cstdbool&gt;#include &lt;iostream&gt;#include &lt;typeinfo&gt;#include &lt;valarray&gt;#include &lt;algorithm&gt;#include &lt;cinttypes&gt;#include &lt;cstdalign&gt;#include &lt;stdexcept&gt;#include &lt;typeindex&gt;#include &lt;functional&gt;#include &lt;forward_list&gt;#include &lt;system_error&gt;#include &lt;unordered_map&gt;#include &lt;unordered_set&gt;#include &lt;scoped_allocator&gt;#include &lt;condition_variable&gt;// #include &lt;conio.h&gt;// #include &lt;windows.h&gt;using namespace std;typedef long long LL;typedef unsigned int ui;typedef unsigned long long ull;typedef float fl;typedef double ld;typedef long double LD;typedef pair&lt;int,int&gt; pii;#if (WIN32) || (WIN64) || (__WIN32) || (__WIN64) || (_WIN32) || (_WIN64) || (WINDOWS)#define lld "%I64d"#define llu "%I64u"#else#define lld "%lld"#define llu "%llu"#endif#define ui(n) ((unsigned int)(n))#define LL(n) ((long long)(n))#define ull(n) ((unsigned long long)(n))#define fl(n) ((float)(n))#define ld(n) ((double)(n))#define LD(n) ((long double)(n))#define char(n) ((char)(n))#define Bool(n) ((bool)(n))#define fixpoint(n) fixed&lt;&lt;setprecision(n)const int INF=1061109567;const int NINF=-1044266559;const LL LINF=4557430888798830399;const ld eps=1e-15;#define MOD (1000000007)#define PI (3.1415926535897932384626433832795028841971)/*#define MB_LEN_MAX 5#define SHRT_MIN (-32768)#define SHRT_MAX 32767#define USHRT_MAX 0xffffU#define INT_MIN (-2147483647 - 1)#define INT_MAX 2147483647#define UINT_MAX 0xffffffffU#define LONG_MIN (-2147483647L - 1)#define LONG_MAX 2147483647L#define ULONG_MAX 0xffffffffUL#define LLONG_MAX 9223372036854775807ll#define LLONG_MIN (-9223372036854775807ll - 1)#define ULLONG_MAX 0xffffffffffffffffull*/#define MP make_pair#define MT make_tuple#define All(a) (a).begin(),(a).end()#define pall(a) (a).rbegin(),(a).rend()#define Log(x,y) log(x)/log(y)#define SZ(a) ((int)(a).size())#define rep(i,n) for(int i=0;i&lt;((int)(n));i++)#define rep1(i,n) for(int i=1;i&lt;=((int)(n));i++)#define repa(i,a,n) for(int i=((int)(a));i&lt;((int)(n));i++)#define repa1(i,a,n) for(int i=((int)(a));i&lt;=((int)(n));i++)#define repd(i,n) for(int i=((int)(n))-1;i&gt;=0;i--)#define repd1(i,n) for(int i=((int)(n));i&gt;=1;i--)#define repda(i,n,a) for(int i=((int)(n));i&gt;((int)(a));i--)#define repda1(i,n,a) for(int i=((int)(n));i&gt;=((int)(a));i--)#define FOR(i,a,n,step) for(int i=((int)(a));i&lt;((int)(n));i+=((int)(step)))#define repv(itr,v) for(__typeof((v).begin()) itr=(v).begin();itr!=(v).end();itr++)#define repV(i,v) for(auto i:v)#define repE(i,v) for(auto &amp;i:v)#define MS(x,y) memset(x,y,sizeof(x))#define MC(x) MS(x,0)#define MINF(x) MS(x,63)#define MCP(x,y) memcpy(x,y,sizeof(y))#define sqr(x) ((x)*(x))#define UN(v) sort(All(v)),v.erase(unique(All(v)),v.end())#define filein(x) freopen(x,"r",stdin)#define fileout(x) freopen(x,"w",stdout)#define fileio(x)\ freopen(x".in","r",stdin);\ freopen(x".out","w",stdout)#define filein2(filename,name) ifstream name(filename,ios::in)#define fileout2(filename,name) ofstream name(filename,ios::out)#define file(filename,name) fstream name(filename,ios::in|ios::out)#define Pause system("pause")#define Cls system("cls")#define fs first#define sc second#define PC(x) putchar(x)#define GC(x) x=getchar()#define Endl PC('\n')#define SF scanf#define PF printfinline int Read()&#123; int X=0,w=0;char ch=0;while(!isdigit(ch))&#123;w|=ch=='-';ch=getchar();&#125;while(isdigit(ch))X=(X&lt;&lt;3)+(X&lt;&lt;1)+(ch^48),ch=getchar(); return w?-X:X;&#125;inline void Write(int x)&#123;if(x&lt;0)putchar('-'),x=-x;if(x&gt;9)Write(x/10);putchar(x%10+'0');&#125;inline LL powmod(LL a,LL b)&#123;LL RES=1;a%=MOD;assert(b&gt;=0);for(;b;b&gt;&gt;=1)&#123;if(b&amp;1)RES=RES*a%MOD;a=a*a%MOD;&#125;return RES%MOD;&#125;inline LL gcdll(LL a,LL b)&#123;return b?gcdll(b,a%b):a;&#125;const int dx[]=&#123;0,1,0,-1,1,-1,-1,1&#125;;const int dy[]=&#123;1,0,-1,0,-1,-1,1,1&#125;;/************************************************************Begin************************************************************/const int maxn=200010;int n,m,cnt[maxn];LL x[maxn],t[maxn],p[maxn],b[maxn];set&lt;pair&lt;LL,int&gt; &gt; frl,frr,mos;inline void erase_frog(int id)&#123; if(frl.find(&#123;x[id],id&#125;)==frl.end()) return; while(1) &#123; auto it=frl.lower_bound(&#123;x[id]+1,-1&#125;); if(it==frl.end()) break; int p=it-&gt;sc; if(x[id]+t[id]&lt;x[p]+t[p]) break; frl.erase(it); frr.erase(&#123;x[p]+t[p],p&#125;); &#125;&#125;inline void frog_eat_mosquitoes(int id)&#123; while(1) &#123; auto it=mos.lower_bound(&#123;x[id]+t[id]+1,-1&#125;); if(it==mos.begin()) break; it--; if(it-&gt;fs&lt;x[id]) break; t[id]+=b[it-&gt;sc]; cnt[id]++; mos.erase(it); &#125;&#125;int main()&#123; SF("%d%d",&amp;n,&amp;m); rep(i,n) &#123; SF("%lld%lld",&amp;x[i],&amp;t[i]); frl.insert(&#123;x[i],i&#125;); frr.insert(&#123;x[i]+t[i],i&#125;); &#125; rep(i,n) erase_frog(i); rep(i,m) &#123; SF("%lld%lld",&amp;p[i],&amp;b[i]); auto it=frr.lower_bound(&#123;p[i],-1&#125;); if(it==frr.end()||x[it-&gt;sc]&gt;p[i]) &#123; mos.insert(&#123;p[i],i&#125;); continue; &#125; int id=it-&gt;sc; frr.erase(&#123;x[id]+t[id],id&#125;); t[id]+=b[i]; cnt[id]++; frog_eat_mosquitoes(id); frr.insert(&#123;x[id]+t[id],id&#125;); erase_frog(id); &#125; rep(i,n) PF("%d %lld\n",cnt[i],t[i]); return 0;&#125;/*************************************************************End**************************************************************/]]></content>
      <categories>
        <category>算法</category>
        <category>Codeforces</category>
      </categories>
      <tags>
        <tag>二分</tag>
        <tag>贪心</tag>
        <tag>数据结构</tag>
        <tag>线段树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Codeforces 1119D Frets On Fire 题解]]></title>
    <url>%2F2019%2F09%2F14%2FCodeforces-1119D-Frets-On-Fire-%E9%A2%98%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[Codeforces 1119D Frets On Fire 题解题意给定$n$和$s_1,s_2,\dots,s_n$，由此得到一个$n\times(10^{18}+1)$的矩阵$f$，其中$f_{i,j}=s_i+j (1\le i\le n,0\le j\le 10^{18})$。 在样例$1$中，给定$n=6,s=[3,1,4,1,5,9]$，得到 \begin{matrix} f & \textbf{0} & \textbf{1} & \textbf{2} & \textbf{3} & \textbf{4} & \textbf{5} & \textbf{6} & \textbf{7} & \ldots \\ s_1: & 3 & 4 & 5 & 6 & 7 & 8 & 9 & 10 & \dots \\ s_2: & 1 & 2 & 3 & 4 & 5 & 6 & 7 & 8 & \dots \\ s_3: & 4 & 5 & 6 & 7 & 8 & 9 & 10 & 11 & \dots \\ s_4: & 1 & 2 & 3 & 4 & 5 & 6 & 7 & 8 & \dots \\ s_5: & 5 & 6 & 7 & 8 & 9 & 10 & 11 & 12 & \dots \\ s_6: & 9 & 10 & 11 & 12 & 13 & 14 & 15 & 16 & \dots \end{matrix}再给定$q$个查询，每个查询有$L,R$，问第$L$列到第$R$列(以下表达为$[L,R]$)有多少个不同的数。 题解因为问的是列，所以行的顺序不重要，可以对$s$进行从小到大排序。 对样例$1$排完序之后矩阵变为 \begin{matrix} \textbf{f} & \textbf{0} & \textbf{1} & \textbf{2} & \textbf{3} & \textbf{4} & \textbf{5} & \textbf{6} & \textbf{7} & \ldots \\ s_1: & 1 & 2 & 3 & 4 & 5 & 6 & 7 & 8 & \dots \\ s_2: & 1 & 2 & 3 & 4 & 5 & 6 & 7 & 8 & \dots \\ s_3: & 3 & 4 & 5 & 6 & 7 & 8 & 9 & 10 & \dots \\ s_4: & 4 & 5 & 6 & 7 & 8 & 9 & 10 & 11 & \dots \\ s_5: & 5 & 6 & 7 & 8 & 9 & 10 & 11 & 12 & \dots \\ s_6: & 9 & 10 & 11 & 12 & 13 & 14 & 15 & 16 & \dots \end{matrix}还有：查询$[L,R]$与查询$[0,R-L]$是等价的。 定义$r=R-L,w=r+1$。 考虑当每一行对于整个矩阵即$r=10^{18}$时的贡献。 对于样例$1$： 第$1$行贡献了$0$个数$\{\varnothing\}$； 第$2$行贡献了$2$个数$\{1,2\}$； 第$3$行贡献了$1$个数$\{3\}$； 第$4$行贡献了$1$个数$\{4\}$； 第$5$行贡献了$4$个数$\{5,6,7,8\}$； 第$6$行贡献了$w$个数$\{9,10,\dots,9+10^{18}\}$。 很容易发现，第$i (1\le i&lt;n)$行的贡献为$s_{i+1}-s_i$，第$n$行的贡献为$w$。 对于任意区间$[0,r]$，第$i (1\le i&lt;n)$行的贡献即为$\min\{s_{i+1}-s_i,w\}$，第$n$行的贡献为$w$。 那么答案即为$\sum_{i=1}^{n-1}{\min\{s_{i+1}-s_i,w\}}+w$。 问题：时间复杂度为$O(n\cdot q)$。 解答：设数组$t$，其中$t_i=s_{i+1}-s_i (1\le i&lt;n)$，将$t$从从小到大排序。设$p$为满足$t_p\le w$的最小值(用二分，时间复杂度为$O(\log n)$)，那么答案为$t_1+t_2+\dots+t_p+w\times(n-p)$($t_1+t_2+\dots+t_p$用前缀和求出)。时间复杂度为$O(\log n\cdot q)$。 程序123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202// #pragma GCC optimize(2)// #pragma G++ optimize(2)// #pragma comment(linker,"/STACK:102400000,102400000")// #include &lt;bits/stdc++.h&gt;#include &lt;map&gt;#include &lt;set&gt;#include &lt;list&gt;#include &lt;array&gt;#include &lt;cfenv&gt;#include &lt;cmath&gt;#include &lt;ctime&gt;#include &lt;deque&gt;#include &lt;mutex&gt;#include &lt;queue&gt;#include &lt;ratio&gt;#include &lt;regex&gt;#include &lt;stack&gt;#include &lt;tuple&gt;#include &lt;atomic&gt;#include &lt;bitset&gt;#include &lt;cctype&gt;#include &lt;cerrno&gt;#include &lt;cfloat&gt;#include &lt;chrono&gt;#include &lt;cstdio&gt;#include &lt;cwchar&gt;#include &lt;future&gt;#include &lt;limits&gt;#include &lt;locale&gt;#include &lt;memory&gt;#include &lt;random&gt;#include &lt;string&gt;#include &lt;thread&gt;#include &lt;vector&gt;#include &lt;cassert&gt;#include &lt;climits&gt;#include &lt;clocale&gt;#include &lt;complex&gt;#include &lt;csetjmp&gt;#include &lt;csignal&gt;#include &lt;cstdarg&gt;#include &lt;cstddef&gt;#include &lt;cstdint&gt;#include &lt;cstdlib&gt;#include &lt;cstring&gt;#include &lt;ctgmath&gt;#include &lt;cwctype&gt;#include &lt;fstream&gt;#include &lt;iomanip&gt;#include &lt;numeric&gt;#include &lt;sstream&gt;#include &lt;ccomplex&gt;#include &lt;cstdbool&gt;#include &lt;iostream&gt;#include &lt;typeinfo&gt;#include &lt;valarray&gt;#include &lt;algorithm&gt;#include &lt;cinttypes&gt;#include &lt;cstdalign&gt;#include &lt;stdexcept&gt;#include &lt;typeindex&gt;#include &lt;functional&gt;#include &lt;forward_list&gt;#include &lt;system_error&gt;#include &lt;unordered_map&gt;#include &lt;unordered_set&gt;#include &lt;scoped_allocator&gt;#include &lt;condition_variable&gt;// #include &lt;conio.h&gt;// #include &lt;windows.h&gt;using namespace std;typedef long long LL;typedef unsigned int ui;typedef unsigned long long ull;typedef float fl;typedef double ld;typedef long double LD;typedef pair&lt;int,int&gt; pii;#if (WIN32) || (WIN64) || (__WIN32) || (__WIN64) || (_WIN32) || (_WIN64) || (WINDOWS)#define lld "%I64d"#define llu "%I64u"#else#define lld "%lld"#define llu "%llu"#endif#define ui(n) ((unsigned int)(n))#define LL(n) ((long long)(n))#define ull(n) ((unsigned long long)(n))#define fl(n) ((float)(n))#define ld(n) ((double)(n))#define LD(n) ((long double)(n))#define char(n) ((char)(n))#define Bool(n) ((bool)(n))#define fixpoint(n) fixed&lt;&lt;setprecision(n)const int INF=1061109567;const int NINF=-1044266559;const LL LINF=4557430888798830399;const ld eps=1e-15;#define MOD (1000000007)#define PI (3.1415926535897932384626433832795028841971)/*#define MB_LEN_MAX 5#define SHRT_MIN (-32768)#define SHRT_MAX 32767#define USHRT_MAX 0xffffU#define INT_MIN (-2147483647 - 1)#define INT_MAX 2147483647#define UINT_MAX 0xffffffffU#define LONG_MIN (-2147483647L - 1)#define LONG_MAX 2147483647L#define ULONG_MAX 0xffffffffUL#define LLONG_MAX 9223372036854775807ll#define LLONG_MIN (-9223372036854775807ll - 1)#define ULLONG_MAX 0xffffffffffffffffull*/#define MP make_pair#define MT make_tuple#define All(a) (a).begin(),(a).end()#define pall(a) (a).rbegin(),(a).rend()#define Log(x,y) log(x)/log(y)#define SZ(a) ((int)(a).size())#define rep(i,n) for(int i=0;i&lt;((int)(n));i++)#define rep1(i,n) for(int i=1;i&lt;=((int)(n));i++)#define repa(i,a,n) for(int i=((int)(a));i&lt;((int)(n));i++)#define repa1(i,a,n) for(int i=((int)(a));i&lt;=((int)(n));i++)#define repd(i,n) for(int i=((int)(n))-1;i&gt;=0;i--)#define repd1(i,n) for(int i=((int)(n));i&gt;=1;i--)#define repda(i,n,a) for(int i=((int)(n));i&gt;((int)(a));i--)#define repda1(i,n,a) for(int i=((int)(n));i&gt;=((int)(a));i--)#define FOR(i,a,n,step) for(int i=((int)(a));i&lt;((int)(n));i+=((int)(step)))#define repv(itr,v) for(__typeof((v).begin()) itr=(v).begin();itr!=(v).end();itr++)#define repV(i,v) for(auto i:v)#define repE(i,v) for(auto &amp;i:v)#define MS(x,y) memset(x,y,sizeof(x))#define MC(x) MS(x,0)#define MINF(x) MS(x,63)#define MCP(x,y) memcpy(x,y,sizeof(y))#define sqr(x) ((x)*(x))#define UN(v) sort(All(v)),v.erase(unique(All(v)),v.end())#define filein(x) freopen(x,"r",stdin)#define fileout(x) freopen(x,"w",stdout)#define fileio(x)\ freopen(x".in","r",stdin);\ freopen(x".out","w",stdout)#define filein2(filename,name) ifstream name(filename,ios::in)#define fileout2(filename,name) ofstream name(filename,ios::out)#define file(filename,name) fstream name(filename,ios::in|ios::out)#define Pause system("pause")#define Cls system("cls")#define fs first#define sc second#define PC(x) putchar(x)#define GC(x) x=getchar()#define Endl PC('\n')#define SF scanf#define PF printfinline int Read()&#123; int X=0,w=0;char ch=0;while(!isdigit(ch))&#123;w|=ch=='-';ch=getchar();&#125;while(isdigit(ch))X=(X&lt;&lt;3)+(X&lt;&lt;1)+(ch^48),ch=getchar(); return w?-X:X;&#125;inline void Write(int x)&#123;if(x&lt;0)putchar('-'),x=-x;if(x&gt;9)Write(x/10);putchar(x%10+'0');&#125;inline LL powmod(LL a,LL b)&#123;LL RES=1;a%=MOD;assert(b&gt;=0);for(;b;b&gt;&gt;=1)&#123;if(b&amp;1)RES=RES*a%MOD;a=a*a%MOD;&#125;return RES%MOD;&#125;inline LL gcdll(LL a,LL b)&#123;return b?gcdll(b,a%b):a;&#125;const int dx[]=&#123;0,1,0,-1,1,-1,-1,1&#125;;const int dy[]=&#123;1,0,-1,0,-1,-1,1,1&#125;;/************************************************************Begin************************************************************/const int maxn=100010;int n,q;LL s[maxn],pre[maxn],L,R;int main()&#123; SF("%d",&amp;n); rep1(i,n) SF("%lld",&amp;s[i]); sort(s+1,s+n+1); rep1(i,n-1) s[i]=s[i+1]-s[i]; sort(s+1,s+n); rep1(i,n-1) pre[i]=pre[i-1]+s[i]; SF("%d",&amp;q); while(q--) &#123; SF("%lld%lld",&amp;L,&amp;R); LL w=R-L+1;int id=lower_bound(s+1,s+n,w)-(s+1); PF("%lld ",pre[id]+(n-id)*w); &#125; return 0;&#125;/*************************************************************End**************************************************************/]]></content>
      <categories>
        <category>算法</category>
        <category>Codeforces</category>
      </categories>
      <tags>
        <tag>二分</tag>
        <tag>排序</tag>
        <tag>前缀和</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Codeforces 309B Context Advertising 题解]]></title>
    <url>%2F2019%2F09%2F08%2FCodeforces-309B-Context-Advertising-%E9%A2%98%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[Codeforces 309B Context Advertising 题解题意给定$n,r,c$和一个由$n$个单词组成的句子(两两单词之间有一个空格)，在这个句子里选出若干个连续的单词，组成一个“矩阵”，行数不能超过$r$，每行字符数不能超过$c$(包括空格)，不能把一个单词拆开。求合法矩阵中，单词数最多的那个矩阵，并输出。 题解题目要求组成一个$r\times c$的矩阵。 先考虑每行字符数的这个条件。设这个句子为$s_0,s_1,\dots,s_{n-1}$，对于一个单词$i(0\le i&lt; n)$，找出一个最大的$j(i&lt;j\le n)$，满足$|s_i|+|s_{i+1}|+\dots+|s_{j-1}|+(j-i-1)\le c$，从$i$到$j$连一条无向边。这个过程可以用双指针或二分完成。这样，就构造了一棵树。 再考虑行数这个条件。对于树上每个结点$i$，用倍增求出它的$r$辈祖先$j$，那么这若干个连续单词的长度是$j-i$。找出最大长度，输出即可。 程序(双指针+倍增)123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246// #pragma GCC optimize(2)// #pragma G++ optimize(2)// #pragma comment(linker,"/STACK:102400000,102400000")// #include &lt;bits/stdc++.h&gt;#include &lt;map&gt;#include &lt;set&gt;#include &lt;list&gt;#include &lt;array&gt;#include &lt;cfenv&gt;#include &lt;cmath&gt;#include &lt;ctime&gt;#include &lt;deque&gt;#include &lt;mutex&gt;#include &lt;queue&gt;#include &lt;ratio&gt;#include &lt;regex&gt;#include &lt;stack&gt;#include &lt;tuple&gt;#include &lt;atomic&gt;#include &lt;bitset&gt;#include &lt;cctype&gt;#include &lt;cerrno&gt;#include &lt;cfloat&gt;#include &lt;chrono&gt;#include &lt;cstdio&gt;#include &lt;cwchar&gt;#include &lt;future&gt;#include &lt;limits&gt;#include &lt;locale&gt;#include &lt;memory&gt;#include &lt;random&gt;#include &lt;string&gt;#include &lt;thread&gt;#include &lt;vector&gt;#include &lt;cassert&gt;#include &lt;climits&gt;#include &lt;clocale&gt;#include &lt;complex&gt;#include &lt;csetjmp&gt;#include &lt;csignal&gt;#include &lt;cstdarg&gt;#include &lt;cstddef&gt;#include &lt;cstdint&gt;#include &lt;cstdlib&gt;#include &lt;cstring&gt;#include &lt;ctgmath&gt;#include &lt;cwctype&gt;#include &lt;fstream&gt;#include &lt;iomanip&gt;#include &lt;numeric&gt;#include &lt;sstream&gt;#include &lt;ccomplex&gt;#include &lt;cstdbool&gt;#include &lt;iostream&gt;#include &lt;typeinfo&gt;#include &lt;valarray&gt;#include &lt;algorithm&gt;#include &lt;cinttypes&gt;#include &lt;cstdalign&gt;#include &lt;stdexcept&gt;#include &lt;typeindex&gt;#include &lt;functional&gt;#include &lt;forward_list&gt;#include &lt;system_error&gt;#include &lt;unordered_map&gt;#include &lt;unordered_set&gt;#include &lt;scoped_allocator&gt;#include &lt;condition_variable&gt;// #include &lt;conio.h&gt;// #include &lt;windows.h&gt;using namespace std;typedef long long LL;typedef unsigned int ui;typedef unsigned long long ull;typedef float fl;typedef double ld;typedef long double LD;typedef pair&lt;int,int&gt; pii;#if (WIN32) || (WIN64) || (__WIN32) || (__WIN64) || (_WIN32) || (_WIN64) || (WINDOWS)#define lld "%I64d"#define llu "%I64u"#else#define lld "%lld"#define llu "%llu"#endif#define ui(n) ((unsigned int)(n))#define LL(n) ((long long)(n))#define ull(n) ((unsigned long long)(n))#define fl(n) ((float)(n))#define ld(n) ((double)(n))#define LD(n) ((long double)(n))#define char(n) ((char)(n))#define Bool(n) ((bool)(n))#define fixpoint(n) fixed&lt;&lt;setprecision(n)const int INF=1061109567;const int NINF=-1044266559;const LL LINF=4557430888798830399;const ld eps=1e-15;#define MOD (1000000007)#define PI (3.1415926535897932384626433832795028841971)/*#define MB_LEN_MAX 5#define SHRT_MIN (-32768)#define SHRT_MAX 32767#define USHRT_MAX 0xffffU#define INT_MIN (-2147483647 - 1)#define INT_MAX 2147483647#define UINT_MAX 0xffffffffU#define LONG_MIN (-2147483647L - 1)#define LONG_MAX 2147483647L#define ULONG_MAX 0xffffffffUL#define LLONG_MAX 9223372036854775807ll#define LLONG_MIN (-9223372036854775807ll - 1)#define ULLONG_MAX 0xffffffffffffffffull*/#define MP make_pair#define MT make_tuple#define All(a) (a).begin(),(a).end()#define pall(a) (a).rbegin(),(a).rend()#define Log(x,y) log(x)/log(y)#define SZ(a) ((int)(a).size())#define rep(i,n) for(int i=0;i&lt;((int)(n));i++)#define rep1(i,n) for(int i=1;i&lt;=((int)(n));i++)#define repa(i,a,n) for(int i=((int)(a));i&lt;((int)(n));i++)#define repa1(i,a,n) for(int i=((int)(a));i&lt;=((int)(n));i++)#define repd(i,n) for(int i=((int)(n))-1;i&gt;=0;i--)#define repd1(i,n) for(int i=((int)(n));i&gt;=1;i--)#define repda(i,n,a) for(int i=((int)(n));i&gt;((int)(a));i--)#define repda1(i,n,a) for(int i=((int)(n));i&gt;=((int)(a));i--)#define FOR(i,a,n,step) for(int i=((int)(a));i&lt;((int)(n));i+=((int)(step)))#define repv(itr,v) for(__typeof((v).begin()) itr=(v).begin();itr!=(v).end();itr++)#define repV(i,v) for(auto i:v)#define repE(i,v) for(auto &amp;i:v)#define MS(x,y) memset(x,y,sizeof(x))#define MC(x) MS(x,0)#define MINF(x) MS(x,63)#define MCP(x,y) memcpy(x,y,sizeof(y))#define sqr(x) ((x)*(x))#define UN(v) sort(All(v)),v.erase(unique(All(v)),v.end())#define filein(x) freopen(x,"r",stdin)#define fileout(x) freopen(x,"w",stdout)#define fileio(x)\ freopen(x".in","r",stdin);\ freopen(x".out","w",stdout)#define filein2(filename,name) ifstream name(filename,ios::in)#define fileout2(filename,name) ofstream name(filename,ios::out)#define file(filename,name) fstream name(filename,ios::in|ios::out)#define Pause system("pause")#define Cls system("cls")#define fs first#define sc second#define PC(x) putchar(x)#define GC(x) x=getchar()#define Endl PC('\n')#define SF scanf#define PF printfinline int Read()&#123; int X=0,w=0;char ch=0;while(!isdigit(ch))&#123;w|=ch=='-';ch=getchar();&#125;while(isdigit(ch))X=(X&lt;&lt;3)+(X&lt;&lt;1)+(ch^48),ch=getchar(); return w?-X:X;&#125;inline void Write(int x)&#123;if(x&lt;0)putchar('-'),x=-x;if(x&gt;9)Write(x/10);putchar(x%10+'0');&#125;inline LL powmod(LL a,LL b)&#123;LL RES=1;a%=MOD;assert(b&gt;=0);for(;b;b&gt;&gt;=1)&#123;if(b&amp;1)RES=RES*a%MOD;a=a*a%MOD;&#125;return RES%MOD;&#125;inline LL gcdll(LL a,LL b)&#123;return b?gcdll(b,a%b):a;&#125;const int dx[]=&#123;0,1,0,-1,1,-1,-1,1&#125;;const int dy[]=&#123;1,0,-1,0,-1,-1,1,1&#125;;/************************************************************Begin************************************************************/const int maxn=1000010;int n,r,c,len[maxn],sum[maxn],to[maxn],fa[maxn],cur[maxn];string str[maxn];inline void sol(int num)&#123; if(!num) &#123; rep(i,n+1) fa[i]=i; return; &#125; sol(num/2); rep(i,n+1) cur[i]=fa[fa[i]]; if(num%2) &#123; rep(i,n+1) fa[i]=to[cur[i]]; &#125; else &#123; rep(i,n+1) fa[i]=cur[i]; &#125;&#125;int main()&#123; cin&gt;&gt;n&gt;&gt;r&gt;&gt;c; rep(i,n) &#123; cin&gt;&gt;str[i]; len[i]=str[i].size()+1; &#125; rep(i,n) sum[i+1]=sum[i]+len[i]; for(int i=0,j=0;i&lt;=n;i++) &#123; for(;j&lt;=n&amp;&amp;sum[j]-sum[i]&lt;=c+1;j++); to[i]=--j; &#125; sol(r); int mx=-1,id=-1; rep(i,n+1) if(mx&lt;fa[i]-i) &#123; mx=fa[i]-i; id=i; &#125; rep(cntr,r) &#123; if(id==to[id]) break; repa(i,id,to[id]) &#123; if(i&gt;id) cout&lt;&lt;" "; cout&lt;&lt;str[i]; &#125; id=to[id]; cout&lt;&lt;endl; &#125; return 0;&#125;/*************************************************************End**************************************************************/]]></content>
      <categories>
        <category>算法</category>
        <category>Codeforces</category>
      </categories>
      <tags>
        <tag>二分</tag>
        <tag>DP</tag>
        <tag>双指针</tag>
        <tag>倍增</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Ural 1220 Stacks 题解]]></title>
    <url>%2F2019%2F09%2F07%2FUral-1220-Stacks-%E9%A2%98%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[Ural 1220 Stacks 题解题意模拟若干个栈。 给定$n(1\le n\le 10^5)$个操作，每个操作有如下两个类型 PUSH a b，意为把b插入第a个栈中。 POP a，意为输出第a个栈的栈顶元素，并弹出栈顶。 $1\le a \le 10^3,0\le b\le 10^9$，保证操作无误，内存限制为0.75MB=768KB​。 题解纯模拟会MLE(不知道有没有神仙可以卡过去)，不管是vector，stack还是其它的。 很容易想到用静态链表$v$维护，把所有的元素存储在同一个数组： $v_i$有一个指针$p_i$指向这个栈中前一个元素。 每个栈有$l_i$表示栈顶元素的下标。 但是这样仍然会MLE。 把$p$数组的类型换成unsigned short($[0,65536]$)，观察到$0\le v_i$。 若$p_i&gt;65536$，让$v_i=-v_i$，$p_i=p_i-65536$。 执行POP操作时转换一下即可。 Tip: G++ 7.1还是MLE(796KB)，选用Visual C++ 2017可以通过(760KB)。 程序1234567891011121314151617181920212223242526272829303132333435363738394041424344#include &lt;stdio.h&gt;#include &lt;math.h&gt;using namespace std;const int maxn=100001,maxm=1001,maxnum=65536;int n,a,b,v[maxn],len,lst[maxm];unsigned short poi[maxn];char op[5];int main()&#123; scanf("%d",&amp;n); for(int i=0;i&lt;n;i++) &#123; scanf("%s%d",op,&amp;a); if(op[1]=='U') &#123; scanf("%d",&amp;b); v[len++]=b; int id=len-1; if(lst[a]&gt;maxnum) &#123; poi[id]=lst[a]-maxnum; v[id]=-v[id]; &#125; else poi[id]=lst[a]; lst[a]=id; &#125; else &#123; printf("%d\n",abs(v[lst[a]])); if(v[lst[a]]&lt;0) lst[a]=poi[lst[a]]+maxnum; else lst[a]=poi[lst[a]]; &#125; &#125; return 0;&#125;]]></content>
      <categories>
        <category>算法</category>
        <category>Ural</category>
      </categories>
      <tags>
        <tag>静态链表</tag>
        <tag>卡内存</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Ural 1218 Episode N-th: The Jedi Tournament 题解]]></title>
    <url>%2F2019%2F09%2F04%2FUral-1218-Episode-N-th-The-Jedi-Tournament-%E9%A2%98%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[Ural 1218 Episode N-th: The Jedi Tournament 题解题意给定$n(1\le n\le 20)$个玩家，每个玩家有一个字符串名字和三个整数值(所有玩家的数值都不同)。对于玩家$i$和$j$，如果玩家$i$的三个值中至少有两个值大于玩家$j$的对应值，则$i$玩家可以淘汰$j$玩家。一个玩家胜利了就是他淘汰了所有人。你可以随意安排赛程，输出那些至少胜利了一次的玩家的名字(按照输入的顺序输出)。 题解构图。若$i$玩家可以淘汰$j$玩家，则从$i$连一条有向边到$j$。问题转化成：如果从$i$开始，能找到一条长度为$n-1$的路径，那么他胜利了。 方法$1$无脑暴力DFS。边数$n^2$，点数$n$，时间复杂度为$O(n^3)$。妥妥的TLE。 方法$2$强连通分量缩点。因为在同一个强连通分量中，任意一个点都可以淘汰(这个强连通分量中)其它的点。缩点后，图变成一个DAG，而入度为$0$的那个强连通分量中，任意一个点都可以淘汰(整个图中)其它的点。输出那个强连通分量里所有的点即可。 方法$2$程序123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245// #pragma GCC optimize(2)// #pragma G++ optimize(2)// #pragma comment(linker,"/STACK:102400000,102400000")// #include &lt;bits/stdc++.h&gt;#include &lt;map&gt;#include &lt;set&gt;#include &lt;list&gt;#include &lt;array&gt;#include &lt;cfenv&gt;#include &lt;cmath&gt;#include &lt;ctime&gt;#include &lt;deque&gt;#include &lt;mutex&gt;#include &lt;queue&gt;#include &lt;ratio&gt;#include &lt;regex&gt;#include &lt;stack&gt;#include &lt;tuple&gt;#include &lt;atomic&gt;#include &lt;bitset&gt;#include &lt;cctype&gt;#include &lt;cerrno&gt;#include &lt;cfloat&gt;#include &lt;chrono&gt;#include &lt;cstdio&gt;#include &lt;cwchar&gt;#include &lt;future&gt;#include &lt;limits&gt;#include &lt;locale&gt;#include &lt;memory&gt;#include &lt;random&gt;#include &lt;string&gt;#include &lt;thread&gt;#include &lt;vector&gt;#include &lt;cassert&gt;#include &lt;climits&gt;#include &lt;clocale&gt;#include &lt;complex&gt;#include &lt;csetjmp&gt;#include &lt;csignal&gt;#include &lt;cstdarg&gt;#include &lt;cstddef&gt;#include &lt;cstdint&gt;#include &lt;cstdlib&gt;#include &lt;cstring&gt;#include &lt;ctgmath&gt;#include &lt;cwctype&gt;#include &lt;fstream&gt;#include &lt;iomanip&gt;#include &lt;numeric&gt;#include &lt;sstream&gt;#include &lt;ccomplex&gt;#include &lt;cstdbool&gt;#include &lt;iostream&gt;#include &lt;typeinfo&gt;#include &lt;valarray&gt;#include &lt;algorithm&gt;#include &lt;cinttypes&gt;#include &lt;cstdalign&gt;#include &lt;stdexcept&gt;#include &lt;typeindex&gt;#include &lt;functional&gt;#include &lt;forward_list&gt;#include &lt;system_error&gt;#include &lt;unordered_map&gt;#include &lt;unordered_set&gt;#include &lt;scoped_allocator&gt;#include &lt;condition_variable&gt;// #include &lt;conio.h&gt;// #include &lt;windows.h&gt;using namespace std;typedef long long LL;typedef unsigned int ui;typedef unsigned long long ull;typedef float fl;typedef double ld;typedef long double LD;typedef pair&lt;int,int&gt; pii;#if (WIN32) || (WIN64) || (__WIN32) || (__WIN64) || (_WIN32) || (_WIN64) || (WINDOWS)#define lld "%I64d"#define llu "%I64u"#else#define lld "%lld"#define llu "%llu"#endif#define ui(n) ((unsigned int)(n))#define LL(n) ((long long)(n))#define ull(n) ((unsigned long long)(n))#define fl(n) ((float)(n))#define ld(n) ((double)(n))#define LD(n) ((long double)(n))#define char(n) ((char)(n))#define Bool(n) ((bool)(n))#define fixpoint(n) fixed&lt;&lt;setprecision(n)const int INF=1061109567;const int NINF=-1044266559;const LL LINF=4557430888798830399;const ld eps=1e-15;#define MOD (1000000007)#define PI (3.1415926535897932384626433832795028841971)/*#define MB_LEN_MAX 5#define SHRT_MIN (-32768)#define SHRT_MAX 32767#define USHRT_MAX 0xffffU#define INT_MIN (-2147483647 - 1)#define INT_MAX 2147483647#define UINT_MAX 0xffffffffU#define LONG_MIN (-2147483647L - 1)#define LONG_MAX 2147483647L#define ULONG_MAX 0xffffffffUL#define LLONG_MAX 9223372036854775807ll#define LLONG_MIN (-9223372036854775807ll - 1)#define ULLONG_MAX 0xffffffffffffffffull*/#define MP make_pair#define MT make_tuple#define All(a) (a).begin(),(a).end()#define pall(a) (a).rbegin(),(a).rend()#define Log(x,y) log(x)/log(y)#define SZ(a) ((int)(a).size())#define rep(i,n) for(int i=0;i&lt;((int)(n));i++)#define rep1(i,n) for(int i=1;i&lt;=((int)(n));i++)#define repa(i,a,n) for(int i=((int)(a));i&lt;((int)(n));i++)#define repa1(i,a,n) for(int i=((int)(a));i&lt;=((int)(n));i++)#define repd(i,n) for(int i=((int)(n))-1;i&gt;=0;i--)#define repd1(i,n) for(int i=((int)(n));i&gt;=1;i--)#define repda(i,n,a) for(int i=((int)(n));i&gt;((int)(a));i--)#define repda1(i,n,a) for(int i=((int)(n));i&gt;=((int)(a));i--)#define FOR(i,a,n,step) for(int i=((int)(a));i&lt;((int)(n));i+=((int)(step)))#define repv(itr,v) for(__typeof((v).begin()) itr=(v).begin();itr!=(v).end();itr++)#define repV(i,v) for(auto i:v)#define repE(i,v) for(auto &amp;i:v)#define MS(x,y) memset(x,y,sizeof(x))#define MC(x) MS(x,0)#define MINF(x) MS(x,63)#define MCP(x,y) memcpy(x,y,sizeof(y))#define sqr(x) ((x)*(x))#define UN(v) sort(All(v)),v.erase(unique(All(v)),v.end())#define filein(x) freopen(x,"r",stdin)#define fileout(x) freopen(x,"w",stdout)#define fileio(x)\ freopen(x".in","r",stdin);\ freopen(x".out","w",stdout)#define filein2(filename,name) ifstream name(filename,ios::in)#define fileout2(filename,name) ofstream name(filename,ios::out)#define file(filename,name) fstream name(filename,ios::in|ios::out)#define Pause system("pause")#define Cls system("cls")#define fs first#define sc second#define PC(x) putchar(x)#define GC(x) x=getchar()#define Endl PC('\n')#define SF scanf#define PF printfinline int Read()&#123; int X=0,w=0;char ch=0;while(!isdigit(ch))&#123;w|=ch=='-';ch=getchar();&#125;while(isdigit(ch))X=(X&lt;&lt;3)+(X&lt;&lt;1)+(ch^48),ch=getchar(); return w?-X:X;&#125;inline void Write(int x)&#123;if(x&lt;0)putchar('-'),x=-x;if(x&gt;9)Write(x/10);putchar(x%10+'0');&#125;inline LL powmod(LL a,LL b)&#123;LL RES=1;a%=MOD;assert(b&gt;=0);for(;b;b&gt;&gt;=1)&#123;if(b&amp;1)RES=RES*a%MOD;a=a*a%MOD;&#125;return RES%MOD;&#125;inline LL gcdll(LL a,LL b)&#123;return b?gcdll(b,a%b):a;&#125;const int dx[]=&#123;0,1,0,-1,1,-1,-1,1&#125;;const int dy[]=&#123;1,0,-1,0,-1,-1,1,1&#125;;/************************************************************Begin************************************************************/const int maxn=210;int n,a[maxn],b[maxn],c[maxn],tim,dfn[maxn],low[maxn],sta[maxn],ind,cscc,scc[maxn],deg[maxn];string jedi[maxn];vector&lt;int&gt; e[maxn];bool vis[maxn];inline void Tarjan(int x)&#123; dfn[x]=low[x]=++tim; vis[x]=1; sta[++ind]=x; for(int i=0;i&lt;e[x].size();i++) &#123; int y=e[x][i]; if(!dfn[y]) &#123; Tarjan(y); low[x]=min(low[x],low[y]); &#125; else if(vis[y]) low[x]=min(low[x],dfn[y]); &#125; if(low[x]==dfn[x]) &#123; do &#123; // printf("%d ",sta[ind]); scc[sta[ind]]=cscc; vis[sta[ind--]]=0; &#125; while(x!=sta[ind+1]); cscc++; // printf("\n"); &#125;&#125;int main()&#123; cin&gt;&gt;n; rep(i,n) &#123; cin&gt;&gt;jedi[i]&gt;&gt;a[i]&gt;&gt;b[i]&gt;&gt;c[i]; &#125; rep(i,n) rep(j,n) &#123; int cnt=0; if(a[i]&gt;a[j]) cnt++; if(b[i]&gt;b[j]) cnt++; if(c[i]&gt;c[j]) cnt++; if(cnt&gt;=2) e[i].push_back(j); &#125; rep(i,n) if(!dfn[i]) Tarjan(i); rep(i,n) repV(j,e[i]) if(scc[i]!=scc[j]) deg[scc[j]]++; int deg0; rep(i,cscc) if(deg[i]==0) deg0=i; rep(i,n) if(scc[i]==deg0) cout&lt;&lt;jedi[i]&lt;&lt;endl; return 0;&#125;/*************************************************************End**************************************************************/]]></content>
      <categories>
        <category>算法</category>
        <category>Ural</category>
      </categories>
      <tags>
        <tag>图论</tag>
        <tag>强连通分量</tag>
        <tag>缩点</tag>
        <tag>Tarjan</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Ural 1217 Unlucky Tickets 题解]]></title>
    <url>%2F2019%2F09%2F03%2FUral-1217-Unlucky-Tickets-%E9%A2%98%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[Ural 1217 Unlucky Tickets 题解题意给定$n(2\le n\le 20)$($n$是偶数)，求出在所有$n$位数中(可以有前导零)，前一半数码的和 与 后一半数码的和相等或在奇数位上的数码的和 与 在偶数位上的数码和相等 的个数。 题解考虑DP。 $f(i,j,k)$表示在前$i$位，前一半数码的和 减去 后一半数码的和的为$j$，在奇数位上的数码的和 减去 在偶数位上的数码和为$k$ 的个数。 Tip: $j$不可能为负数，而$k$有可能为负数，所以写的时候要把$k$变成非负数，即$f(i,j,k+base)$。 初始值：$f(0,0,0)=1$。 状态转移方程： 设当前状态为$f(i,j,k)$，需转移到的状态为$f(i’,j’,k’)$，$i’$位上放的数是$x$。 $i’=i+1$。 若$i’&gt;n/2$且$x&gt;j$($j’$位负数)，跳出关于$x$的循环。 若$i’\le n/2$，$j’=j+x$；否则$j’=j-x$。 若$i’\%2=1$，$k’=k+x$；否则$k’=k-x$。 $f(i’,j’,k’)+=f(i,j,k)$即可。 答案：$f(n,0,0)$。 程序123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204// #pragma GCC optimize(2)// #pragma G++ optimize(2)// #pragma comment(linker,"/STACK:102400000,102400000")// #include &lt;bits/stdc++.h&gt;#include &lt;map&gt;#include &lt;set&gt;#include &lt;list&gt;#include &lt;array&gt;#include &lt;cfenv&gt;#include &lt;cmath&gt;#include &lt;ctime&gt;#include &lt;deque&gt;#include &lt;mutex&gt;#include &lt;queue&gt;#include &lt;ratio&gt;#include &lt;regex&gt;#include &lt;stack&gt;#include &lt;tuple&gt;#include &lt;atomic&gt;#include &lt;bitset&gt;#include &lt;cctype&gt;#include &lt;cerrno&gt;#include &lt;cfloat&gt;#include &lt;chrono&gt;#include &lt;cstdio&gt;#include &lt;cwchar&gt;#include &lt;future&gt;#include &lt;limits&gt;#include &lt;locale&gt;#include &lt;memory&gt;#include &lt;random&gt;#include &lt;string&gt;#include &lt;thread&gt;#include &lt;vector&gt;#include &lt;cassert&gt;#include &lt;climits&gt;#include &lt;clocale&gt;#include &lt;complex&gt;#include &lt;csetjmp&gt;#include &lt;csignal&gt;#include &lt;cstdarg&gt;#include &lt;cstddef&gt;#include &lt;cstdint&gt;#include &lt;cstdlib&gt;#include &lt;cstring&gt;#include &lt;ctgmath&gt;#include &lt;cwctype&gt;#include &lt;fstream&gt;#include &lt;iomanip&gt;#include &lt;numeric&gt;#include &lt;sstream&gt;#include &lt;ccomplex&gt;#include &lt;cstdbool&gt;#include &lt;iostream&gt;#include &lt;typeinfo&gt;#include &lt;valarray&gt;#include &lt;algorithm&gt;#include &lt;cinttypes&gt;#include &lt;cstdalign&gt;#include &lt;stdexcept&gt;#include &lt;typeindex&gt;#include &lt;functional&gt;#include &lt;forward_list&gt;#include &lt;system_error&gt;#include &lt;unordered_map&gt;#include &lt;unordered_set&gt;#include &lt;scoped_allocator&gt;#include &lt;condition_variable&gt;// #include &lt;conio.h&gt;// #include &lt;windows.h&gt;using namespace std;typedef long long LL;typedef unsigned int ui;typedef unsigned long long ull;typedef float fl;typedef double ld;typedef long double LD;typedef pair&lt;int,int&gt; pii;#if (WIN32) || (WIN64) || (__WIN32) || (__WIN64) || (_WIN32) || (_WIN64) || (WINDOWS)#define lld "%I64d"#define llu "%I64u"#else#define lld "%lld"#define llu "%llu"#endif#define ui(n) ((unsigned int)(n))#define LL(n) ((long long)(n))#define ull(n) ((unsigned long long)(n))#define fl(n) ((float)(n))#define ld(n) ((double)(n))#define LD(n) ((long double)(n))#define char(n) ((char)(n))#define Bool(n) ((bool)(n))#define fixpoint(n) fixed&lt;&lt;setprecision(n)const int INF=1061109567;const int NINF=-1044266559;const LL LINF=4557430888798830399;const ld eps=1e-15;#define MOD (1000000007)#define PI (3.1415926535897932384626433832795028841971)/*#define MB_LEN_MAX 5#define SHRT_MIN (-32768)#define SHRT_MAX 32767#define USHRT_MAX 0xffffU#define INT_MIN (-2147483647 - 1)#define INT_MAX 2147483647#define UINT_MAX 0xffffffffU#define LONG_MIN (-2147483647L - 1)#define LONG_MAX 2147483647L#define ULONG_MAX 0xffffffffUL#define LLONG_MAX 9223372036854775807ll#define LLONG_MIN (-9223372036854775807ll - 1)#define ULLONG_MAX 0xffffffffffffffffull*/#define MP make_pair#define MT make_tuple#define All(a) (a).begin(),(a).end()#define pall(a) (a).rbegin(),(a).rend()#define Log(x,y) log(x)/log(y)#define SZ(a) ((int)(a).size())#define rep(i,n) for(int i=0;i&lt;((int)(n));i++)#define rep1(i,n) for(int i=1;i&lt;=((int)(n));i++)#define repa(i,a,n) for(int i=((int)(a));i&lt;((int)(n));i++)#define repa1(i,a,n) for(int i=((int)(a));i&lt;=((int)(n));i++)#define repd(i,n) for(int i=((int)(n))-1;i&gt;=0;i--)#define repd1(i,n) for(int i=((int)(n));i&gt;=1;i--)#define repda(i,n,a) for(int i=((int)(n));i&gt;((int)(a));i--)#define repda1(i,n,a) for(int i=((int)(n));i&gt;=((int)(a));i--)#define FOR(i,a,n,step) for(int i=((int)(a));i&lt;((int)(n));i+=((int)(step)))#define repv(itr,v) for(__typeof((v).begin()) itr=(v).begin();itr!=(v).end();itr++)#define repV(i,v) for(auto i:v)#define repE(i,v) for(auto &amp;i:v)#define MS(x,y) memset(x,y,sizeof(x))#define MC(x) MS(x,0)#define MINF(x) MS(x,63)#define MCP(x,y) memcpy(x,y,sizeof(y))#define sqr(x) ((x)*(x))#define UN(v) sort(All(v)),v.erase(unique(All(v)),v.end())#define filein(x) freopen(x,"r",stdin)#define fileout(x) freopen(x,"w",stdout)#define fileio(x)\ freopen(x".in","r",stdin);\ freopen(x".out","w",stdout)#define filein2(filename,name) ifstream name(filename,ios::in)#define fileout2(filename,name) ofstream name(filename,ios::out)#define file(filename,name) fstream name(filename,ios::in|ios::out)#define Pause system("pause")#define Cls system("cls")#define fs first#define sc second#define PC(x) putchar(x)#define GC(x) x=getchar()#define Endl PC('\n')#define SF scanf#define PF printfinline int Read()&#123; int X=0,w=0;char ch=0;while(!isdigit(ch))&#123;w|=ch=='-';ch=getchar();&#125;while(isdigit(ch))X=(X&lt;&lt;3)+(X&lt;&lt;1)+(ch^48),ch=getchar(); return w?-X:X;&#125;inline void Write(int x)&#123;if(x&lt;0)putchar('-'),x=-x;if(x&gt;9)Write(x/10);putchar(x%10+'0');&#125;inline LL powmod(LL a,LL b)&#123;LL RES=1;a%=MOD;assert(b&gt;=0);for(;b;b&gt;&gt;=1)&#123;if(b&amp;1)RES=RES*a%MOD;a=a*a%MOD;&#125;return RES%MOD;&#125;inline LL gcdll(LL a,LL b)&#123;return b?gcdll(b,a%b):a;&#125;const int dx[]=&#123;0,1,0,-1,1,-1,-1,1&#125;;const int dy[]=&#123;1,0,-1,0,-1,-1,1,1&#125;;/************************************************************Begin************************************************************/const int maxn=25,base=200;int n;LL dp[maxn][base+10][base*2+10];// dp[numbers of digits][the first half - the last half][digits on the odd positions - the digits on the even positions]int main()&#123; SF("%d",&amp;n); dp[0][0][base]=1; rep(i,n) rep(j,base+1) repa1(k,-200,200) if(dp[i][j][k+base]) &#123; rep(x,10) &#123; int ci=i+1,cj=j,ck=k; if(ci&gt;n/2&amp;&amp;x&gt;j) break; if(ci&lt;=n/2) cj+=x; else cj-=x; if(ci%2) ck+=x; else ck-=x; dp[ci][cj][ck+base]+=dp[i][j][k+base]; &#125; &#125; PF("%lld",dp[n][0][base]); return 0;&#125;/*************************************************************End**************************************************************/]]></content>
      <categories>
        <category>算法</category>
        <category>Ural</category>
      </categories>
      <tags>
        <tag>DP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[头文件和宏定义]]></title>
    <url>%2F2019%2F09%2F02%2F%E5%A4%B4%E6%96%87%E4%BB%B6%E5%92%8C%E5%AE%8F%E5%AE%9A%E4%B9%89%2F</url>
    <content type="text"><![CDATA[头文件和宏定义有点长，会使文章看上去很长，请谅解。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190// #pragma GCC optimize(2)// #pragma G++ optimize(2)// #pragma comment(linker,"/STACK:102400000,102400000")// #include &lt;bits/stdc++.h&gt;#include &lt;map&gt;#include &lt;set&gt;#include &lt;list&gt;#include &lt;array&gt;#include &lt;cfenv&gt;#include &lt;cmath&gt;#include &lt;ctime&gt;#include &lt;deque&gt;#include &lt;mutex&gt;#include &lt;queue&gt;#include &lt;ratio&gt;#include &lt;regex&gt;#include &lt;stack&gt;#include &lt;tuple&gt;#include &lt;atomic&gt;#include &lt;bitset&gt;#include &lt;cctype&gt;#include &lt;cerrno&gt;#include &lt;cfloat&gt;#include &lt;chrono&gt;#include &lt;cstdio&gt;#include &lt;cwchar&gt;#include &lt;future&gt;#include &lt;limits&gt;#include &lt;locale&gt;#include &lt;memory&gt;#include &lt;random&gt;#include &lt;string&gt;#include &lt;thread&gt;#include &lt;vector&gt;#include &lt;cassert&gt;#include &lt;climits&gt;#include &lt;clocale&gt;#include &lt;complex&gt;#include &lt;csetjmp&gt;#include &lt;csignal&gt;#include &lt;cstdarg&gt;#include &lt;cstddef&gt;#include &lt;cstdint&gt;#include &lt;cstdlib&gt;#include &lt;cstring&gt;#include &lt;ctgmath&gt;#include &lt;cwctype&gt;#include &lt;fstream&gt;#include &lt;iomanip&gt;#include &lt;numeric&gt;#include &lt;sstream&gt;#include &lt;ccomplex&gt;#include &lt;cstdbool&gt;#include &lt;iostream&gt;#include &lt;typeinfo&gt;#include &lt;valarray&gt;#include &lt;algorithm&gt;#include &lt;cinttypes&gt;#include &lt;cstdalign&gt;#include &lt;stdexcept&gt;#include &lt;typeindex&gt;#include &lt;functional&gt;#include &lt;forward_list&gt;#include &lt;system_error&gt;#include &lt;unordered_map&gt;#include &lt;unordered_set&gt;#include &lt;scoped_allocator&gt;#include &lt;condition_variable&gt;// #include &lt;conio.h&gt;// #include &lt;windows.h&gt;using namespace std;typedef long long LL;typedef unsigned int ui;typedef unsigned long long ull;typedef float fl;typedef double ld;typedef long double LD;typedef pair&lt;int,int&gt; pii;#if (WIN32) || (WIN64) || (__WIN32) || (__WIN64) || (_WIN32) || (_WIN64) || (WINDOWS)#define lld "%I64d"#define llu "%I64u"#else#define lld "%lld"#define llu "%llu"#endif#define ui(n) ((unsigned int)(n))#define LL(n) ((long long)(n))#define ull(n) ((unsigned long long)(n))#define fl(n) ((float)(n))#define ld(n) ((double)(n))#define LD(n) ((long double)(n))#define char(n) ((char)(n))#define Bool(n) ((bool)(n))#define fixpoint(n) fixed&lt;&lt;setprecision(n)const int INF=1061109567;const int NINF=-1044266559;const LL LINF=4557430888798830399;const ld eps=1e-15;#define MOD (1000000007)#define PI (3.1415926535897932384626433832795028841971)/*#define MB_LEN_MAX 5#define SHRT_MIN (-32768)#define SHRT_MAX 32767#define USHRT_MAX 0xffffU#define INT_MIN (-2147483647 - 1)#define INT_MAX 2147483647#define UINT_MAX 0xffffffffU#define LONG_MIN (-2147483647L - 1)#define LONG_MAX 2147483647L#define ULONG_MAX 0xffffffffUL#define LLONG_MAX 9223372036854775807ll#define LLONG_MIN (-9223372036854775807ll - 1)#define ULLONG_MAX 0xffffffffffffffffull*/#define MP make_pair#define MT make_tuple#define All(a) (a).begin(),(a).end()#define pall(a) (a).rbegin(),(a).rend()#define Log(x,y) log(x)/log(y)#define SZ(a) ((int)(a).size())#define rep(i,n) for(int i=0;i&lt;((int)(n));i++)#define rep1(i,n) for(int i=1;i&lt;=((int)(n));i++)#define repa(i,a,n) for(int i=((int)(a));i&lt;((int)(n));i++)#define repa1(i,a,n) for(int i=((int)(a));i&lt;=((int)(n));i++)#define repd(i,n) for(int i=((int)(n))-1;i&gt;=0;i--)#define repd1(i,n) for(int i=((int)(n));i&gt;=1;i--)#define repda(i,n,a) for(int i=((int)(n));i&gt;((int)(a));i--)#define repda1(i,n,a) for(int i=((int)(n));i&gt;=((int)(a));i--)#define FOR(i,a,n,step) for(int i=((int)(a));i&lt;((int)(n));i+=((int)(step)))#define repv(itr,v) for(__typeof((v).begin()) itr=(v).begin();itr!=(v).end();itr++)#define repV(i,v) for(auto i:v)#define repE(i,v) for(auto &amp;i:v)#define MS(x,y) memset(x,y,sizeof(x))#define MC(x) MS(x,0)#define MINF(x) MS(x,63)#define MCP(x,y) memcpy(x,y,sizeof(y))#define sqr(x) ((x)*(x))#define UN(v) sort(All(v)),v.erase(unique(All(v)),v.end())#define filein(x) freopen(x,"r",stdin)#define fileout(x) freopen(x,"w",stdout)#define fileio(x)\ freopen(x".in","r",stdin);\ freopen(x".out","w",stdout)#define filein2(filename,name) ifstream name(filename,ios::in)#define fileout2(filename,name) ofstream name(filename,ios::out)#define file(filename,name) fstream name(filename,ios::in|ios::out)#define Pause system("pause")#define Cls system("cls")#define fs first#define sc second#define PC(x) putchar(x)#define GC(x) x=getchar()#define Endl PC('\n')#define SF scanf#define PF printf#define j0 J0#define j1 J1#define jn Jn#define y0 Y0#define y1 Y1#define yn Yninline int Read()&#123; int x=0,w=0;char ch=0;while(!isdigit(ch))&#123;w|=ch=='-';ch=getchar();&#125;while(isdigit(ch))x=(x&lt;&lt;3)+(x&lt;&lt;1)+(ch^48),ch=getchar(); return w?-x:x;&#125;inline void Write(int x)&#123;if(x&lt;0)putchar('-'),x=-x;if(x&gt;9)Write(x/10);putchar(x%10+'0');&#125;inline LL powmod(LL a,LL b)&#123;LL res=1;a%=MOD;assert(b&gt;=0);for(;b;b&gt;&gt;=1)&#123;if(b&amp;1)res=res*a%MOD;a=a*a%MOD;&#125;return res%MOD;&#125;inline LL gcdll(LL a,LL b)&#123;return b?gcdll(b,a%b):a;&#125;const int dx[]=&#123;0,1,0,-1,1,-1,-1,1&#125;;const int dy[]=&#123;1,0,-1,0,-1,-1,1,1&#125;;/************************************************************BEGIN************************************************************/const int maxn=INF;int main()&#123; return 0;&#125;/*************************************************************END**************************************************************/]]></content>
  </entry>
  <entry>
    <title><![CDATA[agc029C Lexicographic constraints 题解]]></title>
    <url>%2F2019%2F08%2F31%2Fagc029C-Lexicographic-constraints-%E9%A2%98%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[agc029C Lexicographic constraints 题解题意 有$n$个字符串，分别为$S_1,S_2,\dots,S_n$，$S_i$的长度为$A_i(1\le i\le n)$。给定$n$和$A$，求用最少个数的字符组成$S_1,S_2,\dots,S_n$，使得$S_1&lt;S_2&lt;\dots&lt;S_n$(字典序)。输出这个数。 题解贪心。对于每一个字符串，必须选择可选字符串中字典序最小的一个。 反证法：如果不选字典序最小的一个，答案肯定不会更优。 设每个字符为$0\sim\inf$中的一个数字。 所以 S_1=\begin{matrix} \underbrace{0\dots0} \\ A_1\end{matrix}已知$S_{i-1}$如何求$S_i(2\le i\le n)$呢。 $A_i&gt;A_{i-1}$时， S_i=S_{i-1}+\begin{matrix} \underbrace{0\dots0} \\ A_i-A_{i-1}\end{matrix} $A_i\le A_{i-1}$时，$S_i=S_{i-1}$的前$A_i$位，且$S_i$的最后一位加$1$，然后“进位”(如果当前位的值超出字符集的大小，就把当前位设置位$0$，前一位加$1$)。 这里需要知道字符集大小。考虑二分，因为字符集大小是满足单调性的。check函数：“进位”时如果进到$-1$位了，就不可行。 证明：如果字符集大小位$m$，则字符集大小为$m+1$一定可行，而字符集大小为$m-1$不一定可行。 问题：字符串长度最大为$10^9$，不能维护整个字符串。 解法$1$：用一个map&lt;int,int&gt;表示第几位放的是什么字符。观察发现：字符串中大部分的字符为$0$，所以只维护字符不为$0$位就可以了。 Tip: 需要特判$A_1&lt;A_2&lt;\dots&lt;A_n$的情况，否则前$3$个点会TLE。 解法$2$：同样，字符串中大部分的字符为$0$，可以用一个vector&lt;pair&lt;int,int&gt; &gt;维护，&lt;a,b&gt;表示字符为a，出现了b次的字符串，存在vector里即可表达整个字符串。这个方法写起来会更麻烦一点。 程序解法$1$123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231// #pragma GCC optimize(2)// #pragma G++ optimize(2)// #pragma comment(linker,"/STACK:102400000,102400000")// #include &lt;bits/stdc++.h&gt;#include &lt;map&gt;#include &lt;set&gt;#include &lt;list&gt;#include &lt;array&gt;#include &lt;cfenv&gt;#include &lt;cmath&gt;#include &lt;ctime&gt;#include &lt;deque&gt;#include &lt;mutex&gt;#include &lt;queue&gt;#include &lt;ratio&gt;#include &lt;regex&gt;#include &lt;stack&gt;#include &lt;tuple&gt;#include &lt;atomic&gt;#include &lt;bitset&gt;#include &lt;cctype&gt;#include &lt;cerrno&gt;#include &lt;cfloat&gt;#include &lt;chrono&gt;#include &lt;cstdio&gt;#include &lt;cwchar&gt;#include &lt;future&gt;#include &lt;limits&gt;#include &lt;locale&gt;#include &lt;memory&gt;#include &lt;random&gt;#include &lt;string&gt;#include &lt;thread&gt;#include &lt;vector&gt;#include &lt;cassert&gt;#include &lt;climits&gt;#include &lt;clocale&gt;#include &lt;complex&gt;#include &lt;csetjmp&gt;#include &lt;csignal&gt;#include &lt;cstdarg&gt;#include &lt;cstddef&gt;#include &lt;cstdint&gt;#include &lt;cstdlib&gt;#include &lt;cstring&gt;#include &lt;ctgmath&gt;#include &lt;cwctype&gt;#include &lt;fstream&gt;#include &lt;iomanip&gt;#include &lt;numeric&gt;#include &lt;sstream&gt;#include &lt;ccomplex&gt;#include &lt;cstdbool&gt;#include &lt;iostream&gt;#include &lt;typeinfo&gt;#include &lt;valarray&gt;#include &lt;algorithm&gt;#include &lt;cinttypes&gt;#include &lt;cstdalign&gt;#include &lt;stdexcept&gt;#include &lt;typeindex&gt;#include &lt;functional&gt;#include &lt;forward_list&gt;#include &lt;system_error&gt;#include &lt;unordered_map&gt;#include &lt;unordered_set&gt;#include &lt;scoped_allocator&gt;#include &lt;condition_variable&gt;// #include &lt;conio.h&gt;// #include &lt;windows.h&gt;using namespace std;typedef long long LL;typedef unsigned int ui;typedef unsigned long long ull;typedef float fl;typedef double ld;typedef long double LD;typedef pair&lt;int,int&gt; pii;#if (WIN32) || (WIN64) || (__WIN32) || (__WIN64) || (_WIN32) || (_WIN64) || (WINDOWS)#define lld "%I64d"#define llu "%I64u"#else#define lld "%lld"#define llu "%llu"#endif#define ui(n) ((unsigned int)(n))#define LL(n) ((long long)(n))#define ull(n) ((unsigned long long)(n))#define fl(n) ((float)(n))#define ld(n) ((double)(n))#define LD(n) ((long double)(n))#define char(n) ((char)(n))#define Bool(n) ((bool)(n))#define fixpoint(n) fixed&lt;&lt;setprecision(n)const int INF=1061109567;const int NINF=-1044266559;const LL LINF=4557430888798830399;const ld eps=1e-15;#define MOD (1000000007)#define PI (3.1415926535897932384626433832795028841971)/*#define MB_LEN_MAX 5#define SHRT_MIN (-32768)#define SHRT_MAX 32767#define USHRT_MAX 0xffffU#define INT_MIN (-2147483647 - 1)#define INT_MAX 2147483647#define UINT_MAX 0xffffffffU#define LONG_MIN (-2147483647L - 1)#define LONG_MAX 2147483647L#define ULONG_MAX 0xffffffffUL#define LLONG_MAX 9223372036854775807ll#define LLONG_MIN (-9223372036854775807ll - 1)#define ULLONG_MAX 0xffffffffffffffffull*/#define MP make_pair#define MT make_tuple#define All(a) (a).begin(),(a).end()#define pall(a) (a).rbegin(),(a).rend()#define Log(x,y) log(x)/log(y)#define SZ(a) ((int)(a).size())#define rep(i,n) for(int i=0;i&lt;((int)(n));i++)#define rep1(i,n) for(int i=1;i&lt;=((int)(n));i++)#define repa(i,a,n) for(int i=((int)(a));i&lt;((int)(n));i++)#define repa1(i,a,n) for(int i=((int)(a));i&lt;=((int)(n));i++)#define repd(i,n) for(int i=((int)(n))-1;i&gt;=0;i--)#define repd1(i,n) for(int i=((int)(n));i&gt;=1;i--)#define repda(i,n,a) for(int i=((int)(n));i&gt;((int)(a));i--)#define repda1(i,n,a) for(int i=((int)(n));i&gt;=((int)(a));i--)#define FOR(i,a,n,step) for(int i=((int)(a));i&lt;((int)(n));i+=((int)(step)))#define repv(itr,v) for(__typeof((v).begin()) itr=(v).begin();itr!=(v).end();itr++)#define repV(i,v) for(auto i:v)#define repE(i,v) for(auto &amp;i:v)#define MS(x,y) memset(x,y,sizeof(x))#define MC(x) MS(x,0)#define MINF(x) MS(x,63)#define MCP(x,y) memcpy(x,y,sizeof(y))#define sqr(x) ((x)*(x))#define UN(v) sort(All(v)),v.erase(unique(All(v)),v.end())#define filein(x) freopen(x,"r",stdin)#define fileout(x) freopen(x,"w",stdout)#define fileio(x)\ freopen(x".in","r",stdin);\ freopen(x".out","w",stdout)#define filein2(filename,name) ifstream name(filename,ios::in)#define fileout2(filename,name) ofstream name(filename,ios::out)#define file(filename,name) fstream name(filename,ios::in|ios::out)#define Pause system("pause")#define Cls system("cls")#define fs first#define sc second#define PC(x) putchar(x)#define GC(x) x=getchar()#define Endl PC('\n')#define SF scanf#define PF printfinline int Read()&#123; int X=0,w=0;char ch=0;while(!isdigit(ch))&#123;w|=ch=='-';ch=getchar();&#125;while(isdigit(ch))X=(X&lt;&lt;3)+(X&lt;&lt;1)+(ch^48),ch=getchar(); return w?-X:X;&#125;inline void Write(int x)&#123;if(x&lt;0)putchar('-'),x=-x;if(x&gt;9)Write(x/10);putchar(x%10+'0');&#125;inline LL powmod(LL a,LL b)&#123;LL RES=1;a%=MOD;assert(b&gt;=0);for(;b;b&gt;&gt;=1)&#123;if(b&amp;1)RES=RES*a%MOD;a=a*a%MOD;&#125;return RES%MOD;&#125;inline LL gcdll(LL a,LL b)&#123;return b?gcdll(b,a%b):a;&#125;const int dx[]=&#123;0,1,0,-1,1,-1,-1,1&#125;;const int dy[]=&#123;1,0,-1,0,-1,-1,1,1&#125;;/************************************************************Begin************************************************************/const int maxn=200010;int n,a[maxn];map&lt;int,int&gt; str;inline bool check(int x)&#123; int len=0; str.clear(); rep(i,n) if(a[i]&gt;len) &#123; len=a[i]; &#125; else &#123; while(!str.empty()&amp;&amp;str.rbegin()-&gt;fs&gt;=a[i]) str.erase(str.rbegin()-&gt;fs); int cur=a[i]-1; str[cur]++; while(str[cur]&gt;=x) &#123; str.erase(cur); str[--cur]++; if(cur&lt;0) return 0; &#125; len=a[i]; &#125; return 1;&#125;int main()&#123; SF("%d",&amp;n); rep(i,n) SF("%d",&amp;a[i]); bool f=1; rep1(i,n-1) if(a[i]&lt;=a[i-1]) f=0; if(f) return !PF("1"); int l=2,r=n+1; // [l,r) while(l&lt;r) &#123; int mid=(l+r)/2; if(check(mid)) r=mid; else l=mid+1; &#125; PF("%d",r); return 0;&#125;/*************************************************************End**************************************************************/ 解法$2$123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250// #pragma GCC optimize(2)// #pragma G++ optimize(2)// #pragma comment(linker,"/STACK:102400000,102400000")// #include &lt;bits/stdc++.h&gt;#include &lt;map&gt;#include &lt;set&gt;#include &lt;list&gt;#include &lt;array&gt;#include &lt;cfenv&gt;#include &lt;cmath&gt;#include &lt;ctime&gt;#include &lt;deque&gt;#include &lt;mutex&gt;#include &lt;queue&gt;#include &lt;ratio&gt;#include &lt;regex&gt;#include &lt;stack&gt;#include &lt;tuple&gt;#include &lt;atomic&gt;#include &lt;bitset&gt;#include &lt;cctype&gt;#include &lt;cerrno&gt;#include &lt;cfloat&gt;#include &lt;chrono&gt;#include &lt;cstdio&gt;#include &lt;cwchar&gt;#include &lt;future&gt;#include &lt;limits&gt;#include &lt;locale&gt;#include &lt;memory&gt;#include &lt;random&gt;#include &lt;string&gt;#include &lt;thread&gt;#include &lt;vector&gt;#include &lt;cassert&gt;#include &lt;climits&gt;#include &lt;clocale&gt;#include &lt;complex&gt;#include &lt;csetjmp&gt;#include &lt;csignal&gt;#include &lt;cstdarg&gt;#include &lt;cstddef&gt;#include &lt;cstdint&gt;#include &lt;cstdlib&gt;#include &lt;cstring&gt;#include &lt;ctgmath&gt;#include &lt;cwctype&gt;#include &lt;fstream&gt;#include &lt;iomanip&gt;#include &lt;numeric&gt;#include &lt;sstream&gt;#include &lt;ccomplex&gt;#include &lt;cstdbool&gt;#include &lt;iostream&gt;#include &lt;typeinfo&gt;#include &lt;valarray&gt;#include &lt;algorithm&gt;#include &lt;cinttypes&gt;#include &lt;cstdalign&gt;#include &lt;stdexcept&gt;#include &lt;typeindex&gt;#include &lt;functional&gt;#include &lt;forward_list&gt;#include &lt;system_error&gt;#include &lt;unordered_map&gt;#include &lt;unordered_set&gt;#include &lt;scoped_allocator&gt;#include &lt;condition_variable&gt;// #include &lt;conio.h&gt;// #include &lt;windows.h&gt;using namespace std;typedef long long LL;typedef unsigned int ui;typedef unsigned long long ull;typedef float fl;typedef double ld;typedef long double LD;typedef pair&lt;int,int&gt; pii;#if (WIN32) || (WIN64) || (__WIN32) || (__WIN64) || (_WIN32) || (_WIN64) || (WINDOWS)#define lld "%I64d"#define llu "%I64u"#else#define lld "%lld"#define llu "%llu"#endif#define ui(n) ((unsigned int)(n))#define LL(n) ((long long)(n))#define ull(n) ((unsigned long long)(n))#define fl(n) ((float)(n))#define ld(n) ((double)(n))#define LD(n) ((long double)(n))#define char(n) ((char)(n))#define Bool(n) ((bool)(n))#define fixpoint(n) fixed&lt;&lt;setprecision(n)const int INF=1061109567;const int NINF=-1044266559;const LL LINF=4557430888798830399;const ld eps=1e-15;#define MOD (1000000007)#define PI (3.1415926535897932384626433832795028841971)/*#define MB_LEN_MAX 5#define SHRT_MIN (-32768)#define SHRT_MAX 32767#define USHRT_MAX 0xffffU#define INT_MIN (-2147483647 - 1)#define INT_MAX 2147483647#define UINT_MAX 0xffffffffU#define LONG_MIN (-2147483647L - 1)#define LONG_MAX 2147483647L#define ULONG_MAX 0xffffffffUL#define LLONG_MAX 9223372036854775807ll#define LLONG_MIN (-9223372036854775807ll - 1)#define ULLONG_MAX 0xffffffffffffffffull*/#define MP make_pair#define MT make_tuple#define All(a) (a).begin(),(a).end()#define pall(a) (a).rbegin(),(a).rend()#define Log(x,y) log(x)/log(y)#define SZ(a) ((int)(a).size())#define rep(i,n) for(int i=0;i&lt;((int)(n));i++)#define rep1(i,n) for(int i=1;i&lt;=((int)(n));i++)#define repa(i,a,n) for(int i=((int)(a));i&lt;((int)(n));i++)#define repa1(i,a,n) for(int i=((int)(a));i&lt;=((int)(n));i++)#define repd(i,n) for(int i=((int)(n))-1;i&gt;=0;i--)#define repd1(i,n) for(int i=((int)(n));i&gt;=1;i--)#define repda(i,n,a) for(int i=((int)(n));i&gt;((int)(a));i--)#define repda1(i,n,a) for(int i=((int)(n));i&gt;=((int)(a));i--)#define FOR(i,a,n,step) for(int i=((int)(a));i&lt;((int)(n));i+=((int)(step)))#define repv(itr,v) for(__typeof((v).begin()) itr=(v).begin();itr!=(v).end();itr++)#define repV(i,v) for(auto i:v)#define repE(i,v) for(auto &amp;i:v)#define MS(x,y) memset(x,y,sizeof(x))#define MC(x) MS(x,0)#define MINF(x) MS(x,63)#define MCP(x,y) memcpy(x,y,sizeof(y))#define sqr(x) ((x)*(x))#define UN(v) sort(All(v)),v.erase(unique(All(v)),v.end())#define filein(x) freopen(x,"r",stdin)#define fileout(x) freopen(x,"w",stdout)#define fileio(x)\ freopen(x".in","r",stdin);\ freopen(x".out","w",stdout)#define filein2(filename,name) ifstream name(filename,ios::in)#define fileout2(filename,name) ofstream name(filename,ios::out)#define file(filename,name) fstream name(filename,ios::in|ios::out)#define Pause system("pause")#define Cls system("cls")#define fs first#define sc second#define PC(x) putchar(x)#define GC(x) x=getchar()#define Endl PC('\n')#define SF scanf#define PF printfinline int Read()&#123; int X=0,w=0;char ch=0;while(!isdigit(ch))&#123;w|=ch=='-';ch=getchar();&#125;while(isdigit(ch))X=(X&lt;&lt;3)+(X&lt;&lt;1)+(ch^48),ch=getchar(); return w?-X:X;&#125;inline void Write(int x)&#123;if(x&lt;0)putchar('-'),x=-x;if(x&gt;9)Write(x/10);putchar(x%10+'0');&#125;inline LL powmod(LL a,LL b)&#123;LL RES=1;a%=MOD;assert(b&gt;=0);for(;b;b&gt;&gt;=1)&#123;if(b&amp;1)RES=RES*a%MOD;a=a*a%MOD;&#125;return RES%MOD;&#125;inline LL gcdll(LL a,LL b)&#123;return b?gcdll(b,a%b):a;&#125;const int dx[]=&#123;0,1,0,-1,1,-1,-1,1&#125;;const int dy[]=&#123;1,0,-1,0,-1,-1,1,1&#125;;/************************************************************Begin************************************************************/const int maxn=200010;int n,a[maxn],alp;vector&lt;pair&lt;int,int&gt; &gt; v;inline int getlen()&#123; int len=0; repV(i,v) len+=i.sc; return len;&#125;inline int getlast()&#123; return v.back().fs;&#125;inline void pushstr(int x,int cnt)&#123; if(!v.empty()&amp;&amp;x==getlast()) v.back().sc+=cnt; else v.push_back(&#123;x,cnt&#125;);&#125;inline bool transform(int len)&#123; int cur=getlen(); if(cur&lt;len) &#123; pushstr(0,len-cur); &#125; else &#123; while(!v.empty()&amp;&amp;cur-v.back().sc&gt;=len) &#123; cur-=v.back().sc; v.pop_back(); &#125; v.back().sc-=cur-len; while(!v.empty()&amp;&amp;getlast()==alp-1) v.pop_back(); if(v.empty()) return 0; int x=getlast()+1;v.back().sc--; if(!v.back().sc) v.pop_back(); pushstr(x,1); pushstr(0,len-getlen()); &#125; return 1;&#125;inline bool check()&#123; v.clear(); rep(i,n) if(!transform(a[i])) return 0; return 1;&#125;int main()&#123; SF("%d",&amp;n); rep(i,n) SF("%d",&amp;a[i]); int l=1,r=n+1; // [l,r) while(l&lt;r) &#123; alp=(l+r)/2; if(check()) r=alp; else l=alp+1; &#125; PF("%d",r); return 0;&#125;/*************************************************************End**************************************************************/]]></content>
      <categories>
        <category>算法</category>
        <category>AtCoder</category>
      </categories>
      <tags>
        <tag>二分</tag>
        <tag>贪心</tag>
        <tag>模拟</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Ural 1204 Idempotents 题解]]></title>
    <url>%2F2019%2F08%2F29%2FUral-1204-Idempotents-%E9%A2%98%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[Ural 1204 Idempotents 题解题意给定$n$，且$n=p\times q$，$p,q$为不相等的质数。求所有的$x$，满足$0\le x\le n$且$x^2=x\pmod{n}$，并按序输出。 题解 \begin{align*} &\because x^2=x\pmod{n}\\ &\therefore x(x-1)=0\pmod{n}\\ &\therefore x(x-1)=0\pmod{pq}\\ &\therefore x(x-1)=kpq,k\ge 0\\ &\because x\le pq\\ &\therefore \begin{cases} x\%p=0,x\%q=1\\ x\%p=1,x\%q=0\\ \end{cases}\\ &\therefore \begin{cases} x=ap,x=bq+1\\ x=cp+1,x=dq \end{cases}\\ &\therefore \begin{cases} ap-bq=1\\ dq-cp=1 \end{cases} \end{align*}因为$gcd(p,q)=1$，所以可以用扩展欧几里得算法求出$x$。如果$x$是负数需要加上$n$。 程序123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228// #pragma GCC optimize(2)// #pragma G++ optimize(2)// #pragma comment(linker,"/STACK:102400000,102400000")// #include &lt;bits/stdc++.h&gt;#include &lt;map&gt;#include &lt;set&gt;#include &lt;list&gt;#include &lt;array&gt;#include &lt;cfenv&gt;#include &lt;cmath&gt;#include &lt;ctime&gt;#include &lt;deque&gt;#include &lt;mutex&gt;#include &lt;queue&gt;#include &lt;ratio&gt;#include &lt;regex&gt;#include &lt;stack&gt;#include &lt;tuple&gt;#include &lt;atomic&gt;#include &lt;bitset&gt;#include &lt;cctype&gt;#include &lt;cerrno&gt;#include &lt;cfloat&gt;#include &lt;chrono&gt;#include &lt;cstdio&gt;#include &lt;cwchar&gt;#include &lt;future&gt;#include &lt;limits&gt;#include &lt;locale&gt;#include &lt;memory&gt;#include &lt;random&gt;#include &lt;string&gt;#include &lt;thread&gt;#include &lt;vector&gt;#include &lt;cassert&gt;#include &lt;climits&gt;#include &lt;clocale&gt;#include &lt;complex&gt;#include &lt;csetjmp&gt;#include &lt;csignal&gt;#include &lt;cstdarg&gt;#include &lt;cstddef&gt;#include &lt;cstdint&gt;#include &lt;cstdlib&gt;#include &lt;cstring&gt;#include &lt;ctgmath&gt;#include &lt;cwctype&gt;#include &lt;fstream&gt;#include &lt;iomanip&gt;#include &lt;numeric&gt;#include &lt;sstream&gt;#include &lt;ccomplex&gt;#include &lt;cstdbool&gt;#include &lt;iostream&gt;#include &lt;typeinfo&gt;#include &lt;valarray&gt;#include &lt;algorithm&gt;#include &lt;cinttypes&gt;#include &lt;cstdalign&gt;#include &lt;stdexcept&gt;#include &lt;typeindex&gt;#include &lt;functional&gt;#include &lt;forward_list&gt;#include &lt;system_error&gt;#include &lt;unordered_map&gt;#include &lt;unordered_set&gt;#include &lt;scoped_allocator&gt;#include &lt;condition_variable&gt;// #include &lt;conio.h&gt;// #include &lt;windows.h&gt;using namespace std;typedef long long LL;typedef unsigned int ui;typedef unsigned long long ull;typedef float fl;typedef double ld;typedef long double LD;typedef pair&lt;int,int&gt; pii;#if (WIN32) || (WIN64) || (__WIN32) || (__WIN64) || (_WIN32) || (_WIN64) || (WINDOWS)#define lld "%I64d"#define llu "%I64u"#else#define lld "%lld"#define llu "%llu"#endif#define ui(n) ((unsigned int)(n))#define LL(n) ((long long)(n))#define ull(n) ((unsigned long long)(n))#define fl(n) ((float)(n))#define ld(n) ((double)(n))#define LD(n) ((long double)(n))#define char(n) ((char)(n))#define Bool(n) ((bool)(n))#define fixpoint(n) fixed&lt;&lt;setprecision(n)const int INF=1061109567;const int NINF=-1044266559;const LL LINF=4557430888798830399;const ld eps=1e-15;#define MOD (1000000007)#define PI (3.1415926535897932384626433832795028841971)/*#define MB_LEN_MAX 5#define SHRT_MIN (-32768)#define SHRT_MAX 32767#define USHRT_MAX 0xffffU#define INT_MIN (-2147483647 - 1)#define INT_MAX 2147483647#define UINT_MAX 0xffffffffU#define LONG_MIN (-2147483647L - 1)#define LONG_MAX 2147483647L#define ULONG_MAX 0xffffffffUL#define LLONG_MAX 9223372036854775807ll#define LLONG_MIN (-9223372036854775807ll - 1)#define ULLONG_MAX 0xffffffffffffffffull*/#define MP make_pair#define MT make_tuple#define All(a) (a).begin(),(a).end()#define pall(a) (a).rbegin(),(a).rend()#define Log(x,y) log(x)/log(y)#define SZ(a) ((int)(a).size())#define rep(i,n) for(int i=0;i&lt;((int)(n));i++)#define rep1(i,n) for(int i=1;i&lt;=((int)(n));i++)#define repa(i,a,n) for(int i=((int)(a));i&lt;((int)(n));i++)#define repa1(i,a,n) for(int i=((int)(a));i&lt;=((int)(n));i++)#define repd(i,n) for(int i=((int)(n))-1;i&gt;=0;i--)#define repd1(i,n) for(int i=((int)(n));i&gt;=1;i--)#define repda(i,n,a) for(int i=((int)(n));i&gt;((int)(a));i--)#define repda1(i,n,a) for(int i=((int)(n));i&gt;=((int)(a));i--)#define FOR(i,a,n,step) for(int i=((int)(a));i&lt;((int)(n));i+=((int)(step)))#define repv(itr,v) for(__typeof((v).begin()) itr=(v).begin();itr!=(v).end();itr++)#define repV(i,v) for(auto i:v)#define repE(i,v) for(auto &amp;i:v)#define MS(x,y) memset(x,y,sizeof(x))#define MC(x) MS(x,0)#define MINF(x) MS(x,63)#define MCP(x,y) memcpy(x,y,sizeof(y))#define sqr(x) ((x)*(x))#define UN(v) sort(All(v)),v.erase(unique(All(v)),v.end())#define filein(x) freopen(x,"r",stdin)#define fileout(x) freopen(x,"w",stdout)#define fileio(x)\ freopen(x".in","r",stdin);\ freopen(x".out","w",stdout)#define filein2(filename,name) ifstream name(filename,ios::in)#define fileout2(filename,name) ofstream name(filename,ios::out)#define file(filename,name) fstream name(filename,ios::in|ios::out)#define Pause system("pause")#define Cls system("cls")#define fs first#define sc second#define PC(x) putchar(x)#define GC(x) x=getchar()#define Endl PC('\n')#define SF scanf#define PF printfinline int Read()&#123; int X=0,w=0;char ch=0;while(!isdigit(ch))&#123;w|=ch=='-';ch=getchar();&#125;while(isdigit(ch))X=(X&lt;&lt;3)+(X&lt;&lt;1)+(ch^48),ch=getchar(); return w?-X:X;&#125;inline void Write(int x)&#123;if(x&lt;0)putchar('-'),x=-x;if(x&gt;9)Write(x/10);putchar(x%10+'0');&#125;inline LL powmod(LL a,LL b)&#123;LL RES=1;a%=MOD;assert(b&gt;=0);for(;b;b&gt;&gt;=1)&#123;if(b&amp;1)RES=RES*a%MOD;a=a*a%MOD;&#125;return RES%MOD;&#125;inline LL gcdll(LL a,LL b)&#123;return b?gcdll(b,a%b):a;&#125;const int dx[]=&#123;0,1,0,-1,1,-1,-1,1&#125;;const int dy[]=&#123;1,0,-1,0,-1,-1,1,1&#125;;/************************************************************Begin************************************************************/const int maxn=1000000000;int tim,n,p,q;vector&lt;int&gt; pri;bool isp[100010];inline void exgcd(int a,int b,int &amp;x,int &amp;y)&#123; if(b) &#123; exgcd(b,a%b,y,x); y-=a/b*x; &#125; else &#123; x=1; y=0; &#125;&#125;int main()&#123; for(int i=2;i&lt;=100000;i++) if(!isp[i]) &#123; pri.push_back(i); for(int j=i*2;j&lt;=100000;j+=i) isp[i]=1; &#125; SF("%d",&amp;tim); while(tim--) &#123; SF("%d",&amp;n); repV(i,pri) if(n%i==0) &#123; p=i; q=n/i; break; &#125; int x,y,ans1,ans2; exgcd(p,q,x,y); ans1=x&gt;0?x*p:x*p+n; exgcd(q,p,x,y); ans2=x&gt;0?x*q:x*q+n; PF("0 1 %d %d\n",min(ans1,ans2),max(ans1,ans2)); &#125; return 0;&#125;/*************************************************************End**************************************************************/]]></content>
      <categories>
        <category>算法</category>
        <category>Ural</category>
      </categories>
      <tags>
        <tag>数学</tag>
        <tag>拓展欧几里得</tag>
        <tag>同余</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Ural 1298 Knight 题解]]></title>
    <url>%2F2019%2F08%2F18%2FUral-1298-Knight-%E9%A2%98%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[Ural 1298 Knight 题解题意给定一个$n\times n(1\le n\le8)$的国际象棋棋盘和一个骑士(基本上相当于中国象棋的马)，问可否用经过每个格子$1$次。如果可以，输出路径，否则输出IMPOSSIBLE。 题解考虑回溯。暴力程序十分好写，但是会超时。 可以用启发式优化。 设当前点为$(x,y)$，可到达的点为$(x’,y’)$。优先选择$(x’,y’)$状态种数少的回溯，即可以转移的格子的数量少。 这样优化后就可以过了。 Tip: 优化后很快，为0.015s。 程序123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260// #pragma GCC optimize(2)// #pragma G++ optimize(2)// #pragma comment(linker,"/STACK:102400000,102400000")// #include &lt;bits/stdc++.h&gt;#include &lt;map&gt;#include &lt;set&gt;#include &lt;list&gt;#include &lt;array&gt;#include &lt;cfenv&gt;#include &lt;cmath&gt;#include &lt;ctime&gt;#include &lt;deque&gt;#include &lt;mutex&gt;#include &lt;queue&gt;#include &lt;ratio&gt;#include &lt;regex&gt;#include &lt;stack&gt;#include &lt;tuple&gt;#include &lt;atomic&gt;#include &lt;bitset&gt;#include &lt;cctype&gt;#include &lt;cerrno&gt;#include &lt;cfloat&gt;#include &lt;chrono&gt;#include &lt;cstdio&gt;#include &lt;cwchar&gt;#include &lt;future&gt;#include &lt;limits&gt;#include &lt;locale&gt;#include &lt;memory&gt;#include &lt;random&gt;#include &lt;string&gt;#include &lt;thread&gt;#include &lt;vector&gt;#include &lt;cassert&gt;#include &lt;climits&gt;#include &lt;clocale&gt;#include &lt;complex&gt;#include &lt;csetjmp&gt;#include &lt;csignal&gt;#include &lt;cstdarg&gt;#include &lt;cstddef&gt;#include &lt;cstdint&gt;#include &lt;cstdlib&gt;#include &lt;cstring&gt;#include &lt;ctgmath&gt;#include &lt;cwctype&gt;#include &lt;fstream&gt;#include &lt;iomanip&gt;#include &lt;numeric&gt;#include &lt;sstream&gt;#include &lt;ccomplex&gt;#include &lt;cstdbool&gt;#include &lt;iostream&gt;#include &lt;typeinfo&gt;#include &lt;valarray&gt;#include &lt;algorithm&gt;#include &lt;cinttypes&gt;#include &lt;cstdalign&gt;#include &lt;stdexcept&gt;#include &lt;typeindex&gt;#include &lt;functional&gt;#include &lt;forward_list&gt;#include &lt;system_error&gt;#include &lt;unordered_map&gt;#include &lt;unordered_set&gt;#include &lt;scoped_allocator&gt;#include &lt;condition_variable&gt;// #include &lt;conio.h&gt;// #include &lt;windows.h&gt;using namespace std;typedef long long LL;typedef unsigned int ui;typedef unsigned long long ull;typedef float fl;typedef double ld;typedef long double LD;typedef pair&lt;int,int&gt; pii;#if (WIN32) || (WIN64) || (__WIN32) || (__WIN64) || (_WIN32) || (_WIN64) || (WINDOWS)#define lld "%I64d"#define llu "%I64u"#else#define lld "%lld"#define llu "%llu"#endif#define ui(n) ((unsigned int)(n))#define LL(n) ((long long)(n))#define ull(n) ((unsigned long long)(n))#define fl(n) ((float)(n))#define ld(n) ((double)(n))#define LD(n) ((long double)(n))#define char(n) ((char)(n))#define Bool(n) ((bool)(n))#define fixpoint(n) fixed&lt;&lt;setprecision(n)const int INF=1061109567;const int NINF=-1044266559;const LL LINF=4557430888798830399;const ld eps=1e-15;#define MOD (1000000007)#define PI (3.1415926535897932384626433832795028841971)/*#define MB_LEN_MAX 5#define SHRT_MIN (-32768)#define SHRT_MAX 32767#define USHRT_MAX 0xffffU#define INT_MIN (-2147483647 - 1)#define INT_MAX 2147483647#define UINT_MAX 0xffffffffU#define LONG_MIN (-2147483647L - 1)#define LONG_MAX 2147483647L#define ULONG_MAX 0xffffffffUL#define LLONG_MAX 9223372036854775807ll#define LLONG_MIN (-9223372036854775807ll - 1)#define ULLONG_MAX 0xffffffffffffffffull*/#define MP make_pair#define MT make_tuple#define All(a) (a).begin(),(a).end()#define pall(a) (a).rbegin(),(a).rend()#define log2(x) log(x)/log(2)#define Log(x,y) log(x)/log(y)#define SZ(a) ((int)(a).size())#define rep(i,n) for(int i=0;i&lt;((int)(n));i++)#define rep1(i,n) for(int i=1;i&lt;=((int)(n));i++)#define repa(i,a,n) for(int i=((int)(a));i&lt;((int)(n));i++)#define repa1(i,a,n) for(int i=((int)(a));i&lt;=((int)(n));i++)#define repd(i,n) for(int i=((int)(n))-1;i&gt;=0;i--)#define repd1(i,n) for(int i=((int)(n));i&gt;=1;i--)#define repda(i,n,a) for(int i=((int)(n));i&gt;((int)(a));i--)#define repda1(i,n,a) for(int i=((int)(n));i&gt;=((int)(a));i--)#define FOR(i,a,n,step) for(int i=((int)(a));i&lt;((int)(n));i+=((int)(step)))#define repv(itr,v) for(__typeof((v).begin()) itr=(v).begin();itr!=(v).end();itr++)#define repV(i,v) for(auto i:v)#define repE(i,v) for(auto &amp;i:v)#define MS(x,y) memset(x,y,sizeof(x))#define MC(x) MS(x,0)#define MINF(x) MS(x,63)#define MCP(x,y) memcpy(x,y,sizeof(y))#define sqr(x) ((x)*(x))#define UN(v) sort(All(v)),v.erase(unique(All(v)),v.end())#define filein(x) freopen(x,"r",stdin)#define fileout(x) freopen(x,"w",stdout)#define fileio(x)\ freopen(x".in","r",stdin);\ freopen(x".out","w",stdout)#define filein2(filename,name) ifstream name(filename,ios::in)#define fileout2(filename,name) ofstream name(filename,ios::out)#define file(filename,name) fstream name(filename,ios::in|ios::out)#define Pause system("pause")#define Cls system("cls")#define fs first#define sc second#define PC(x) putchar(x)#define GC(x) x=getchar()#define Endl PC('\n')#define SF scanf#define PF printfinline int Read()&#123; int X=0,w=0;char ch=0;while(!isdigit(ch))&#123;w|=ch=='-';ch=getchar();&#125;while(isdigit(ch))X=(X&lt;&lt;3)+(X&lt;&lt;1)+(ch^48),ch=getchar(); return w?-X:X;&#125;inline void Write(int x)&#123;if(x&lt;0)putchar('-'),x=-x;if(x&gt;9)Write(x/10);putchar(x%10+'0');&#125;inline LL powmod(LL a,LL b)&#123;LL RES=1;a%=MOD;assert(b&gt;=0);for(;b;b&gt;&gt;=1)&#123;if(b&amp;1)RES=RES*a%MOD;a=a*a%MOD;&#125;return RES%MOD;&#125;inline LL gcdll(LL a,LL b)&#123;return b?gcdll(b,a%b):a;&#125;const int dx[]=&#123;1,1,2,2,-1,-1,-2,-2&#125;;const int dy[]=&#123;2,-2,1,-1,2,-2,1,-1&#125;;/************************************************************Begin************************************************************/const int maxn=10;int n,cnt[maxn][maxn];bool vis[maxn][maxn];pair&lt;int,int&gt; pre[maxn][maxn];vector&lt;pair&lt;int,int&gt; &gt; v;inline bool ok()&#123; rep(i,n) rep(j,n) if(!vis[i][j]) return 0; return 1;&#125;inline void print(int x,int y)&#123; if(pre[x][y].fs!=-1) print(pre[x][y].fs,pre[x][y].sc); PF("%c%c\n",char(x+'a'),char(y+'1'));&#125;inline bool cmp(pair&lt;int,int&gt; x,pair&lt;int,int&gt; y)&#123; return cnt[x.fs][x.sc]&lt;cnt[y.fs][y.sc];&#125;inline void dfs(int x,int y)&#123; vis[x][y]=1; if(ok()) &#123; print(x,y); exit(0); &#125; vector&lt;pair&lt;int,int&gt; &gt; w;w.clear(); rep(i,8) &#123; int cx=x+dx[i],cy=y+dy[i]; if(cx&gt;=0&amp;&amp;cx&lt;n&amp;&amp;cy&gt;=0&amp;&amp;cy&lt;n&amp;&amp;!vis[cx][cy]) w.push_back(&#123;cx,cy&#125;); &#125; sort(All(w),cmp); repV(i,w) &#123; int cx=i.fs,cy=i.sc; pre[cx][cy]=&#123;x,y&#125;; dfs(cx,cy); &#125; vis[x][y]=0;&#125;int main()&#123; SF("%d",&amp;n); rep(i,n) rep(j,n) &#123; v.push_back(&#123;i,j&#125;); rep(k,8) &#123; int ci=i+dx[k],cj=j+dy[k]; if(ci&gt;=0&amp;&amp;ci&lt;n&amp;&amp;cj&gt;=0&amp;&amp;cj&lt;n) cnt[i][j]++; &#125; &#125; sort(All(v),cmp); repV(it,v) &#123; int i=it.fs,j=it.sc; MC(vis); MC(pre); pre[i][j]=&#123;-1,-1&#125;; dfs(i,j); &#125; PF("IMPOSSIBLE"); return 0;&#125;/*************************************************************End**************************************************************/]]></content>
      <categories>
        <category>算法</category>
        <category>Ural</category>
      </categories>
      <tags>
        <tag>回溯</tag>
        <tag>启发式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Ural 1248 Sequence Sum 题解]]></title>
    <url>%2F2019%2F08%2F18%2FUral-1248-Sequence-Sum-%E9%A2%98%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[Ural 1248 Sequence Sum 题解题意给定$n$个用科学计数法表示的实数$(10^{-100}\sim10^{100})$，输出它们的和。 Tip: 一个实数可以用科学计数法表示为$x\times10^y$，其中$1\le x&lt;10$ $x$为实数，$y$是整数。输入时表示为$xey$。保证输入的实数有$19$位有效数字。输出时用科学计数法，必须包括$19$位正确数字。 题解 读入字符串，把它们换成正常形态放入数组。 小数点对齐。 计算。 换成科学计数法输出。 Tip: 口胡得很简单，写起来可能有点麻烦，要仔细。 程序123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273// #pragma GCC optimize(2)// #pragma G++ optimize(2)// #pragma comment(linker,"/STACK:102400000,102400000")// #include &lt;bits/stdc++.h&gt;#include &lt;map&gt;#include &lt;set&gt;#include &lt;list&gt;#include &lt;array&gt;#include &lt;cfenv&gt;#include &lt;cmath&gt;#include &lt;ctime&gt;#include &lt;deque&gt;#include &lt;mutex&gt;#include &lt;queue&gt;#include &lt;ratio&gt;#include &lt;regex&gt;#include &lt;stack&gt;#include &lt;tuple&gt;#include &lt;atomic&gt;#include &lt;bitset&gt;#include &lt;cctype&gt;#include &lt;cerrno&gt;#include &lt;cfloat&gt;#include &lt;chrono&gt;#include &lt;cstdio&gt;#include &lt;cwchar&gt;#include &lt;future&gt;#include &lt;limits&gt;#include &lt;locale&gt;#include &lt;memory&gt;#include &lt;random&gt;#include &lt;string&gt;#include &lt;thread&gt;#include &lt;vector&gt;#include &lt;cassert&gt;#include &lt;climits&gt;#include &lt;clocale&gt;#include &lt;complex&gt;#include &lt;csetjmp&gt;#include &lt;csignal&gt;#include &lt;cstdarg&gt;#include &lt;cstddef&gt;#include &lt;cstdint&gt;#include &lt;cstdlib&gt;#include &lt;cstring&gt;#include &lt;ctgmath&gt;#include &lt;cwctype&gt;#include &lt;fstream&gt;#include &lt;iomanip&gt;#include &lt;numeric&gt;#include &lt;sstream&gt;#include &lt;ccomplex&gt;#include &lt;cstdbool&gt;#include &lt;iostream&gt;#include &lt;typeinfo&gt;#include &lt;valarray&gt;#include &lt;algorithm&gt;#include &lt;cinttypes&gt;#include &lt;cstdalign&gt;#include &lt;stdexcept&gt;#include &lt;typeindex&gt;#include &lt;functional&gt;#include &lt;forward_list&gt;#include &lt;system_error&gt;#include &lt;unordered_map&gt;#include &lt;unordered_set&gt;#include &lt;scoped_allocator&gt;#include &lt;condition_variable&gt;// #include &lt;conio.h&gt;// #include &lt;windows.h&gt;using namespace std;typedef long long LL;typedef unsigned int ui;typedef unsigned long long ull;typedef float fl;typedef double ld;typedef long double LD;typedef pair&lt;int,int&gt; pii;#if (WIN32) || (WIN64) || (__WIN32) || (__WIN64) || (_WIN32) || (_WIN64) || (WINDOWS)#define lld "%I64d"#define llu "%I64u"#else#define lld "%lld"#define llu "%llu"#endif#define ui(n) ((unsigned int)(n))#define LL(n) ((long long)(n))#define ull(n) ((unsigned long long)(n))#define fl(n) ((float)(n))#define ld(n) ((double)(n))#define LD(n) ((long double)(n))#define char(n) ((char)(n))#define Bool(n) ((bool)(n))#define fixpoint(n) fixed&lt;&lt;setprecision(n)const int INF=1061109567;const int NINF=-1044266559;const LL LINF=4557430888798830399;const ld eps=1e-15;#define MOD (1000000007)#define PI (3.1415926535897932384626433832795028841971)/*#define MB_LEN_MAX 5#define SHRT_MIN (-32768)#define SHRT_MAX 32767#define USHRT_MAX 0xffffU#define INT_MIN (-2147483647 - 1)#define INT_MAX 2147483647#define UINT_MAX 0xffffffffU#define LONG_MIN (-2147483647L - 1)#define LONG_MAX 2147483647L#define ULONG_MAX 0xffffffffUL#define LLONG_MAX 9223372036854775807ll#define LLONG_MIN (-9223372036854775807ll - 1)#define ULLONG_MAX 0xffffffffffffffffull*/#define MP make_pair#define MT make_tuple#define All(a) (a).begin(),(a).end()#define pall(a) (a).rbegin(),(a).rend()#define log2(x) log(x)/log(2)#define Log(x,y) log(x)/log(y)#define SZ(a) ((int)(a).size())#define rep(i,n) for(int i=0;i&lt;((int)(n));i++)#define rep1(i,n) for(int i=1;i&lt;=((int)(n));i++)#define repa(i,a,n) for(int i=((int)(a));i&lt;((int)(n));i++)#define repa1(i,a,n) for(int i=((int)(a));i&lt;=((int)(n));i++)#define repd(i,n) for(int i=((int)(n))-1;i&gt;=0;i--)#define repd1(i,n) for(int i=((int)(n));i&gt;=1;i--)#define repda(i,n,a) for(int i=((int)(n));i&gt;((int)(a));i--)#define repda1(i,n,a) for(int i=((int)(n));i&gt;=((int)(a));i--)#define FOR(i,a,n,step) for(int i=((int)(a));i&lt;((int)(n));i+=((int)(step)))#define repv(itr,v) for(__typeof((v).begin()) itr=(v).begin();itr!=(v).end();itr++)#define repV(i,v) for(auto i:v)#define repE(i,v) for(auto &amp;i:v)#define MS(x,y) memset(x,y,sizeof(x))#define MC(x) MS(x,0)#define MINF(x) MS(x,63)#define MCP(x,y) memcpy(x,y,sizeof(y))#define sqr(x) ((x)*(x))#define UN(v) sort(All(v)),v.erase(unique(All(v)),v.end())#define filein(x) freopen(x,"r",stdin)#define fileout(x) freopen(x,"w",stdout)#define fileio(x)\ freopen(x".in","r",stdin);\ freopen(x".out","w",stdout)#define filein2(filename,name) ifstream name(filename,ios::in)#define fileout2(filename,name) ofstream name(filename,ios::out)#define file(filename,name) fstream name(filename,ios::in|ios::out)#define Pause system("pause")#define Cls system("cls")#define fs first#define sc second#define PC(x) putchar(x)#define GC(x) x=getchar()#define Endl PC('\n')#define SF scanf#define PF printfinline int Read()&#123; int X=0,w=0;char ch=0;while(!isdigit(ch))&#123;w|=ch=='-';ch=getchar();&#125;while(isdigit(ch))X=(X&lt;&lt;3)+(X&lt;&lt;1)+(ch^48),ch=getchar(); return w?-X:X;&#125;inline void Write(int x)&#123;if(x&lt;0)putchar('-'),x=-x;if(x&gt;9)Write(x/10);putchar(x%10+'0');&#125;inline LL powmod(LL a,LL b)&#123;LL RES=1;a%=MOD;assert(b&gt;=0);for(;b;b&gt;&gt;=1)&#123;if(b&amp;1)RES=RES*a%MOD;a=a*a%MOD;&#125;return RES%MOD;&#125;inline LL gcdll(LL a,LL b)&#123;return b?gcdll(b,a%b):a;&#125;const int dx[]=&#123;0,1,0,-1,1,-1,-1,1&#125;;const int dy[]=&#123;1,0,-1,0,-1,-1,1,1&#125;;/************************************************************Begin************************************************************/const int maxn=1010;const int Dot=500;int n,dig[maxn][maxn];inline int Atoi(string x)&#123; int res=0; repV(i,x) if(isdigit(i)) res=(res+i-'0')*10;res/=10; return (x[0]=='-'?-res:res);&#125;inline void func(int k,string x)&#123; int e=x.find("e"); string a=x.substr(0,e),b=x.substr(e+1); if(a.find(".")==string::npos) a+='.'; rep(i,101) a='0'+a; rep(i,101) a+='0'; int dot=a.find(".")+Atoi(b)-(b[0]=='-'?1:0); int hav=0; repd(i,dot+1) &#123; if(a[i]=='.') &#123; hav=1; continue; &#125; dig[k][Dot-(dot-i+1)+hav]=a[i]-'0'; &#125; hav=0; repa(i,dot+1,a.size()) &#123; if(a[i]=='.') &#123; hav=1; continue; &#125; dig[k][Dot+(i-dot)-hav]=a[i]-'0'; &#125;&#125;int main()&#123; cin&gt;&gt;n; rep(i,n) &#123; string x;cin&gt;&gt;x; func(i,x); &#125; rep(i,n) rep(j,1000) dig[n][j]+=dig[i][j]; repd(j,1000) &#123; while(dig[n][j]&gt;=10) &#123; int hav=0; if(j-1==Dot) hav=1; dig[n][j-1-hav]+=dig[n][j]/10; dig[n][j]%=10; &#125; &#125; int w=INF,e=0; rep(i,Dot) if(dig[n][i]) &#123; w=i; e=Dot-w-1; break; &#125; if(w==INF) &#123; repa(i,Dot+1,1000) if(dig[n][i]) &#123; w=i; e=i-Dot; break; &#125; e=-e; &#125; cout&lt;&lt;dig[n][w]&lt;&lt;'.'; repa(i,w+1,w+20) if(i!=Dot) cout&lt;&lt;dig[n][i]; cout&lt;&lt;'e'&lt;&lt;e; return 0;&#125;/*************************************************************End**************************************************************/]]></content>
      <categories>
        <category>算法</category>
        <category>Ural</category>
      </categories>
      <tags>
        <tag>数论</tag>
        <tag>模拟</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Ural 1238 Folding 题解]]></title>
    <url>%2F2019%2F08%2F18%2FUral-1238-Folding-%E9%A2%98%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[Ural 1238 Folding 题解题意定义折叠、展开为： 单个大写英文字母是一个折叠的串，把它展开后是它本身。 如果$S$和$Q$是折叠的串，则$SQ$也是折叠的串。如果$S$展开后为$S’$，$Q$展开后为$Q’$，则$SQ$展开后为$S’Q’$。 如果$S$是个折叠的串，则$X(S)$也是折叠的串，其中$X$是一个十进制大于$1$的整数，如果$S$展开为$S’$，则$X(S)$展开后为$S’$重复$X$次。 给定一个字符串(长度小于等于$100$)，求把它折叠后有最小长度的那个字符串。 题解考虑记忆化搜索(DP也可以)。 定义$f(s)$为$s$字符串折叠后有最小长度的那个字符串。 边界为当$|s|\le4$($|s|$为$s$的长度)时，$f(s)=s$。 给定$s$，求出$f(s)$有以下几种方式 $f(s)=s$。 设$1&lt;x\le|s|,|s|\%x=0$且有字符串$q$，$q$重复$x$次为$s$，$f(s)=x“(”+f(q)+“)”$。 设$0&lt;i&lt;|s|$，$f(s)=f(s[0..i-1])+f(s[i..|s|-1])$。 取长度最小的值即可，不要忘了记忆化。 程序123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230// #pragma GCC optimize(2)// #pragma G++ optimize(2)// #pragma comment(linker,"/STACK:102400000,102400000")// #include &lt;bits/stdc++.h&gt;#include &lt;map&gt;#include &lt;set&gt;#include &lt;list&gt;#include &lt;array&gt;#include &lt;cfenv&gt;#include &lt;cmath&gt;#include &lt;ctime&gt;#include &lt;deque&gt;#include &lt;mutex&gt;#include &lt;queue&gt;#include &lt;ratio&gt;#include &lt;regex&gt;#include &lt;stack&gt;#include &lt;tuple&gt;#include &lt;atomic&gt;#include &lt;bitset&gt;#include &lt;cctype&gt;#include &lt;cerrno&gt;#include &lt;cfloat&gt;#include &lt;chrono&gt;#include &lt;cstdio&gt;#include &lt;cwchar&gt;#include &lt;future&gt;#include &lt;limits&gt;#include &lt;locale&gt;#include &lt;memory&gt;#include &lt;random&gt;#include &lt;string&gt;#include &lt;thread&gt;#include &lt;vector&gt;#include &lt;cassert&gt;#include &lt;climits&gt;#include &lt;clocale&gt;#include &lt;complex&gt;#include &lt;csetjmp&gt;#include &lt;csignal&gt;#include &lt;cstdarg&gt;#include &lt;cstddef&gt;#include &lt;cstdint&gt;#include &lt;cstdlib&gt;#include &lt;cstring&gt;#include &lt;ctgmath&gt;#include &lt;cwctype&gt;#include &lt;fstream&gt;#include &lt;iomanip&gt;#include &lt;numeric&gt;#include &lt;sstream&gt;#include &lt;ccomplex&gt;#include &lt;cstdbool&gt;#include &lt;iostream&gt;#include &lt;typeinfo&gt;#include &lt;valarray&gt;#include &lt;algorithm&gt;#include &lt;cinttypes&gt;#include &lt;cstdalign&gt;#include &lt;stdexcept&gt;#include &lt;typeindex&gt;#include &lt;functional&gt;#include &lt;forward_list&gt;#include &lt;system_error&gt;#include &lt;unordered_map&gt;#include &lt;unordered_set&gt;#include &lt;scoped_allocator&gt;#include &lt;condition_variable&gt;// #include &lt;conio.h&gt;// #include &lt;windows.h&gt;using namespace std;typedef long long LL;typedef unsigned int ui;typedef unsigned long long ull;typedef float fl;typedef double ld;typedef long double LD;typedef pair&lt;int,int&gt; pii;#if (WIN32) || (WIN64) || (__WIN32) || (__WIN64) || (_WIN32) || (_WIN64) || (WINDOWS)#define lld "%I64d"#define llu "%I64u"#else#define lld "%lld"#define llu "%llu"#endif#define ui(n) ((unsigned int)(n))#define LL(n) ((long long)(n))#define ull(n) ((unsigned long long)(n))#define fl(n) ((float)(n))#define ld(n) ((double)(n))#define LD(n) ((long double)(n))#define char(n) ((char)(n))#define Bool(n) ((bool)(n))#define fixpoint(n) fixed&lt;&lt;setprecision(n)const int INF=1061109567;const int NINF=-1044266559;const LL LINF=4557430888798830399;const ld eps=1e-15;#define MOD (1000000007)#define PI (3.1415926535897932384626433832795028841971)/*#define MB_LEN_MAX 5#define SHRT_MIN (-32768)#define SHRT_MAX 32767#define USHRT_MAX 0xffffU#define INT_MIN (-2147483647 - 1)#define INT_MAX 2147483647#define UINT_MAX 0xffffffffU#define LONG_MIN (-2147483647L - 1)#define LONG_MAX 2147483647L#define ULONG_MAX 0xffffffffUL#define LLONG_MAX 9223372036854775807ll#define LLONG_MIN (-9223372036854775807ll - 1)#define ULLONG_MAX 0xffffffffffffffffull*/#define MP make_pair#define MT make_tuple#define All(a) (a).begin(),(a).end()#define pall(a) (a).rbegin(),(a).rend()#define log2(x) log(x)/log(2)#define Log(x,y) log(x)/log(y)#define SZ(a) ((int)(a).size())#define rep(i,n) for(int i=0;i&lt;((int)(n));i++)#define rep1(i,n) for(int i=1;i&lt;=((int)(n));i++)#define repa(i,a,n) for(int i=((int)(a));i&lt;((int)(n));i++)#define repa1(i,a,n) for(int i=((int)(a));i&lt;=((int)(n));i++)#define repd(i,n) for(int i=((int)(n))-1;i&gt;=0;i--)#define repd1(i,n) for(int i=((int)(n));i&gt;=1;i--)#define repda(i,n,a) for(int i=((int)(n));i&gt;((int)(a));i--)#define repda1(i,n,a) for(int i=((int)(n));i&gt;=((int)(a));i--)#define FOR(i,a,n,step) for(int i=((int)(a));i&lt;((int)(n));i+=((int)(step)))#define repv(itr,v) for(__typeof((v).begin()) itr=(v).begin();itr!=(v).end();itr++)#define repV(i,v) for(auto i:v)#define repE(i,v) for(auto &amp;i:v)#define MS(x,y) memset(x,y,sizeof(x))#define MC(x) MS(x,0)#define MINF(x) MS(x,63)#define MCP(x,y) memcpy(x,y,sizeof(y))#define sqr(x) ((x)*(x))#define UN(v) sort(All(v)),v.erase(unique(All(v)),v.end())#define filein(x) freopen(x,"r",stdin)#define fileout(x) freopen(x,"w",stdout)#define fileio(x)\ freopen(x".in","r",stdin);\ freopen(x".out","w",stdout)#define filein2(filename,name) ifstream name(filename,ios::in)#define fileout2(filename,name) ofstream name(filename,ios::out)#define file(filename,name) fstream name(filename,ios::in|ios::out)#define Pause system("pause")#define Cls system("cls")#define fs first#define sc second#define PC(x) putchar(x)#define GC(x) x=getchar()#define Endl PC('\n')#define SF scanf#define PF printfinline int Read()&#123; int X=0,w=0;char ch=0;while(!isdigit(ch))&#123;w|=ch=='-';ch=getchar();&#125;while(isdigit(ch))X=(X&lt;&lt;3)+(X&lt;&lt;1)+(ch^48),ch=getchar(); return w?-X:X;&#125;inline void Write(int x)&#123;if(x&lt;0)putchar('-'),x=-x;if(x&gt;9)Write(x/10);putchar(x%10+'0');&#125;inline LL powmod(LL a,LL b)&#123;LL RES=1;a%=MOD;assert(b&gt;=0);for(;b;b&gt;&gt;=1)&#123;if(b&amp;1)RES=RES*a%MOD;a=a*a%MOD;&#125;return RES%MOD;&#125;inline LL gcdll(LL a,LL b)&#123;return b?gcdll(b,a%b):a;&#125;const int dx[]=&#123;0,1,0,-1,1,-1,-1,1&#125;;const int dy[]=&#123;1,0,-1,0,-1,-1,1,1&#125;;/************************************************************Begin************************************************************/const int maxn=110;inline string Itoa(int x)&#123; string res=""; while(x) &#123; res+=char(x%10+'0'); x/=10; &#125; reverse(All(res)); return res;&#125;map&lt;string,string&gt; vis;inline string sol(string s)&#123; if(vis.count(s)) return vis[s]; if(s.size()&lt;=4) return vis[s]=s; string ans=s; rep1(i,s.size()) if(i&gt;1&amp;&amp;s.size()%i==0) &#123; int len=s.size()/i; string x=s.substr(0,len); bool f=1; for(int j=0;j&lt;s.size();j+=len) if(s.substr(j,len)!=x) f=0; if(f) &#123; string res=Itoa(i)+'('+sol(x)+')'; if(ans.size()&gt;res.size()) ans=res; &#125; &#125; rep1(i,s.size()-1) &#123; string res=sol(s.substr(0,i))+sol(s.substr(i)); if(ans.size()&gt;res.size()) ans=res; &#125; return vis[s]=ans;&#125;int main()&#123; string s; cin&gt;&gt;s; cout&lt;&lt;sol(s); return 0;&#125;/*************************************************************End**************************************************************/]]></content>
      <categories>
        <category>算法</category>
        <category>Ural</category>
      </categories>
      <tags>
        <tag>DP</tag>
        <tag>字符串</tag>
        <tag>记忆化搜索</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Ural 1201 Which Day Is It 题解]]></title>
    <url>%2F2019%2F08%2F18%2FUral-1201-Which-Day-Is-It-%E9%A2%98%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[Ural 1201 Which Day Is It? 题解题意打印一个月历。 输入输入日$(1\sim31)$、月$(1\sim12)$、年$(1600\sim2400)$。 输出123456789输入: 16 3 2002输出:mon........4...11...18...25tue........5...12...19...26wed........6...13...20...27thu........7...14...21...28fri...1....8...15...22...29sat...2....9..[16]..23...30sun...3...10...17...24...31 123456789输入: 1 3 2002输出:mon........4...11...18...25tue........5...12...19...26wed........6...13...20...27thu........7...14...21...28fri.[.1]...8...15...22...29sat...2....9...16...23...30sun...3...10...17...24...31 打印$7$行，mon tue…这些都懂吧。在输入的那天打上[]。 Tips: 样例输出中的.其实是 (空格)。 输出的第一列日期前有三个.，第二列即以后一位数前有$4$个，两位数前有$3$个。 例: 123456789输入: 30 1 2012输出:mon........2....9...16...23..[30]tue........3...10...17...24...31wed........4...11...18...25.....thu........5...12...19...26.....fri........6...13...20...27.....sat........7...14...21...28.....sun...1....8...15...22...29..... 如果输入的那一天是个一位数，则打印$[.x]$。 题解 找出这一个月的第一天是星期几。 知道1.1.1(公元元年1月1日)是星期一。 暴力推一下就可以了。 打印月历。 Tip: 口胡得很简单，写起来可能有点麻烦，要仔细。 程序123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270// #pragma GCC optimize(2)// #pragma G++ optimize(2)// #pragma comment(linker,"/STACK:102400000,102400000")// #include &lt;bits/stdc++.h&gt;#include &lt;map&gt;#include &lt;set&gt;#include &lt;list&gt;#include &lt;array&gt;#include &lt;cfenv&gt;#include &lt;cmath&gt;#include &lt;ctime&gt;#include &lt;deque&gt;#include &lt;mutex&gt;#include &lt;queue&gt;#include &lt;ratio&gt;#include &lt;regex&gt;#include &lt;stack&gt;#include &lt;tuple&gt;#include &lt;atomic&gt;#include &lt;bitset&gt;#include &lt;cctype&gt;#include &lt;cerrno&gt;#include &lt;cfloat&gt;#include &lt;chrono&gt;#include &lt;cstdio&gt;#include &lt;cwchar&gt;#include &lt;future&gt;#include &lt;limits&gt;#include &lt;locale&gt;#include &lt;memory&gt;#include &lt;random&gt;#include &lt;string&gt;#include &lt;thread&gt;#include &lt;vector&gt;#include &lt;cassert&gt;#include &lt;climits&gt;#include &lt;clocale&gt;#include &lt;complex&gt;#include &lt;csetjmp&gt;#include &lt;csignal&gt;#include &lt;cstdarg&gt;#include &lt;cstddef&gt;#include &lt;cstdint&gt;#include &lt;cstdlib&gt;#include &lt;cstring&gt;#include &lt;ctgmath&gt;#include &lt;cwctype&gt;#include &lt;fstream&gt;#include &lt;iomanip&gt;#include &lt;numeric&gt;#include &lt;sstream&gt;#include &lt;ccomplex&gt;#include &lt;cstdbool&gt;#include &lt;iostream&gt;#include &lt;typeinfo&gt;#include &lt;valarray&gt;#include &lt;algorithm&gt;#include &lt;cinttypes&gt;#include &lt;cstdalign&gt;#include &lt;stdexcept&gt;#include &lt;typeindex&gt;#include &lt;functional&gt;#include &lt;forward_list&gt;#include &lt;system_error&gt;#include &lt;unordered_map&gt;#include &lt;unordered_set&gt;#include &lt;scoped_allocator&gt;#include &lt;condition_variable&gt;// #include &lt;conio.h&gt;// #include &lt;windows.h&gt;using namespace std;typedef long long LL;typedef unsigned int ui;typedef unsigned long long ull;typedef float fl;typedef double ld;typedef long double LD;typedef pair&lt;int,int&gt; pii;#if (WIN32) || (WIN64) || (__WIN32) || (__WIN64) || (_WIN32) || (_WIN64) || (WINDOWS)#define lld "%I64d"#define llu "%I64u"#else#define lld "%lld"#define llu "%llu"#endif#define ui(n) ((unsigned int)(n))#define LL(n) ((long long)(n))#define ull(n) ((unsigned long long)(n))#define fl(n) ((float)(n))#define ld(n) ((double)(n))#define LD(n) ((long double)(n))#define char(n) ((char)(n))#define Bool(n) ((bool)(n))#define fixpoint(n) fixed&lt;&lt;setprecision(n)const int INF=1061109567;const int NINF=-1044266559;const LL LINF=4557430888798830399;const ld eps=1e-15;#define MOD (1000000007)#define PI (3.1415926535897932384626433832795028841971)/*#define MB_LEN_MAX 5#define SHRT_MIN (-32768)#define SHRT_MAX 32767#define USHRT_MAX 0xffffU#define INT_MIN (-2147483647 - 1)#define INT_MAX 2147483647#define UINT_MAX 0xffffffffU#define LONG_MIN (-2147483647L - 1)#define LONG_MAX 2147483647L#define ULONG_MAX 0xffffffffUL#define LLONG_MAX 9223372036854775807ll#define LLONG_MIN (-9223372036854775807ll - 1)#define ULLONG_MAX 0xffffffffffffffffull*/#define MP make_pair#define MT make_tuple#define All(a) (a).begin(),(a).end()#define pall(a) (a).rbegin(),(a).rend()#define log2(x) log(x)/log(2)#define Log(x,y) log(x)/log(y)#define SZ(a) ((int)(a).size())#define rep(i,n) for(int i=0;i&lt;((int)(n));i++)#define rep1(i,n) for(int i=1;i&lt;=((int)(n));i++)#define repa(i,a,n) for(int i=((int)(a));i&lt;((int)(n));i++)#define repa1(i,a,n) for(int i=((int)(a));i&lt;=((int)(n));i++)#define repd(i,n) for(int i=((int)(n))-1;i&gt;=0;i--)#define repd1(i,n) for(int i=((int)(n));i&gt;=1;i--)#define repda(i,n,a) for(int i=((int)(n));i&gt;((int)(a));i--)#define repda1(i,n,a) for(int i=((int)(n));i&gt;=((int)(a));i--)#define FOR(i,a,n,step) for(int i=((int)(a));i&lt;((int)(n));i+=((int)(step)))#define repv(itr,v) for(__typeof((v).begin()) itr=(v).begin();itr!=(v).end();itr++)#define repV(i,v) for(auto i:v)#define repE(i,v) for(auto &amp;i:v)#define MS(x,y) memset(x,y,sizeof(x))#define MC(x) MS(x,0)#define MINF(x) MS(x,63)#define MCP(x,y) memcpy(x,y,sizeof(y))#define sqr(x) ((x)*(x))#define UN(v) sort(All(v)),v.erase(unique(All(v)),v.end())#define filein(x) freopen(x,"r",stdin)#define fileout(x) freopen(x,"w",stdout)#define fileio(x)\ freopen(x".in","r",stdin);\ freopen(x".out","w",stdout)#define filein2(filename,name) ifstream name(filename,ios::in)#define fileout2(filename,name) ofstream name(filename,ios::out)#define file(filename,name) fstream name(filename,ios::in|ios::out)#define Pause system("pause")#define Cls system("cls")#define fs first#define sc second#define PC(x) putchar(x)#define GC(x) x=getchar()#define Endl PC('\n')#define SF scanf#define PF printfinline int Read()&#123; int X=0,w=0;char ch=0;while(!isdigit(ch))&#123;w|=ch=='-';ch=getchar();&#125;while(isdigit(ch))X=(X&lt;&lt;3)+(X&lt;&lt;1)+(ch^48),ch=getchar(); return w?-X:X;&#125;inline void Write(int x)&#123;if(x&lt;0)putchar('-'),x=-x;if(x&gt;9)Write(x/10);putchar(x%10+'0');&#125;inline LL powmod(LL a,LL b)&#123;LL RES=1;a%=MOD;assert(b&gt;=0);for(;b;b&gt;&gt;=1)&#123;if(b&amp;1)RES=RES*a%MOD;a=a*a%MOD;&#125;return RES%MOD;&#125;inline LL gcdll(LL a,LL b)&#123;return b?gcdll(b,a%b):a;&#125;const int dx[]=&#123;0,1,0,-1,1,-1,-1,1&#125;;const int dy[]=&#123;1,0,-1,0,-1,-1,1,1&#125;;/************************************************************Begin************************************************************/const int maxn=INF;const int days[]=&#123;0,31,0,31,30,31,30,31,31,30,31,30,31&#125;;const string weeks[]=&#123;"","mon","tue","wed","thu","fri","sat","sun"&#125;;// 1.1.1 =&gt; moninline int getday(int year,int month)&#123; if(month==2) &#123; if(year%400==0) return 29; if(year%100==0) return 28; return year%4==0?29:28; &#125; else return days[month];&#125;inline bool cmp(int y1,int m1,int y2,int m2)&#123; if(y1==y2) return m1&lt;m2; else return y1&lt;y2;&#125;inline int getweek(int year,int month)&#123; int y=1,m=1,w=0; while(y!=year||m!=month) &#123; if(cmp(y,m,year,month)) &#123; w=(w+getday(y,m)%7)%7; m++; if(m==13) &#123; y++; m=1; &#125; &#125; &#125; return w+1;&#125;inline void print(int year,int month,int day)&#123; vector&lt;int&gt; w[8]; int lst=getweek(year,month); w[lst].push_back(1); rep1(i,lst-1) w[i].push_back(0); int pos[15]; pos[0]=6; rep1(i,5) pos[i]=pos[i-1]+5; repa1(i,2,getday(year,month)) &#123; lst++; if(lst==8) lst=1; w[lst].push_back(i); &#125; string str[8]; rep1(i,7) &#123; str[i]=weeks[i]; rep(j,100) str[i]+=" "; rep(j,w[i].size()) &#123; int x=w[i][j]; if(x) str[i][pos[j]]=(x%10+'0'); if(x/10) str[i][pos[j]-1]=(x/10+'0'); if(x==day) &#123; str[i][pos[j]-2]='['; str[i][pos[j]+1]=']'; &#125; &#125; &#125; rep1(i,7) cout&lt;&lt;str[i]&lt;&lt;endl;&#125;int main()&#123; int year,month,day; cin&gt;&gt;day&gt;&gt;month&gt;&gt;year; print(year,month,day); return 0;&#125;/*************************************************************End**************************************************************/]]></content>
      <categories>
        <category>算法</category>
        <category>Ural</category>
      </categories>
      <tags>
        <tag>模拟</tag>
        <tag>暴力</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Codeforces 718A Efim and Strange Grade 程序分析]]></title>
    <url>%2F2019%2F08%2F18%2FCodeforces-718A-Efim-and-Strange-Grade-%E7%A8%8B%E5%BA%8F%E5%88%86%E6%9E%90%2F</url>
    <content type="text"><![CDATA[Codeforces 718A Efim and Strange Grade 程序分析 jerry的程序123456789101112131415161718192021222324252627282930313233343536373839404142434445using namespace std;typedef long long ll; string buf;int i; void up(int at)&#123; at--; if (at &lt; 0) &#123; buf = '1' + buf; i++; return; &#125; if (buf[at] == '.') at--; buf[at]++; if (buf[at] == '9'+1) &#123; buf[at] = '0'; up(at); &#125;&#125; int main()&#123; cin.sync_with_stdio(false); cin.tie(0); int n, k; cin &gt;&gt; n &gt;&gt; k &gt;&gt; buf; while (buf[i] != '.') i++; i++; while (i &lt; buf.length() &amp;&amp; buf[i] &lt;= '4') i++; if (i == buf.length()) &#123; cout &lt;&lt; buf &lt;&lt; endl; return 0; &#125; for (;buf[i] != '.' &amp;&amp; k;i--) if (buf[i] &gt;= '5') &#123; buf.resize(i); up(i); k--; &#125; if (buf.back() == '.') buf.pop_back(); cout &lt;&lt; buf &lt;&lt; endl; return 0;&#125; 首先，先找到小数点第一个后大于等于$5$的数位，如果没有的话直接输出原数。 从那个数位起，从后往前循环到小数点处，如果还当前数位大于等于$5$且有进位的机会，则先把这个数的结尾改成这个位置，因为之后的所有数都会被清零，然后调用up函数进位，如果有$9$的数继续递归，否则退出，如果整数部分首位还要进位，需要在最前面加上$1$。 最后注意最后一个字符如果是小数点要删去。 总结：用一个函数来执行进位，如果还有进位机会只需继续调用函数就行了，这样处理起来十分方便。 izrak的程序1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include &lt;bits/stdc++.h&gt; #define FO(i,a,b) for (int i = (a); i &lt; (b); i++)#define sz(v) int(v.size()) using namespace std; char s[200005]; int main() &#123; int l, t; scanf("%d %d", &amp;l, &amp;t); scanf("%s", s+1); s[0] = '0'; for (int i = 0; i &lt;= l; i++) &#123; if (s[i] == '.') &#123; for (int j = i+1; j &lt;= l; j++) if (s[j] &gt;= '5') &#123; s[j] = 0; bool roundup = true; t--; for (int k = j-1; k &gt; i; k--) &#123; // s[k]++ if (roundup) &#123; s[k]++; if (s[k] &gt;= '5' &amp;&amp; t) &#123; s[k] = 0; t--; roundup = true; &#125; else roundup = false; &#125; &#125; if (roundup) &#123; s[i] = 0; for (int k = i-1; k &gt;= 0; k--) &#123; s[k]++; if (s[k] &lt;= '9') break; else s[k] = '0'; &#125; &#125; break; &#125; &#125; &#125; if (s[0] != '0') &#123; printf("%s\n", s); &#125; else &#123; printf("%s\n", s+1); &#125;&#125; 这个程序读入时在数字前加上一个前导零，以便处理整数部分首位进位情况。 第一层循环找到小数点的位置，第二层循环找到小数点后第一位大于等于$5$的数字，第三层循环(最多进位到小数点)，roundup记录是否继续进位，如果进位后还有大于等于$5$的数字且还有进位机会，则继续进位。如果第三层循环结束后，仍需继续进位，则在整数部分进位。进位时每进位一次，就把这一位设置为\0，这样输出时只会输出到第一个\0的位置便结束。 注意最后需判断如果开始时加上的前导零仍是零，就不能输出。 总结：用bool变量roundup维护需不需要继续进位，进了位的位置就标为\0，如果在小数点前面进位直接循环处理即可，这样处理起来不容易错。]]></content>
      <categories>
        <category>算法</category>
        <category>Codeforces</category>
      </categories>
      <tags>
        <tag>数学</tag>
        <tag>DP</tag>
        <tag>贪心</tag>
        <tag>模拟</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2019 Multi-University Training Contest 2 1010 Just Skip The Problem 自闭记]]></title>
    <url>%2F2019%2F08%2F18%2F2019-Multi-University-Training-Contest-2-1010-Just-Skip-The-Problem-%E8%87%AA%E9%97%AD%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[2019 Multi-University Training Contest 2: 1010 Just Skip The Problem 自闭记题意多测。每次给你一个数$n$，你可以同时问无数次，每次问的是一个数$y_i$，你会得到的回答是$x\&amp;y_i$是否为$y_i$，问你问的最少的次数的种数$\%1e6+3$，可以调换顺序。 10min 得出数学方法求$n!\%1e6+3$。 50min 自闭 5min 写出裸暴力，优化10min，交一发TLE 30min 网上找各种快速阶乘题解、优化，发现板子全是错的：$3!$打出$60$、不会清空$\dots\dots$，写到自闭 5min 发现一旦$n\ge1e6+3$时取了模后就为$0$了$\dots\dots$，自闭 2min AC直接码，2min AC$\dots\dots$ 总结：以后多多总结性质。]]></content>
      <categories>
        <category>算法</category>
        <category>hdu</category>
        <category>多校</category>
      </categories>
      <tags>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Ural 1029 Ministry 题解]]></title>
    <url>%2F2019%2F08%2F12%2FUral-1029-Ministry-%E9%A2%98%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[Ural 1029 Ministry 题解题意给定一个$n\times m(1\le n \le10,1\le m \le500)$的矩阵，矩阵中的每个值都是一个小于等于$10^9$的正整数。 现在从第$1$行的任意位置开始，在第$n$行的任意位置结束。每次有$3$种移动选择(不能移动到矩阵外)。 设当前位置为$(i,j)$ 移动到$(i+1,j)$ 移动到$(i,j-1)$ 移动到$(i,j+1)$ 每条路径的价值是路径走过所有的位置上的值的和(小于等于$10^9$)。 问在所有路径中，路径价值最小的，输出这条路径所有位置的列号。 题解考虑记忆化搜索(DP也可以)。 对于每个点，记忆化搜索可以移动到它的$3$种位置，取最小值即可，顺便记录一下路径。 也可以无脑最短路。 Tips: WA$1$的同学不要着急，Test$1$并不是样例，仔细找找有没有错误。 设$(i,j)$的答案为$dp(i,j)$，矩阵中的值为$a(i,j)$，状态转移方程如果是$dp(i,j)=\min\{dp(i-1,j),dp(i,j-1),dp(i,j+1) \}+a(i,j)$可能会WA$1$，改为$dp(i,j)=\min\{dp(i-1,j)+a(i,j),dp(i,j-1)+a(i,j),dp(i,j+1)+a(i,j) \}$即可AC。目前并不知道原因(我太弱了)，如果有知道的可以在评论区留言，谢谢！ 程序AC程序123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228// #pragma GCC optimize(2)// #pragma G++ optimize(2)// #pragma comment(linker,"/STACK:102400000,102400000")// #include &lt;bits/stdc++.h&gt;#include &lt;map&gt;#include &lt;set&gt;#include &lt;list&gt;#include &lt;array&gt;#include &lt;cfenv&gt;#include &lt;cmath&gt;#include &lt;ctime&gt;#include &lt;deque&gt;#include &lt;mutex&gt;#include &lt;queue&gt;#include &lt;ratio&gt;#include &lt;regex&gt;#include &lt;stack&gt;#include &lt;tuple&gt;#include &lt;atomic&gt;#include &lt;bitset&gt;#include &lt;cctype&gt;#include &lt;cerrno&gt;#include &lt;cfloat&gt;#include &lt;chrono&gt;#include &lt;cstdio&gt;#include &lt;cwchar&gt;#include &lt;future&gt;#include &lt;limits&gt;#include &lt;locale&gt;#include &lt;memory&gt;#include &lt;random&gt;#include &lt;string&gt;#include &lt;thread&gt;#include &lt;vector&gt;#include &lt;cassert&gt;#include &lt;climits&gt;#include &lt;clocale&gt;#include &lt;complex&gt;#include &lt;csetjmp&gt;#include &lt;csignal&gt;#include &lt;cstdarg&gt;#include &lt;cstddef&gt;#include &lt;cstdint&gt;#include &lt;cstdlib&gt;#include &lt;cstring&gt;#include &lt;ctgmath&gt;#include &lt;cwctype&gt;#include &lt;fstream&gt;#include &lt;iomanip&gt;#include &lt;numeric&gt;#include &lt;sstream&gt;#include &lt;ccomplex&gt;#include &lt;cstdbool&gt;#include &lt;iostream&gt;#include &lt;typeinfo&gt;#include &lt;valarray&gt;#include &lt;algorithm&gt;#include &lt;cinttypes&gt;#include &lt;cstdalign&gt;#include &lt;stdexcept&gt;#include &lt;typeindex&gt;#include &lt;functional&gt;#include &lt;forward_list&gt;#include &lt;system_error&gt;#include &lt;unordered_map&gt;#include &lt;unordered_set&gt;#include &lt;scoped_allocator&gt;#include &lt;condition_variable&gt;// #include &lt;conio.h&gt;// #include &lt;windows.h&gt;using namespace std;typedef long long LL;typedef unsigned int ui;typedef unsigned long long ull;typedef float fl;typedef double ld;typedef long double LD;typedef pair&lt;int,int&gt; pii;#if (WIN32) || (WIN64) || (__WIN32) || (__WIN64) || (_WIN32) || (_WIN64) || (WINDOWS)#define lld "%I64d"#define llu "%I64u"#else#define lld "%lld"#define llu "%llu"#endif#define ui(n) ((unsigned int)(n))#define LL(n) ((long long)(n))#define ull(n) ((unsigned long long)(n))#define fl(n) ((float)(n))#define ld(n) ((double)(n))#define LD(n) ((long double)(n))#define char(n) ((char)(n))#define Bool(n) ((bool)(n))#define fixpoint(n) fixed&lt;&lt;setprecision(n)const int INF=1061109567;const int NINF=-1044266559;const LL LINF=4557430888798830399;const ld eps=1e-15;#define MOD (1000000007)#define PI (3.1415926535897932384626433832795028841971)/*#define MB_LEN_MAX 5#define SHRT_MIN (-32768)#define SHRT_MAX 32767#define USHRT_MAX 0xffffU#define INT_MIN (-2147483647 - 1)#define INT_MAX 2147483647#define UINT_MAX 0xffffffffU#define LONG_MIN (-2147483647L - 1)#define LONG_MAX 2147483647L#define ULONG_MAX 0xffffffffUL#define LLONG_MAX 9223372036854775807ll#define LLONG_MIN (-9223372036854775807ll - 1)#define ULLONG_MAX 0xffffffffffffffffull*/#define MP make_pair#define MT make_tuple#define All(a) (a).begin(),(a).end()#define pall(a) (a).rbegin(),(a).rend()#define log2(x) log(x)/log(2)#define Log(x,y) log(x)/log(y)#define SZ(a) ((int)(a).size())#define rep(i,n) for(int i=0;i&lt;((int)(n));i++)#define rep1(i,n) for(int i=1;i&lt;=((int)(n));i++)#define repa(i,a,n) for(int i=((int)(a));i&lt;((int)(n));i++)#define repa1(i,a,n) for(int i=((int)(a));i&lt;=((int)(n));i++)#define repd(i,n) for(int i=((int)(n))-1;i&gt;=0;i--)#define repd1(i,n) for(int i=((int)(n));i&gt;=1;i--)#define repda(i,n,a) for(int i=((int)(n));i&gt;((int)(a));i--)#define repda1(i,n,a) for(int i=((int)(n));i&gt;=((int)(a));i--)#define FOR(i,a,n,step) for(int i=((int)(a));i&lt;((int)(n));i+=((int)(step)))#define repv(itr,v) for(__typeof((v).begin()) itr=(v).begin();itr!=(v).end();itr++)#define repV(i,v) for(auto i:v)#define repE(i,v) for(auto &amp;i:v)#define MS(x,y) memset(x,y,sizeof(x))#define MC(x) MS(x,0)#define MINF(x) MS(x,63)#define MCP(x,y) memcpy(x,y,sizeof(y))#define sqr(x) ((x)*(x))#define UN(v) sort(All(v)),v.erase(unique(All(v)),v.end())#define filein(x) freopen(x,"r",stdin)#define fileout(x) freopen(x,"w",stdout)#define fileio(x)\ freopen(x".in","r",stdin);\ freopen(x".out","w",stdout)#define filein2(filename,name) ifstream name(filename,ios::in)#define fileout2(filename,name) ofstream name(filename,ios::out)#define file(filename,name) fstream name(filename,ios::in|ios::out)#define Pause system("pause")#define Cls system("cls")#define fs first#define sc second#define PC(x) putchar(x)#define GC(x) x=getchar()#define Endl PC('\n')#define SF scanf#define PF printfinline int Read()&#123; int X=0,w=0;char ch=0;while(!isdigit(ch))&#123;w|=ch=='-';ch=getchar();&#125;while(isdigit(ch))X=(X&lt;&lt;3)+(X&lt;&lt;1)+(ch^48),ch=getchar(); return w?-X:X;&#125;inline void Write(int x)&#123;if(x&lt;0)putchar('-'),x=-x;if(x&gt;9)Write(x/10);putchar(x%10+'0');&#125;inline LL powmod(LL a,LL b)&#123;LL RES=1;a%=MOD;assert(b&gt;=0);for(;b;b&gt;&gt;=1)&#123;if(b&amp;1)RES=RES*a%MOD;a=a*a%MOD;&#125;return RES%MOD;&#125;inline LL gcdll(LL a,LL b)&#123;return b?gcdll(b,a%b):a;&#125;const int dx[]=&#123;0,1,0,-1,1,-1,-1,1&#125;;const int dy[]=&#123;1,0,-1,0,-1,-1,1,1&#125;;/************************************************************Begin************************************************************/const int maxn=110,maxm=510;int n,m,a[maxn][maxm],dp[maxn][maxm];pair&lt;int,int&gt; pre[maxn][maxm];inline int sol(int x,int y)&#123; if(y&lt;1||y&gt;m) return dp[x][y]=INF; if(dp[x][y]!=-1) return dp[x][y]; else dp[x][y]=0; int res=sol(x-1,y)+a[x][y]; dp[x][y]=res; pre[x][y]=&#123;x-1,y&#125;; res=sol(x,y-1)+a[x][y]; if(res&lt;dp[x][y]) &#123; dp[x][y]=res; pre[x][y]=&#123;x,y-1&#125;; &#125; res=sol(x,y+1)+a[x][y]; if(res&lt;dp[x][y]) &#123; dp[x][y]=res; pre[x][y]=&#123;x,y+1&#125;; &#125; return dp[x][y];&#125;inline void print(int x,int y)&#123; if(x&gt;1) print(pre[x][y].fs,pre[x][y].sc); cout&lt;&lt;y&lt;&lt;' ';&#125;int main()&#123; cin&gt;&gt;n&gt;&gt;m; rep1(i,n) rep1(j,m) cin&gt;&gt;a[i][j]; MS(dp,-1); rep1(j,m) dp[1][j]=a[1][j]; int ans=1; rep1(j,m) if(sol(n,j)&lt;sol(n,ans)) ans=j; print(n,ans); return 0;&#125;/*************************************************************End**************************************************************/ WA$1$程序123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229// #pragma GCC optimize(2)// #pragma G++ optimize(2)// #pragma comment(linker,"/STACK:102400000,102400000")// #include &lt;bits/stdc++.h&gt;#include &lt;map&gt;#include &lt;set&gt;#include &lt;list&gt;#include &lt;array&gt;#include &lt;cfenv&gt;#include &lt;cmath&gt;#include &lt;ctime&gt;#include &lt;deque&gt;#include &lt;mutex&gt;#include &lt;queue&gt;#include &lt;ratio&gt;#include &lt;regex&gt;#include &lt;stack&gt;#include &lt;tuple&gt;#include &lt;atomic&gt;#include &lt;bitset&gt;#include &lt;cctype&gt;#include &lt;cerrno&gt;#include &lt;cfloat&gt;#include &lt;chrono&gt;#include &lt;cstdio&gt;#include &lt;cwchar&gt;#include &lt;future&gt;#include &lt;limits&gt;#include &lt;locale&gt;#include &lt;memory&gt;#include &lt;random&gt;#include &lt;string&gt;#include &lt;thread&gt;#include &lt;vector&gt;#include &lt;cassert&gt;#include &lt;climits&gt;#include &lt;clocale&gt;#include &lt;complex&gt;#include &lt;csetjmp&gt;#include &lt;csignal&gt;#include &lt;cstdarg&gt;#include &lt;cstddef&gt;#include &lt;cstdint&gt;#include &lt;cstdlib&gt;#include &lt;cstring&gt;#include &lt;ctgmath&gt;#include &lt;cwctype&gt;#include &lt;fstream&gt;#include &lt;iomanip&gt;#include &lt;numeric&gt;#include &lt;sstream&gt;#include &lt;ccomplex&gt;#include &lt;cstdbool&gt;#include &lt;iostream&gt;#include &lt;typeinfo&gt;#include &lt;valarray&gt;#include &lt;algorithm&gt;#include &lt;cinttypes&gt;#include &lt;cstdalign&gt;#include &lt;stdexcept&gt;#include &lt;typeindex&gt;#include &lt;functional&gt;#include &lt;forward_list&gt;#include &lt;system_error&gt;#include &lt;unordered_map&gt;#include &lt;unordered_set&gt;#include &lt;scoped_allocator&gt;#include &lt;condition_variable&gt;// #include &lt;conio.h&gt;// #include &lt;windows.h&gt;using namespace std;typedef long long LL;typedef unsigned int ui;typedef unsigned long long ull;typedef float fl;typedef double ld;typedef long double LD;typedef pair&lt;int,int&gt; pii;#if (WIN32) || (WIN64) || (__WIN32) || (__WIN64) || (_WIN32) || (_WIN64) || (WINDOWS)#define lld "%I64d"#define llu "%I64u"#else#define lld "%lld"#define llu "%llu"#endif#define ui(n) ((unsigned int)(n))#define LL(n) ((long long)(n))#define ull(n) ((unsigned long long)(n))#define fl(n) ((float)(n))#define ld(n) ((double)(n))#define LD(n) ((long double)(n))#define char(n) ((char)(n))#define Bool(n) ((bool)(n))#define fixpoint(n) fixed&lt;&lt;setprecision(n)const int INF=1061109567;const int NINF=-1044266559;const LL LINF=4557430888798830399;const ld eps=1e-15;#define MOD (1000000007)#define PI (3.1415926535897932384626433832795028841971)/*#define MB_LEN_MAX 5#define SHRT_MIN (-32768)#define SHRT_MAX 32767#define USHRT_MAX 0xffffU#define INT_MIN (-2147483647 - 1)#define INT_MAX 2147483647#define UINT_MAX 0xffffffffU#define LONG_MIN (-2147483647L - 1)#define LONG_MAX 2147483647L#define ULONG_MAX 0xffffffffUL#define LLONG_MAX 9223372036854775807ll#define LLONG_MIN (-9223372036854775807ll - 1)#define ULLONG_MAX 0xffffffffffffffffull*/#define MP make_pair#define MT make_tuple#define All(a) (a).begin(),(a).end()#define pall(a) (a).rbegin(),(a).rend()#define log2(x) log(x)/log(2)#define Log(x,y) log(x)/log(y)#define SZ(a) ((int)(a).size())#define rep(i,n) for(int i=0;i&lt;((int)(n));i++)#define rep1(i,n) for(int i=1;i&lt;=((int)(n));i++)#define repa(i,a,n) for(int i=((int)(a));i&lt;((int)(n));i++)#define repa1(i,a,n) for(int i=((int)(a));i&lt;=((int)(n));i++)#define repd(i,n) for(int i=((int)(n))-1;i&gt;=0;i--)#define repd1(i,n) for(int i=((int)(n));i&gt;=1;i--)#define repda(i,n,a) for(int i=((int)(n));i&gt;((int)(a));i--)#define repda1(i,n,a) for(int i=((int)(n));i&gt;=((int)(a));i--)#define FOR(i,a,n,step) for(int i=((int)(a));i&lt;((int)(n));i+=((int)(step)))#define repv(itr,v) for(__typeof((v).begin()) itr=(v).begin();itr!=(v).end();itr++)#define repV(i,v) for(auto i:v)#define repE(i,v) for(auto &amp;i:v)#define MS(x,y) memset(x,y,sizeof(x))#define MC(x) MS(x,0)#define MINF(x) MS(x,63)#define MCP(x,y) memcpy(x,y,sizeof(y))#define sqr(x) ((x)*(x))#define UN(v) sort(All(v)),v.erase(unique(All(v)),v.end())#define filein(x) freopen(x,"r",stdin)#define fileout(x) freopen(x,"w",stdout)#define fileio(x)\ freopen(x".in","r",stdin);\ freopen(x".out","w",stdout)#define filein2(filename,name) ifstream name(filename,ios::in)#define fileout2(filename,name) ofstream name(filename,ios::out)#define file(filename,name) fstream name(filename,ios::in|ios::out)#define Pause system("pause")#define Cls system("cls")#define fs first#define sc second#define PC(x) putchar(x)#define GC(x) x=getchar()#define Endl PC('\n')#define SF scanf#define PF printfinline int Read()&#123; int X=0,w=0;char ch=0;while(!isdigit(ch))&#123;w|=ch=='-';ch=getchar();&#125;while(isdigit(ch))X=(X&lt;&lt;3)+(X&lt;&lt;1)+(ch^48),ch=getchar(); return w?-X:X;&#125;inline void Write(int x)&#123;if(x&lt;0)putchar('-'),x=-x;if(x&gt;9)Write(x/10);putchar(x%10+'0');&#125;inline LL powmod(LL a,LL b)&#123;LL RES=1;a%=MOD;assert(b&gt;=0);for(;b;b&gt;&gt;=1)&#123;if(b&amp;1)RES=RES*a%MOD;a=a*a%MOD;&#125;return RES%MOD;&#125;inline LL gcdll(LL a,LL b)&#123;return b?gcdll(b,a%b):a;&#125;const int dx[]=&#123;0,1,0,-1,1,-1,-1,1&#125;;const int dy[]=&#123;1,0,-1,0,-1,-1,1,1&#125;;/************************************************************Begin************************************************************/const int maxn=110,maxm=510;int n,m,a[maxn][maxm],dp[maxn][maxm];pair&lt;int,int&gt; pre[maxn][maxm];inline int sol(int x,int y)&#123; if(y&lt;1||y&gt;m) return dp[x][y]=INF; if(dp[x][y]!=-1) return dp[x][y]; else dp[x][y]=0; int res=sol(x-1,y); dp[x][y]=res; pre[x][y]=&#123;x-1,y&#125;; res=sol(x,y-1); if(res&lt;dp[x][y]) &#123; dp[x][y]=res; pre[x][y]=&#123;x,y-1&#125;; &#125; res=sol(x,y+1); if(res&lt;dp[x][y]) &#123; dp[x][y]=res; pre[x][y]=&#123;x,y+1&#125;; &#125; dp[x][y]+=a[x][y]; return dp[x][y];&#125;inline void print(int x,int y)&#123; if(x&gt;1) print(pre[x][y].fs,pre[x][y].sc); cout&lt;&lt;y&lt;&lt;' ';&#125;int main()&#123; cin&gt;&gt;n&gt;&gt;m; rep1(i,n) rep1(j,m) cin&gt;&gt;a[i][j]; MS(dp,-1); rep1(j,m) dp[1][j]=a[1][j]; int ans=1; rep1(j,m) if(sol(n,j)&lt;sol(n,ans)) ans=j; print(n,ans); return 0;&#125;/*************************************************************End**************************************************************/]]></content>
      <categories>
        <category>算法</category>
        <category>Ural</category>
      </categories>
      <tags>
        <tag>DP</tag>
        <tag>记忆化搜索</tag>
        <tag>最短路</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Ural 1250 Sea Burial 题解]]></title>
    <url>%2F2019%2F08%2F12%2FUral-1250-Sea-Burial-%E9%A2%98%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[Ural 1250 Sea Burial 题解题意给定一个$n\times m$的地图，.为水，#为陆，地图的外部是水(地图被水包围)。水为八连通，陆为四联通。联通的水称为海，联通的陆称为岛。海内可能有岛，岛内可能有海。给定$x,y$求在包含$(x,y)$(保证$(x,y)$为水)的海里面有多少岛。 输入第一行包含$m,n,y,x(1\le n,m\le 500,1\le x \le n,1\le y \le m)$ 以下若干行为一个$n\times m$的地图 题解考虑BFS或DFS(以下简称BFS) 从$(x,y)$BFS，找出包含$(x,y)$的海。 从地图外部(水)BFS，找出在包含$(x,y)$的海的外面部分。 执行完前两步，就可以知道包含$(x,y)$的海里面的部分，数出包含$(x,y)$的海里面的部分有多少岛即可。 Tip: 运用二进制可以使程序简便。记陆为$1$，岛为$2$。设我们需要的值为$x$，当前的值为$y$，只需判断$(x\&amp;y)$是否大于$0$即可。第1步时$x=2$，第2步时$x=3$(想一想，为什么，答案最后揭晓)，第3步时$x=1$。 程序 BFS 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239// #pragma GCC optimize(2)// #pragma G++ optimize(2)// #pragma comment(linker,"/STACK:102400000,102400000")// #include &lt;bits/stdc++.h&gt;#include &lt;map&gt;#include &lt;set&gt;#include &lt;list&gt;#include &lt;array&gt;#include &lt;cfenv&gt;#include &lt;cmath&gt;#include &lt;ctime&gt;#include &lt;deque&gt;#include &lt;mutex&gt;#include &lt;queue&gt;#include &lt;ratio&gt;#include &lt;regex&gt;#include &lt;stack&gt;#include &lt;tuple&gt;#include &lt;atomic&gt;#include &lt;bitset&gt;#include &lt;cctype&gt;#include &lt;cerrno&gt;#include &lt;cfloat&gt;#include &lt;chrono&gt;#include &lt;cstdio&gt;#include &lt;cwchar&gt;#include &lt;future&gt;#include &lt;limits&gt;#include &lt;locale&gt;#include &lt;memory&gt;#include &lt;random&gt;#include &lt;string&gt;#include &lt;thread&gt;#include &lt;vector&gt;#include &lt;cassert&gt;#include &lt;climits&gt;#include &lt;clocale&gt;#include &lt;complex&gt;#include &lt;csetjmp&gt;#include &lt;csignal&gt;#include &lt;cstdarg&gt;#include &lt;cstddef&gt;#include &lt;cstdint&gt;#include &lt;cstdlib&gt;#include &lt;cstring&gt;#include &lt;ctgmath&gt;#include &lt;cwctype&gt;#include &lt;fstream&gt;#include &lt;iomanip&gt;#include &lt;numeric&gt;#include &lt;sstream&gt;#include &lt;ccomplex&gt;#include &lt;cstdbool&gt;#include &lt;iostream&gt;#include &lt;typeinfo&gt;#include &lt;valarray&gt;#include &lt;algorithm&gt;#include &lt;cinttypes&gt;#include &lt;cstdalign&gt;#include &lt;stdexcept&gt;#include &lt;typeindex&gt;#include &lt;functional&gt;#include &lt;forward_list&gt;#include &lt;system_error&gt;#include &lt;unordered_map&gt;#include &lt;unordered_set&gt;#include &lt;scoped_allocator&gt;#include &lt;condition_variable&gt;// #include &lt;conio.h&gt;// #include &lt;windows.h&gt;using namespace std;typedef long long LL;typedef unsigned int ui;typedef unsigned long long ull;typedef float fl;typedef double ld;typedef long double LD;typedef pair&lt;int,int&gt; pii;#if (WIN32) || (WIN64) || (__WIN32) || (__WIN64) || (_WIN32) || (_WIN64) || (WINDOWS)#define lld "%I64d"#define llu "%I64u"#else#define lld "%lld"#define llu "%llu"#endif#define ui(n) ((unsigned int)(n))#define LL(n) ((long long)(n))#define ull(n) ((unsigned long long)(n))#define fl(n) ((float)(n))#define ld(n) ((double)(n))#define LD(n) ((long double)(n))#define char(n) ((char)(n))#define Bool(n) ((bool)(n))#define fixpoint(n) fixed&lt;&lt;setprecision(n)const int INF=1061109567;const int NINF=-1044266559;const LL LINF=4557430888798830399;const ld eps=1e-15;#define MOD (1000000007)#define PI (3.1415926535897932384626433832795028841971)/*#define MB_LEN_MAX 5#define SHRT_MIN (-32768)#define SHRT_MAX 32767#define USHRT_MAX 0xffffU#define INT_MIN (-2147483647 - 1)#define INT_MAX 2147483647#define UINT_MAX 0xffffffffU#define LONG_MIN (-2147483647L - 1)#define LONG_MAX 2147483647L#define ULONG_MAX 0xffffffffUL#define LLONG_MAX 9223372036854775807ll#define LLONG_MIN (-9223372036854775807ll - 1)#define ULLONG_MAX 0xffffffffffffffffull*/#define MP make_pair#define MT make_tuple#define All(a) (a).begin(),(a).end()#define pall(a) (a).rbegin(),(a).rend()#define log2(x) log(x)/log(2)#define Log(x,y) log(x)/log(y)#define SZ(a) ((int)(a).size())#define rep(i,n) for(int i=0;i&lt;((int)(n));i++)#define rep1(i,n) for(int i=1;i&lt;=((int)(n));i++)#define repa(i,a,n) for(int i=((int)(a));i&lt;((int)(n));i++)#define repa1(i,a,n) for(int i=((int)(a));i&lt;=((int)(n));i++)#define repd(i,n) for(int i=((int)(n))-1;i&gt;=0;i--)#define repd1(i,n) for(int i=((int)(n));i&gt;=1;i--)#define repda(i,n,a) for(int i=((int)(n));i&gt;((int)(a));i--)#define repda1(i,n,a) for(int i=((int)(n));i&gt;=((int)(a));i--)#define FOR(i,a,n,step) for(int i=((int)(a));i&lt;((int)(n));i+=((int)(step)))#define repv(itr,v) for(__typeof((v).begin()) itr=(v).begin();itr!=(v).end();itr++)#define repV(i,v) for(auto i:v)#define repE(i,v) for(auto &amp;i:v)#define MS(x,y) memset(x,y,sizeof(x))#define MC(x) MS(x,0)#define MINF(x) MS(x,63)#define MCP(x,y) memcpy(x,y,sizeof(y))#define sqr(x) ((x)*(x))#define UN(v) sort(All(v)),v.erase(unique(All(v)),v.end())#define filein(x) freopen(x,"r",stdin)#define fileout(x) freopen(x,"w",stdout)#define fileio(x)\ freopen(x".in","r",stdin);\ freopen(x".out","w",stdout)#define filein2(filename,name) ifstream name(filename,ios::in)#define fileout2(filename,name) ofstream name(filename,ios::out)#define file(filename,name) fstream name(filename,ios::in|ios::out)#define Pause system("pause")#define Cls system("cls")#define fs first#define sc second#define PC(x) putchar(x)#define GC(x) x=getchar()#define Endl PC('\n')#define SF scanf#define PF printfinline int Read()&#123; int X=0,w=0;char ch=0;while(!isdigit(ch))&#123;w|=ch=='-';ch=getchar();&#125;while(isdigit(ch))X=(X&lt;&lt;3)+(X&lt;&lt;1)+(ch^48),ch=getchar(); return w?-X:X;&#125;inline void Write(int x)&#123;if(x&lt;0)putchar('-'),x=-x;if(x&gt;9)Write(x/10);putchar(x%10+'0');&#125;inline LL powmod(LL a,LL b)&#123;LL RES=1;a%=MOD;assert(b&gt;=0);for(;b;b&gt;&gt;=1)&#123;if(b&amp;1)RES=RES*a%MOD;a=a*a%MOD;&#125;return RES%MOD;&#125;inline LL gcdll(LL a,LL b)&#123;return b?gcdll(b,a%b):a;&#125;const int dx[]=&#123;0,1,0,-1,1,-1,-1,1&#125;;const int dy[]=&#123;1,0,-1,0,-1,-1,1,1&#125;;/************************************************************Begin************************************************************/const int maxn=510;int n,m,X,Y,s[maxn][maxn],ans; // '#'=&gt;1(01) '.'=&gt;2(10)bool vis[maxn][maxn];inline void bfs(int sx,int sy,int status)&#123; vis[sx][sy]=1; queue&lt;pair&lt;int,int&gt; &gt; q;q.push(&#123;sx,sy&#125;); while(!q.empty()) &#123; int x=q.front().fs,y=q.front().sc;q.pop(); rep(i,8) &#123; if(s[x][y]==1&amp;&amp;i&gt;3) break; int cx=x+dx[i],cy=y+dy[i]; if(cx&gt;0&amp;&amp;cx&lt;=n&amp;&amp;cy&gt;0&amp;&amp;cy&lt;=m&amp;&amp;!vis[cx][cy]&amp;&amp;(s[cx][cy]&amp;status)) &#123; vis[cx][cy]=1; q.push(&#123;cx,cy&#125;); &#125; &#125; &#125;&#125;int main()&#123; cin&gt;&gt;m&gt;&gt;n&gt;&gt;Y&gt;&gt;X; rep1(i,n) rep1(j,m) &#123; char c;cin&gt;&gt;c; s[i][j]=(c=='#'?1:2); &#125; // step 1 bfs(X,Y,2); // step 2 rep1(i,n) &#123; bfs(i,0,3); bfs(i,m+1,3); &#125; rep1(j,m) &#123; bfs(0,j,3); bfs(n+1,j,3); &#125; //step 3 rep1(i,n) rep1(j,m) if(!vis[i][j]&amp;&amp;s[i][j]==1) &#123; ans++; bfs(i,j,1); &#125; cout&lt;&lt;ans; return 0;&#125;/*************************************************************End**************************************************************/ DFS(与BFS十分类似) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229// #pragma GCC optimize(2)// #pragma G++ optimize(2)// #pragma comment(linker,"/STACK:102400000,102400000")// #include &lt;bits/stdc++.h&gt;#include &lt;map&gt;#include &lt;set&gt;#include &lt;list&gt;#include &lt;array&gt;#include &lt;cfenv&gt;#include &lt;cmath&gt;#include &lt;ctime&gt;#include &lt;deque&gt;#include &lt;mutex&gt;#include &lt;queue&gt;#include &lt;ratio&gt;#include &lt;regex&gt;#include &lt;stack&gt;#include &lt;tuple&gt;#include &lt;atomic&gt;#include &lt;bitset&gt;#include &lt;cctype&gt;#include &lt;cerrno&gt;#include &lt;cfloat&gt;#include &lt;chrono&gt;#include &lt;cstdio&gt;#include &lt;cwchar&gt;#include &lt;future&gt;#include &lt;limits&gt;#include &lt;locale&gt;#include &lt;memory&gt;#include &lt;random&gt;#include &lt;string&gt;#include &lt;thread&gt;#include &lt;vector&gt;#include &lt;cassert&gt;#include &lt;climits&gt;#include &lt;clocale&gt;#include &lt;complex&gt;#include &lt;csetjmp&gt;#include &lt;csignal&gt;#include &lt;cstdarg&gt;#include &lt;cstddef&gt;#include &lt;cstdint&gt;#include &lt;cstdlib&gt;#include &lt;cstring&gt;#include &lt;ctgmath&gt;#include &lt;cwctype&gt;#include &lt;fstream&gt;#include &lt;iomanip&gt;#include &lt;numeric&gt;#include &lt;sstream&gt;#include &lt;ccomplex&gt;#include &lt;cstdbool&gt;#include &lt;iostream&gt;#include &lt;typeinfo&gt;#include &lt;valarray&gt;#include &lt;algorithm&gt;#include &lt;cinttypes&gt;#include &lt;cstdalign&gt;#include &lt;stdexcept&gt;#include &lt;typeindex&gt;#include &lt;functional&gt;#include &lt;forward_list&gt;#include &lt;system_error&gt;#include &lt;unordered_map&gt;#include &lt;unordered_set&gt;#include &lt;scoped_allocator&gt;#include &lt;condition_variable&gt;// #include &lt;conio.h&gt;// #include &lt;windows.h&gt;using namespace std;typedef long long LL;typedef unsigned int ui;typedef unsigned long long ull;typedef float fl;typedef double ld;typedef long double LD;typedef pair&lt;int,int&gt; pii;#if (WIN32) || (WIN64) || (__WIN32) || (__WIN64) || (_WIN32) || (_WIN64) || (WINDOWS)#define lld "%I64d"#define llu "%I64u"#else#define lld "%lld"#define llu "%llu"#endif#define ui(n) ((unsigned int)(n))#define LL(n) ((long long)(n))#define ull(n) ((unsigned long long)(n))#define fl(n) ((float)(n))#define ld(n) ((double)(n))#define LD(n) ((long double)(n))#define char(n) ((char)(n))#define Bool(n) ((bool)(n))#define fixpoint(n) fixed&lt;&lt;setprecision(n)const int INF=1061109567;const int NINF=-1044266559;const LL LINF=4557430888798830399;const ld eps=1e-15;#define MOD (1000000007)#define PI (3.1415926535897932384626433832795028841971)/*#define MB_LEN_MAX 5#define SHRT_MIN (-32768)#define SHRT_MAX 32767#define USHRT_MAX 0xffffU#define INT_MIN (-2147483647 - 1)#define INT_MAX 2147483647#define UINT_MAX 0xffffffffU#define LONG_MIN (-2147483647L - 1)#define LONG_MAX 2147483647L#define ULONG_MAX 0xffffffffUL#define LLONG_MAX 9223372036854775807ll#define LLONG_MIN (-9223372036854775807ll - 1)#define ULLONG_MAX 0xffffffffffffffffull*/#define MP make_pair#define MT make_tuple#define All(a) (a).begin(),(a).end()#define pall(a) (a).rbegin(),(a).rend()#define log2(x) log(x)/log(2)#define Log(x,y) log(x)/log(y)#define SZ(a) ((int)(a).size())#define rep(i,n) for(int i=0;i&lt;((int)(n));i++)#define rep1(i,n) for(int i=1;i&lt;=((int)(n));i++)#define repa(i,a,n) for(int i=((int)(a));i&lt;((int)(n));i++)#define repa1(i,a,n) for(int i=((int)(a));i&lt;=((int)(n));i++)#define repd(i,n) for(int i=((int)(n))-1;i&gt;=0;i--)#define repd1(i,n) for(int i=((int)(n));i&gt;=1;i--)#define repda(i,n,a) for(int i=((int)(n));i&gt;((int)(a));i--)#define repda1(i,n,a) for(int i=((int)(n));i&gt;=((int)(a));i--)#define FOR(i,a,n,step) for(int i=((int)(a));i&lt;((int)(n));i+=((int)(step)))#define repv(itr,v) for(__typeof((v).begin()) itr=(v).begin();itr!=(v).end();itr++)#define repV(i,v) for(auto i:v)#define repE(i,v) for(auto &amp;i:v)#define MS(x,y) memset(x,y,sizeof(x))#define MC(x) MS(x,0)#define MINF(x) MS(x,63)#define MCP(x,y) memcpy(x,y,sizeof(y))#define sqr(x) ((x)*(x))#define UN(v) sort(All(v)),v.erase(unique(All(v)),v.end())#define filein(x) freopen(x,"r",stdin)#define fileout(x) freopen(x,"w",stdout)#define fileio(x)\ freopen(x".in","r",stdin);\ freopen(x".out","w",stdout)#define filein2(filename,name) ifstream name(filename,ios::in)#define fileout2(filename,name) ofstream name(filename,ios::out)#define file(filename,name) fstream name(filename,ios::in|ios::out)#define Pause system("pause")#define Cls system("cls")#define fs first#define sc second#define PC(x) putchar(x)#define GC(x) x=getchar()#define Endl PC('\n')#define SF scanf#define PF printfinline int Read()&#123; int X=0,w=0;char ch=0;while(!isdigit(ch))&#123;w|=ch=='-';ch=getchar();&#125;while(isdigit(ch))X=(X&lt;&lt;3)+(X&lt;&lt;1)+(ch^48),ch=getchar(); return w?-X:X;&#125;inline void Write(int x)&#123;if(x&lt;0)putchar('-'),x=-x;if(x&gt;9)Write(x/10);putchar(x%10+'0');&#125;inline LL powmod(LL a,LL b)&#123;LL RES=1;a%=MOD;assert(b&gt;=0);for(;b;b&gt;&gt;=1)&#123;if(b&amp;1)RES=RES*a%MOD;a=a*a%MOD;&#125;return RES%MOD;&#125;inline LL gcdll(LL a,LL b)&#123;return b?gcdll(b,a%b):a;&#125;const int dx[]=&#123;0,1,0,-1,1,-1,-1,1&#125;;const int dy[]=&#123;1,0,-1,0,-1,-1,1,1&#125;;/************************************************************Begin************************************************************/const int maxn=510;int n,m,X,Y,s[maxn][maxn],ans; // '#'=&gt;1(01) '.'=&gt;2(10)bool vis[maxn][maxn];inline void dfs(int x,int y,int status)&#123; vis[x][y]=1; rep(i,8) &#123; if(s[x][y]==1&amp;&amp;i&gt;3) break; int cx=x+dx[i],cy=y+dy[i]; if(cx&gt;0&amp;&amp;cx&lt;=n&amp;&amp;cy&gt;0&amp;&amp;cy&lt;=m&amp;&amp;!vis[cx][cy]&amp;&amp;(s[cx][cy]&amp;status)) dfs(cx,cy,status); &#125;&#125;int main()&#123; cin&gt;&gt;m&gt;&gt;n&gt;&gt;Y&gt;&gt;X; rep1(i,n) rep1(j,m) &#123; char c;cin&gt;&gt;c; s[i][j]=(c=='#'?1:2); &#125; // step 1 dfs(X,Y,2); // step 2 rep1(i,n) &#123; dfs(i,0,3); dfs(i,m+1,3); &#125; rep1(j,m) &#123; dfs(0,j,3); dfs(n+1,j,3); &#125; //step 3 rep1(i,n) rep1(j,m) if(!vis[i][j]&amp;&amp;s[i][j]==1) &#123; ans++; dfs(i,j,1); &#125; cout&lt;&lt;ans; return 0;&#125;/*************************************************************End**************************************************************/ Tip’s answer: 第2步是需要找出在包含$(x,y)$的海的外面部分，而外面部分不分海陆，$x=3$即$x=(11)_2$，这样$1\&amp;3$与$2\&amp;3$都大于$0$了。]]></content>
      <categories>
        <category>算法</category>
        <category>Ural</category>
      </categories>
      <tags>
        <tag>DFS</tag>
        <tag>图论</tag>
        <tag>BFS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Welcome to Sir-kay's Blog!]]></title>
    <url>%2F2019%2F08%2F12%2FWelcome-to-Sir-kay's-Blog%2F</url>
    <content type="text"><![CDATA[Welcome to Sir-kay’s Blog!Think Once, Debug More. Think More, Debug Once.]]></content>
  </entry>
</search>
