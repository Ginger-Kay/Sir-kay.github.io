<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Ural 1250 Sea Burial 题解]]></title>
    <url>%2F2019%2F08%2F12%2FUral-1250-Sea-Burial-%E9%A2%98%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[Ural 1250 Sea Burial 题解题意给定一个$n\times m$的地图，$.$为水，$#$为陆，地图的外部是水(地图被水包围)。水为八连通，陆为四联通。联通的水称为海，联通的陆称为岛。海内可能有岛，岛内可能有海。给定$x,y$求在包含$(x,y)$(保证$(x,y)$为水)的海里面有多少岛。 输入第一行包含$m,n,y,x(1\le n,m\le 500,1\le x \le n,1\le y \le m)$ 以下若干行为一个$n\times m$的地图 题解考虑BFS或DFS(以下简称BFS) 从$(x,y)$BFS，找出包含$(x,y)$的海。 从地图外部(水)BFS，找出在包含$(x,y)$的海的外面部分。 执行完前两步，就可以知道包含$(x,y)$的海里面的部分，数出包含$(x,y)$的海里面的部分有多少岛即可。 Tip: 运用二进制可以使程序简便。记陆为$1$，岛为$2$。设我们需要的值为$x$，当前的值为$y$，只需判断$(x\&amp;y)$是否大于$0$即可。第1步时$x=2$，第2步时$x=3$(想一想，为什么，答案最后揭晓)，第3步时$x=1$。 程序 BFS 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239// #pragma GCC optimize(2)// #pragma G++ optimize(2)// #pragma comment(linker,"/STACK:102400000,102400000")// #include &lt;bits/stdc++.h&gt;#include &lt;map&gt;#include &lt;set&gt;#include &lt;list&gt;#include &lt;array&gt;#include &lt;cfenv&gt;#include &lt;cmath&gt;#include &lt;ctime&gt;#include &lt;deque&gt;#include &lt;mutex&gt;#include &lt;queue&gt;#include &lt;ratio&gt;#include &lt;regex&gt;#include &lt;stack&gt;#include &lt;tuple&gt;#include &lt;atomic&gt;#include &lt;bitset&gt;#include &lt;cctype&gt;#include &lt;cerrno&gt;#include &lt;cfloat&gt;#include &lt;chrono&gt;#include &lt;cstdio&gt;#include &lt;cwchar&gt;#include &lt;future&gt;#include &lt;limits&gt;#include &lt;locale&gt;#include &lt;memory&gt;#include &lt;random&gt;#include &lt;string&gt;#include &lt;thread&gt;#include &lt;vector&gt;#include &lt;cassert&gt;#include &lt;climits&gt;#include &lt;clocale&gt;#include &lt;complex&gt;#include &lt;csetjmp&gt;#include &lt;csignal&gt;#include &lt;cstdarg&gt;#include &lt;cstddef&gt;#include &lt;cstdint&gt;#include &lt;cstdlib&gt;#include &lt;cstring&gt;#include &lt;ctgmath&gt;#include &lt;cwctype&gt;#include &lt;fstream&gt;#include &lt;iomanip&gt;#include &lt;numeric&gt;#include &lt;sstream&gt;#include &lt;ccomplex&gt;#include &lt;cstdbool&gt;#include &lt;iostream&gt;#include &lt;typeinfo&gt;#include &lt;valarray&gt;#include &lt;algorithm&gt;#include &lt;cinttypes&gt;#include &lt;cstdalign&gt;#include &lt;stdexcept&gt;#include &lt;typeindex&gt;#include &lt;functional&gt;#include &lt;forward_list&gt;#include &lt;system_error&gt;#include &lt;unordered_map&gt;#include &lt;unordered_set&gt;#include &lt;scoped_allocator&gt;#include &lt;condition_variable&gt;// #include &lt;conio.h&gt;// #include &lt;windows.h&gt;using namespace std;typedef long long LL;typedef unsigned int ui;typedef unsigned long long ull;typedef float fl;typedef double ld;typedef long double LD;typedef pair&lt;int,int&gt; pii;#if (WIN32) || (WIN64) || (__WIN32) || (__WIN64) || (_WIN32) || (_WIN64) || (WINDOWS)#define lld "%I64d"#define llu "%I64u"#else#define lld "%lld"#define llu "%llu"#endif#define ui(n) ((unsigned int)(n))#define LL(n) ((long long)(n))#define ull(n) ((unsigned long long)(n))#define fl(n) ((float)(n))#define ld(n) ((double)(n))#define LD(n) ((long double)(n))#define char(n) ((char)(n))#define Bool(n) ((bool)(n))#define fixpoint(n) fixed&lt;&lt;setprecision(n)const int INF=1061109567;const int NINF=-1044266559;const LL LINF=4557430888798830399;const ld eps=1e-15;#define MOD (1000000007)#define PI (3.1415926535897932384626433832795028841971)/*#define MB_LEN_MAX 5#define SHRT_MIN (-32768)#define SHRT_MAX 32767#define USHRT_MAX 0xffffU#define INT_MIN (-2147483647 - 1)#define INT_MAX 2147483647#define UINT_MAX 0xffffffffU#define LONG_MIN (-2147483647L - 1)#define LONG_MAX 2147483647L#define ULONG_MAX 0xffffffffUL#define LLONG_MAX 9223372036854775807ll#define LLONG_MIN (-9223372036854775807ll - 1)#define ULLONG_MAX 0xffffffffffffffffull*/#define MP make_pair#define MT make_tuple#define All(a) (a).begin(),(a).end()#define pall(a) (a).rbegin(),(a).rend()#define log2(x) log(x)/log(2)#define Log(x,y) log(x)/log(y)#define SZ(a) ((int)(a).size())#define rep(i,n) for(int i=0;i&lt;((int)(n));i++)#define rep1(i,n) for(int i=1;i&lt;=((int)(n));i++)#define repa(i,a,n) for(int i=((int)(a));i&lt;((int)(n));i++)#define repa1(i,a,n) for(int i=((int)(a));i&lt;=((int)(n));i++)#define repd(i,n) for(int i=((int)(n))-1;i&gt;=0;i--)#define repd1(i,n) for(int i=((int)(n));i&gt;=1;i--)#define repda(i,n,a) for(int i=((int)(n));i&gt;((int)(a));i--)#define repda1(i,n,a) for(int i=((int)(n));i&gt;=((int)(a));i--)#define FOR(i,a,n,step) for(int i=((int)(a));i&lt;((int)(n));i+=((int)(step)))#define repv(itr,v) for(__typeof((v).begin()) itr=(v).begin();itr!=(v).end();itr++)#define repV(i,v) for(auto i:v)#define repE(i,v) for(auto &amp;i:v)#define MS(x,y) memset(x,y,sizeof(x))#define MC(x) MS(x,0)#define MINF(x) MS(x,63)#define MCP(x,y) memcpy(x,y,sizeof(y))#define sqr(x) ((x)*(x))#define UN(v) sort(All(v)),v.erase(unique(All(v)),v.end())#define filein(x) freopen(x,"r",stdin)#define fileout(x) freopen(x,"w",stdout)#define fileio(x)\ freopen(x".in","r",stdin);\ freopen(x".out","w",stdout)#define filein2(filename,name) ifstream name(filename,ios::in)#define fileout2(filename,name) ofstream name(filename,ios::out)#define file(filename,name) fstream name(filename,ios::in|ios::out)#define Pause system("pause")#define Cls system("cls")#define fs first#define sc second#define PC(x) putchar(x)#define GC(x) x=getchar()#define Endl PC('\n')#define SF scanf#define PF printfinline int Read()&#123; int X=0,w=0;char ch=0;while(!isdigit(ch))&#123;w|=ch=='-';ch=getchar();&#125;while(isdigit(ch))X=(X&lt;&lt;3)+(X&lt;&lt;1)+(ch^48),ch=getchar(); return w?-X:X;&#125;inline void Write(int x)&#123;if(x&lt;0)putchar('-'),x=-x;if(x&gt;9)Write(x/10);putchar(x%10+'0');&#125;inline LL powmod(LL a,LL b)&#123;LL RES=1;a%=MOD;assert(b&gt;=0);for(;b;b&gt;&gt;=1)&#123;if(b&amp;1)RES=RES*a%MOD;a=a*a%MOD;&#125;return RES%MOD;&#125;inline LL gcdll(LL a,LL b)&#123;return b?gcdll(b,a%b):a;&#125;const int dx[]=&#123;0,1,0,-1,1,-1,-1,1&#125;;const int dy[]=&#123;1,0,-1,0,-1,-1,1,1&#125;;/************************************************************Begin************************************************************/const int maxn=510;int n,m,X,Y,s[maxn][maxn],ans; // '#'=&gt;1(01) '.'=&gt;2(10)bool vis[maxn][maxn];inline void bfs(int sx,int sy,int status)&#123; vis[sx][sy]=1; queue&lt;pair&lt;int,int&gt; &gt; q;q.push(&#123;sx,sy&#125;); while(!q.empty()) &#123; int x=q.front().fs,y=q.front().sc;q.pop(); rep(i,8) &#123; if(s[x][y]==1&amp;&amp;i&gt;3) break; int cx=x+dx[i],cy=y+dy[i]; if(cx&gt;0&amp;&amp;cx&lt;=n&amp;&amp;cy&gt;0&amp;&amp;cy&lt;=m&amp;&amp;!vis[cx][cy]&amp;&amp;(s[cx][cy]&amp;status)) &#123; vis[cx][cy]=1; q.push(&#123;cx,cy&#125;); &#125; &#125; &#125;&#125;int main()&#123; cin&gt;&gt;m&gt;&gt;n&gt;&gt;Y&gt;&gt;X; rep1(i,n) rep1(j,m) &#123; char c;cin&gt;&gt;c; s[i][j]=(c=='#'?1:2); &#125; // step 1 bfs(X,Y,2); // step 2 rep1(i,n) &#123; bfs(i,0,3); bfs(i,m+1,3); &#125; rep1(j,m) &#123; bfs(0,j,3); bfs(n+1,j,3); &#125; //step 3 rep1(i,n) rep1(j,m) if(!vis[i][j]&amp;&amp;s[i][j]==1) &#123; ans++; bfs(i,j,1); &#125; cout&lt;&lt;ans; return 0;&#125;/*************************************************************End**************************************************************/ DFS(与BFS十分类似) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229// #pragma GCC optimize(2)// #pragma G++ optimize(2)// #pragma comment(linker,"/STACK:102400000,102400000")// #include &lt;bits/stdc++.h&gt;#include &lt;map&gt;#include &lt;set&gt;#include &lt;list&gt;#include &lt;array&gt;#include &lt;cfenv&gt;#include &lt;cmath&gt;#include &lt;ctime&gt;#include &lt;deque&gt;#include &lt;mutex&gt;#include &lt;queue&gt;#include &lt;ratio&gt;#include &lt;regex&gt;#include &lt;stack&gt;#include &lt;tuple&gt;#include &lt;atomic&gt;#include &lt;bitset&gt;#include &lt;cctype&gt;#include &lt;cerrno&gt;#include &lt;cfloat&gt;#include &lt;chrono&gt;#include &lt;cstdio&gt;#include &lt;cwchar&gt;#include &lt;future&gt;#include &lt;limits&gt;#include &lt;locale&gt;#include &lt;memory&gt;#include &lt;random&gt;#include &lt;string&gt;#include &lt;thread&gt;#include &lt;vector&gt;#include &lt;cassert&gt;#include &lt;climits&gt;#include &lt;clocale&gt;#include &lt;complex&gt;#include &lt;csetjmp&gt;#include &lt;csignal&gt;#include &lt;cstdarg&gt;#include &lt;cstddef&gt;#include &lt;cstdint&gt;#include &lt;cstdlib&gt;#include &lt;cstring&gt;#include &lt;ctgmath&gt;#include &lt;cwctype&gt;#include &lt;fstream&gt;#include &lt;iomanip&gt;#include &lt;numeric&gt;#include &lt;sstream&gt;#include &lt;ccomplex&gt;#include &lt;cstdbool&gt;#include &lt;iostream&gt;#include &lt;typeinfo&gt;#include &lt;valarray&gt;#include &lt;algorithm&gt;#include &lt;cinttypes&gt;#include &lt;cstdalign&gt;#include &lt;stdexcept&gt;#include &lt;typeindex&gt;#include &lt;functional&gt;#include &lt;forward_list&gt;#include &lt;system_error&gt;#include &lt;unordered_map&gt;#include &lt;unordered_set&gt;#include &lt;scoped_allocator&gt;#include &lt;condition_variable&gt;// #include &lt;conio.h&gt;// #include &lt;windows.h&gt;using namespace std;typedef long long LL;typedef unsigned int ui;typedef unsigned long long ull;typedef float fl;typedef double ld;typedef long double LD;typedef pair&lt;int,int&gt; pii;#if (WIN32) || (WIN64) || (__WIN32) || (__WIN64) || (_WIN32) || (_WIN64) || (WINDOWS)#define lld "%I64d"#define llu "%I64u"#else#define lld "%lld"#define llu "%llu"#endif#define ui(n) ((unsigned int)(n))#define LL(n) ((long long)(n))#define ull(n) ((unsigned long long)(n))#define fl(n) ((float)(n))#define ld(n) ((double)(n))#define LD(n) ((long double)(n))#define char(n) ((char)(n))#define Bool(n) ((bool)(n))#define fixpoint(n) fixed&lt;&lt;setprecision(n)const int INF=1061109567;const int NINF=-1044266559;const LL LINF=4557430888798830399;const ld eps=1e-15;#define MOD (1000000007)#define PI (3.1415926535897932384626433832795028841971)/*#define MB_LEN_MAX 5#define SHRT_MIN (-32768)#define SHRT_MAX 32767#define USHRT_MAX 0xffffU#define INT_MIN (-2147483647 - 1)#define INT_MAX 2147483647#define UINT_MAX 0xffffffffU#define LONG_MIN (-2147483647L - 1)#define LONG_MAX 2147483647L#define ULONG_MAX 0xffffffffUL#define LLONG_MAX 9223372036854775807ll#define LLONG_MIN (-9223372036854775807ll - 1)#define ULLONG_MAX 0xffffffffffffffffull*/#define MP make_pair#define MT make_tuple#define All(a) (a).begin(),(a).end()#define pall(a) (a).rbegin(),(a).rend()#define log2(x) log(x)/log(2)#define Log(x,y) log(x)/log(y)#define SZ(a) ((int)(a).size())#define rep(i,n) for(int i=0;i&lt;((int)(n));i++)#define rep1(i,n) for(int i=1;i&lt;=((int)(n));i++)#define repa(i,a,n) for(int i=((int)(a));i&lt;((int)(n));i++)#define repa1(i,a,n) for(int i=((int)(a));i&lt;=((int)(n));i++)#define repd(i,n) for(int i=((int)(n))-1;i&gt;=0;i--)#define repd1(i,n) for(int i=((int)(n));i&gt;=1;i--)#define repda(i,n,a) for(int i=((int)(n));i&gt;((int)(a));i--)#define repda1(i,n,a) for(int i=((int)(n));i&gt;=((int)(a));i--)#define FOR(i,a,n,step) for(int i=((int)(a));i&lt;((int)(n));i+=((int)(step)))#define repv(itr,v) for(__typeof((v).begin()) itr=(v).begin();itr!=(v).end();itr++)#define repV(i,v) for(auto i:v)#define repE(i,v) for(auto &amp;i:v)#define MS(x,y) memset(x,y,sizeof(x))#define MC(x) MS(x,0)#define MINF(x) MS(x,63)#define MCP(x,y) memcpy(x,y,sizeof(y))#define sqr(x) ((x)*(x))#define UN(v) sort(All(v)),v.erase(unique(All(v)),v.end())#define filein(x) freopen(x,"r",stdin)#define fileout(x) freopen(x,"w",stdout)#define fileio(x)\ freopen(x".in","r",stdin);\ freopen(x".out","w",stdout)#define filein2(filename,name) ifstream name(filename,ios::in)#define fileout2(filename,name) ofstream name(filename,ios::out)#define file(filename,name) fstream name(filename,ios::in|ios::out)#define Pause system("pause")#define Cls system("cls")#define fs first#define sc second#define PC(x) putchar(x)#define GC(x) x=getchar()#define Endl PC('\n')#define SF scanf#define PF printfinline int Read()&#123; int X=0,w=0;char ch=0;while(!isdigit(ch))&#123;w|=ch=='-';ch=getchar();&#125;while(isdigit(ch))X=(X&lt;&lt;3)+(X&lt;&lt;1)+(ch^48),ch=getchar(); return w?-X:X;&#125;inline void Write(int x)&#123;if(x&lt;0)putchar('-'),x=-x;if(x&gt;9)Write(x/10);putchar(x%10+'0');&#125;inline LL powmod(LL a,LL b)&#123;LL RES=1;a%=MOD;assert(b&gt;=0);for(;b;b&gt;&gt;=1)&#123;if(b&amp;1)RES=RES*a%MOD;a=a*a%MOD;&#125;return RES%MOD;&#125;inline LL gcdll(LL a,LL b)&#123;return b?gcdll(b,a%b):a;&#125;const int dx[]=&#123;0,1,0,-1,1,-1,-1,1&#125;;const int dy[]=&#123;1,0,-1,0,-1,-1,1,1&#125;;/************************************************************Begin************************************************************/const int maxn=510;int n,m,X,Y,s[maxn][maxn],ans; // '#'=&gt;1(01) '.'=&gt;2(10)bool vis[maxn][maxn];inline void dfs(int x,int y,int status)&#123; vis[x][y]=1; rep(i,8) &#123; if(s[x][y]==1&amp;&amp;i&gt;3) break; int cx=x+dx[i],cy=y+dy[i]; if(cx&gt;0&amp;&amp;cx&lt;=n&amp;&amp;cy&gt;0&amp;&amp;cy&lt;=m&amp;&amp;!vis[cx][cy]&amp;&amp;(s[cx][cy]&amp;status)) dfs(cx,cy,status); &#125;&#125;int main()&#123; cin&gt;&gt;m&gt;&gt;n&gt;&gt;Y&gt;&gt;X; rep1(i,n) rep1(j,m) &#123; char c;cin&gt;&gt;c; s[i][j]=(c=='#'?1:2); &#125; // step 1 dfs(X,Y,2); // step 2 rep1(i,n) &#123; dfs(i,0,3); dfs(i,m+1,3); &#125; rep1(j,m) &#123; dfs(0,j,3); dfs(n+1,j,3); &#125; //step 3 rep1(i,n) rep1(j,m) if(!vis[i][j]&amp;&amp;s[i][j]==1) &#123; ans++; dfs(i,j,1); &#125; cout&lt;&lt;ans; return 0;&#125;/*************************************************************End**************************************************************/ Tip’s answer: 第2步是需要找出在包含$(x,y)$的海的外面部分，而外面部分不分海陆，$x=3$即$x=(11)_2$，这样$1\&amp;3$与$2\&amp;3$都大于$0$了。]]></content>
      <categories>
        <category>算法</category>
        <category>Ural</category>
      </categories>
      <tags>
        <tag>BFS</tag>
        <tag>DFS</tag>
        <tag>图论</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2019%2F08%2F12%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
</search>
